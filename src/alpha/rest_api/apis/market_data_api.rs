/*
 * Binance Alpha REST API
 *
 * OpenAPI Specification for the Binance Alpha REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#![allow(unused_imports)]
use async_trait::async_trait;
use derive_builder::Builder;
use reqwest;
use rust_decimal::prelude::*;
use serde::{Deserialize, Serialize};
use serde_json::{Value, json};
use std::collections::BTreeMap;

use crate::alpha::rest_api::models;
use crate::common::{
    config::ConfigurationRestApi,
    models::{ParamBuildError, RestApiResponse},
    utils::send_request,
};

const HAS_TIME_UNIT: bool = false;

#[async_trait]
pub trait MarketDataApi: Send + Sync {
    async fn aggregated_trades(
        &self,
        params: AggregatedTradesParams,
    ) -> anyhow::Result<RestApiResponse<models::AggregatedTradesResponse>>;
    async fn get_exchange_info(
        &self,
    ) -> anyhow::Result<RestApiResponse<models::GetExchangeInfoResponse>>;
    async fn klines(
        &self,
        params: KlinesParams,
    ) -> anyhow::Result<RestApiResponse<models::KlinesResponse>>;
    async fn ticker(
        &self,
        params: TickerParams,
    ) -> anyhow::Result<RestApiResponse<models::TickerResponse>>;
    async fn token_list(&self) -> anyhow::Result<RestApiResponse<models::TokenListResponse>>;
}

#[derive(Debug, Clone)]
pub struct MarketDataApiClient {
    configuration: ConfigurationRestApi,
}

impl MarketDataApiClient {
    pub fn new(configuration: ConfigurationRestApi) -> Self {
        Self { configuration }
    }
}

/// Request parameters for the [`aggregated_trades`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`aggregated_trades`](#method.aggregated_trades).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct AggregatedTradesParams {
    /// e.g., "`ALPHA_175USDT`" – use token ID from Token List
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// starting trade ID to fetch from
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub from_id: Option<i64>,
    /// start timestamp (milliseconds)
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    /// end timestamp (milliseconds)
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// number of results to return (default 500, max 1000)
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i64>,
}

impl AggregatedTradesParams {
    /// Create a builder for [`aggregated_trades`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — e.g., \"`ALPHA_175USDT`\" – use token ID from Token List
    ///
    #[must_use]
    pub fn builder(symbol: String) -> AggregatedTradesParamsBuilder {
        AggregatedTradesParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`klines`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`klines`](#method.klines).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct KlinesParams {
    /// e.g., "`ALPHA_175USDT`" – use token ID from Token List
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// e.g., "1h" – supported intervals: 1s, 15s, 1m, 3m, 5m, 15m, 30m, 1h, 2h, 4h, 6h, 8h, 12h, 1d, 3d, 1w, 1M
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub interval: String,
    /// number of results to return (default 500, max 1000)
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i64>,
    /// start timestamp (milliseconds)
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    /// end timestamp (milliseconds)
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
}

impl KlinesParams {
    /// Create a builder for [`klines`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — e.g., \"`ALPHA_175USDT`\" – use token ID from Token List
    /// * `interval` — e.g., \"1h\" – supported intervals: 1s, 15s, 1m, 3m, 5m, 15m, 30m, 1h, 2h, 4h, 6h, 8h, 12h, 1d, 3d, 1w, 1M
    ///
    #[must_use]
    pub fn builder(symbol: String, interval: String) -> KlinesParamsBuilder {
        KlinesParamsBuilder::default()
            .symbol(symbol)
            .interval(interval)
    }
}
/// Request parameters for the [`ticker`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`ticker`](#method.ticker).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct TickerParams {
    /// e.g., "`ALPHA_175USDT`" – use token ID from Token List
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
}

impl TickerParams {
    /// Create a builder for [`ticker`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — e.g., \"`ALPHA_175USDT`\" – use token ID from Token List
    ///
    #[must_use]
    pub fn builder(symbol: String) -> TickerParamsBuilder {
        TickerParamsBuilder::default().symbol(symbol)
    }
}

#[async_trait]
impl MarketDataApi for MarketDataApiClient {
    async fn aggregated_trades(
        &self,
        params: AggregatedTradesParams,
    ) -> anyhow::Result<RestApiResponse<models::AggregatedTradesResponse>> {
        let AggregatedTradesParams {
            symbol,
            from_id,
            start_time,
            end_time,
            limit,
        } = params;

        let mut query_params = BTreeMap::new();
        let body_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = from_id {
            query_params.insert("fromId".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        send_request::<models::AggregatedTradesResponse>(
            &self.configuration,
            "/bapi/defi/v1/public/alpha-trade/agg-trades",
            reqwest::Method::GET,
            query_params,
            body_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn get_exchange_info(
        &self,
    ) -> anyhow::Result<RestApiResponse<models::GetExchangeInfoResponse>> {
        let query_params = BTreeMap::new();
        let body_params = BTreeMap::new();

        send_request::<models::GetExchangeInfoResponse>(
            &self.configuration,
            "/bapi/defi/v1/public/alpha-trade/get-exchange-info",
            reqwest::Method::GET,
            query_params,
            body_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn klines(
        &self,
        params: KlinesParams,
    ) -> anyhow::Result<RestApiResponse<models::KlinesResponse>> {
        let KlinesParams {
            symbol,
            interval,
            limit,
            start_time,
            end_time,
        } = params;

        let mut query_params = BTreeMap::new();
        let body_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        query_params.insert("interval".to_string(), json!(interval));

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        send_request::<models::KlinesResponse>(
            &self.configuration,
            "/bapi/defi/v1/public/alpha-trade/klines",
            reqwest::Method::GET,
            query_params,
            body_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn ticker(
        &self,
        params: TickerParams,
    ) -> anyhow::Result<RestApiResponse<models::TickerResponse>> {
        let TickerParams { symbol } = params;

        let mut query_params = BTreeMap::new();
        let body_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        send_request::<models::TickerResponse>(
            &self.configuration,
            "/bapi/defi/v1/public/alpha-trade/ticker",
            reqwest::Method::GET,
            query_params,
            body_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn token_list(&self) -> anyhow::Result<RestApiResponse<models::TokenListResponse>> {
        let query_params = BTreeMap::new();
        let body_params = BTreeMap::new();

        send_request::<models::TokenListResponse>(
            &self.configuration,
            "/bapi/defi/v1/public/wallet-direct/buw/wallet/cex/alpha/all/token/list",
            reqwest::Method::GET,
            query_params,
            body_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }
}

#[cfg(all(test, feature = "alpha"))]
mod tests {
    use super::*;
    use crate::TOKIO_SHARED_RT;
    use crate::{errors::ConnectorError, models::DataFuture, models::RestApiRateLimit};
    use async_trait::async_trait;
    use std::collections::HashMap;

    struct DummyRestApiResponse<T> {
        inner: Box<dyn FnOnce() -> DataFuture<Result<T, ConnectorError>> + Send + Sync>,
        status: u16,
        headers: HashMap<String, String>,
        rate_limits: Option<Vec<RestApiRateLimit>>,
    }

    impl<T> From<DummyRestApiResponse<T>> for RestApiResponse<T> {
        fn from(dummy: DummyRestApiResponse<T>) -> Self {
            Self {
                data_fn: dummy.inner,
                status: dummy.status,
                headers: dummy.headers,
                rate_limits: dummy.rate_limits,
            }
        }
    }

    struct MockMarketDataApiClient {
        force_error: bool,
    }

    #[async_trait]
    impl MarketDataApi for MockMarketDataApiClient {
        async fn aggregated_trades(
            &self,
            _params: AggregatedTradesParams,
        ) -> anyhow::Result<RestApiResponse<models::AggregatedTradesResponse>> {
            if self.force_error {
                return Err(ConnectorError::ConnectorClientError {
                    msg: "ResponseError".to_string(),
                    code: None,
                }
                .into());
            }

            let resp_json: Value = serde_json::from_str(r#"{"code":"000000","message":"","messageDetail":"","data":[{"a":58470,"p":"1.00","q":"1.00","f":58470,"l":58665,"T":1752568680000,"m":true}]}"#).unwrap();
            let dummy_response: models::AggregatedTradesResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::AggregatedTradesResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_exchange_info(
            &self,
        ) -> anyhow::Result<RestApiResponse<models::GetExchangeInfoResponse>> {
            if self.force_error {
                return Err(ConnectorError::ConnectorClientError {
                    msg: "ResponseError".to_string(),
                    code: None,
                }
                .into());
            }

            let resp_json: Value = serde_json::from_str(r#"{"code":"000000","message":"","messageDetail":"","success":true,"data":{"timezone":"UTC","assets":[{"asset":"USDT"}],"symbols":[{"symbol":"ALPHA_105USDT","status":"TRADING","baseAsset":"ALPHA_105","quoteAsset":"USDT","pricePrecision":8,"quantityPrecision":8,"baseAssetPrecision":8,"quotePrecision":8,"filters":[{"filterType":"PRICE_FILTER","minPrice":"0.00000001","maxPrice":"1000","tickSize":"0.00000001"},{"filterType":"LOT_SIZE","stepSize":"0.01000000","maxQty":"277778","minQty":"0.01000000"},{"filterType":"MAX_NUM_ORDERS","limit":200},{"filterType":"MIN_NOTIONAL","minNotional":"0.1"},{"filterType":"MAX_NOTIONAL","maxNotional":"1000000"},{"filterType":"NOTIONAL","minNotional":"0.1","maxNotional":"1000000"},{"filterType":"PERCENT_PRICE","multiplierDown":"0.20000","multiplierUp":"5"},{"filterType":"PERCENT_PRICE_BY_SIDE","bidMultiplierUp":"5","askMultiplierUp":"5","bidMultiplierDown":"0.20000","askMultiplierDown":"0.20000"}],"orderTypes":["LIMIT"]}],"orderTypes":""}}"#).unwrap();
            let dummy_response: models::GetExchangeInfoResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetExchangeInfoResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn klines(
            &self,
            _params: KlinesParams,
        ) -> anyhow::Result<RestApiResponse<models::KlinesResponse>> {
            if self.force_error {
                return Err(ConnectorError::ConnectorClientError {
                    msg: "ResponseError".to_string(),
                    code: None,
                }
                .into());
            }

            let resp_json: Value = serde_json::from_str(r#"{"code":"000000","message":"","messageDetail":"","success":true,"data":[["1752642000000","0.00171473","0.00172515","0.00171473","0.00172515","1771.86000000","1752645599999","3.05093481","2","1771.86000000","3.05093481",0]]}"#).unwrap();
            let dummy_response: models::KlinesResponse = serde_json::from_value(resp_json.clone())
                .expect("should parse into models::KlinesResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn ticker(
            &self,
            _params: TickerParams,
        ) -> anyhow::Result<RestApiResponse<models::TickerResponse>> {
            if self.force_error {
                return Err(ConnectorError::ConnectorClientError {
                    msg: "ResponseError".to_string(),
                    code: None,
                }
                .into());
            }

            let resp_json: Value = serde_json::from_str(r#"{"code":"000000","message":"","messageDetail":"","data":{"symbol":"ALPHA_175USDT","priceChange":"-0.00007172","priceChangePercent":"-8.841","weightedAvgPrice":"0.00079608","lastPrice":"0.00073954","lastQty":"12600.43000000","openPrice":"0.00081126","highPrice":"0.00081126","lowPrice":"0.00073954","volume":"1204754.30000000","quoteVolume":"959.07729927","openTime":1768808100000,"closeTime":1768893244772,"firstId":93742,"lastId":93768,"count":38},"success":true}"#).unwrap();
            let dummy_response: models::TickerResponse = serde_json::from_value(resp_json.clone())
                .expect("should parse into models::TickerResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn token_list(&self) -> anyhow::Result<RestApiResponse<models::TokenListResponse>> {
            if self.force_error {
                return Err(ConnectorError::ConnectorClientError {
                    msg: "ResponseError".to_string(),
                    code: None,
                }
                .into());
            }

            let resp_json: Value = serde_json::from_str(r#"{"code":"000000","message":"","messageDetail":"","success":true,"data":[{"tokenId":"3F350C8B3621770A673159B7A19BC034","chainId":"56","chainIconUrl":"https://bin.bnbstatic.com/image/admin_mgs_image_upload/20250228/d0216ce4-a3e9-4bda-8937-4a6aa943ccf2.png","chainName":"BSC","contractAddress":"0xcf640fdf9b3d9e45cbd69fda91d7e22579c14444","name":"gorilla","symbol":"gorilla","iconUrl":"https://bin.bnbstatic.com/images/web3-data/public/token/logos/248b5406f88a4ee28913a29107875339.png","price":"0.00080595003978242023","percentChange24h":"-7.42","volume24h":"14847.711222633409558029675","marketCap":"805950.03978242","fdv":"805950.03978242","liquidity":"263192.72813121626034","totalSupply":"1000000000","circulatingSupply":"1000000000","holders":"7120","decimals":18,"listingCex":false,"hotTag":false,"cexCoinName":"","canTransfer":false,"denomination":1,"offline":false,"tradeDecimal":8,"alphaId":"ALPHA_175","offsell":false,"priceHigh24h":"0.00088873864475645879","priceLow24h":"0.0008020805165487083","count24h":"166","onlineTge":false,"onlineAirdrop":false,"score":1,"cexOffDisplay":false,"stockState":false,"listingTime":1746686700000,"mulPoint":1,"bnExclusiveState":false}]}"#).unwrap();
            let dummy_response: models::TokenListResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::TokenListResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }
    }

    #[test]
    fn aggregated_trades_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketDataApiClient { force_error: false };

            let params = AggregatedTradesParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"code":"000000","message":"","messageDetail":"","data":[{"a":58470,"p":"1.00","q":"1.00","f":58470,"l":58665,"T":1752568680000,"m":true}]}"#).unwrap();
            let expected_response : models::AggregatedTradesResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::AggregatedTradesResponse");

            let resp = client.aggregated_trades(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn aggregated_trades_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketDataApiClient { force_error: false };

            let params = AggregatedTradesParams::builder("symbol_example".to_string(),).from_id(1).start_time(1623319461670).end_time(1641782889000).limit(500).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"code":"000000","message":"","messageDetail":"","data":[{"a":58470,"p":"1.00","q":"1.00","f":58470,"l":58665,"T":1752568680000,"m":true}]}"#).unwrap();
            let expected_response : models::AggregatedTradesResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::AggregatedTradesResponse");

            let resp = client.aggregated_trades(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn aggregated_trades_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketDataApiClient { force_error: true };

            let params = AggregatedTradesParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.aggregated_trades(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_exchange_info_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketDataApiClient { force_error: false };


            let resp_json: Value = serde_json::from_str(r#"{"code":"000000","message":"","messageDetail":"","success":true,"data":{"timezone":"UTC","assets":[{"asset":"USDT"}],"symbols":[{"symbol":"ALPHA_105USDT","status":"TRADING","baseAsset":"ALPHA_105","quoteAsset":"USDT","pricePrecision":8,"quantityPrecision":8,"baseAssetPrecision":8,"quotePrecision":8,"filters":[{"filterType":"PRICE_FILTER","minPrice":"0.00000001","maxPrice":"1000","tickSize":"0.00000001"},{"filterType":"LOT_SIZE","stepSize":"0.01000000","maxQty":"277778","minQty":"0.01000000"},{"filterType":"MAX_NUM_ORDERS","limit":200},{"filterType":"MIN_NOTIONAL","minNotional":"0.1"},{"filterType":"MAX_NOTIONAL","maxNotional":"1000000"},{"filterType":"NOTIONAL","minNotional":"0.1","maxNotional":"1000000"},{"filterType":"PERCENT_PRICE","multiplierDown":"0.20000","multiplierUp":"5"},{"filterType":"PERCENT_PRICE_BY_SIDE","bidMultiplierUp":"5","askMultiplierUp":"5","bidMultiplierDown":"0.20000","askMultiplierDown":"0.20000"}],"orderTypes":["LIMIT"]}],"orderTypes":""}}"#).unwrap();
            let expected_response : models::GetExchangeInfoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetExchangeInfoResponse");

            let resp = client.get_exchange_info().await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_exchange_info_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketDataApiClient { force_error: false };


            let resp_json: Value = serde_json::from_str(r#"{"code":"000000","message":"","messageDetail":"","success":true,"data":{"timezone":"UTC","assets":[{"asset":"USDT"}],"symbols":[{"symbol":"ALPHA_105USDT","status":"TRADING","baseAsset":"ALPHA_105","quoteAsset":"USDT","pricePrecision":8,"quantityPrecision":8,"baseAssetPrecision":8,"quotePrecision":8,"filters":[{"filterType":"PRICE_FILTER","minPrice":"0.00000001","maxPrice":"1000","tickSize":"0.00000001"},{"filterType":"LOT_SIZE","stepSize":"0.01000000","maxQty":"277778","minQty":"0.01000000"},{"filterType":"MAX_NUM_ORDERS","limit":200},{"filterType":"MIN_NOTIONAL","minNotional":"0.1"},{"filterType":"MAX_NOTIONAL","maxNotional":"1000000"},{"filterType":"NOTIONAL","minNotional":"0.1","maxNotional":"1000000"},{"filterType":"PERCENT_PRICE","multiplierDown":"0.20000","multiplierUp":"5"},{"filterType":"PERCENT_PRICE_BY_SIDE","bidMultiplierUp":"5","askMultiplierUp":"5","bidMultiplierDown":"0.20000","askMultiplierDown":"0.20000"}],"orderTypes":["LIMIT"]}],"orderTypes":""}}"#).unwrap();
            let expected_response : models::GetExchangeInfoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetExchangeInfoResponse");

            let resp = client.get_exchange_info().await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_exchange_info_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketDataApiClient { force_error: true };

            match client.get_exchange_info().await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn klines_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketDataApiClient { force_error: false };

            let params = KlinesParams::builder("symbol_example".to_string(),"interval_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"code":"000000","message":"","messageDetail":"","success":true,"data":[["1752642000000","0.00171473","0.00172515","0.00171473","0.00172515","1771.86000000","1752645599999","3.05093481","2","1771.86000000","3.05093481",0]]}"#).unwrap();
            let expected_response : models::KlinesResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::KlinesResponse");

            let resp = client.klines(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn klines_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketDataApiClient { force_error: false };

            let params = KlinesParams::builder("symbol_example".to_string(),"interval_example".to_string(),).limit(500).start_time(1623319461670).end_time(1641782889000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"code":"000000","message":"","messageDetail":"","success":true,"data":[["1752642000000","0.00171473","0.00172515","0.00171473","0.00172515","1771.86000000","1752645599999","3.05093481","2","1771.86000000","3.05093481",0]]}"#).unwrap();
            let expected_response : models::KlinesResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::KlinesResponse");

            let resp = client.klines(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn klines_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketDataApiClient { force_error: true };

            let params =
                KlinesParams::builder("symbol_example".to_string(), "interval_example".to_string())
                    .build()
                    .unwrap();

            match client.klines(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn ticker_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketDataApiClient { force_error: false };

            let params = TickerParams::builder("symbol_example".to_string()).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"code":"000000","message":"","messageDetail":"","data":{"symbol":"ALPHA_175USDT","priceChange":"-0.00007172","priceChangePercent":"-8.841","weightedAvgPrice":"0.00079608","lastPrice":"0.00073954","lastQty":"12600.43000000","openPrice":"0.00081126","highPrice":"0.00081126","lowPrice":"0.00073954","volume":"1204754.30000000","quoteVolume":"959.07729927","openTime":1768808100000,"closeTime":1768893244772,"firstId":93742,"lastId":93768,"count":38},"success":true}"#).unwrap();
            let expected_response : models::TickerResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::TickerResponse");

            let resp = client.ticker(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ticker_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketDataApiClient { force_error: false };

            let params = TickerParams::builder("symbol_example".to_string()).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"code":"000000","message":"","messageDetail":"","data":{"symbol":"ALPHA_175USDT","priceChange":"-0.00007172","priceChangePercent":"-8.841","weightedAvgPrice":"0.00079608","lastPrice":"0.00073954","lastQty":"12600.43000000","openPrice":"0.00081126","highPrice":"0.00081126","lowPrice":"0.00073954","volume":"1204754.30000000","quoteVolume":"959.07729927","openTime":1768808100000,"closeTime":1768893244772,"firstId":93742,"lastId":93768,"count":38},"success":true}"#).unwrap();
            let expected_response : models::TickerResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::TickerResponse");

            let resp = client.ticker(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ticker_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketDataApiClient { force_error: true };

            let params = TickerParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.ticker(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn token_list_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketDataApiClient { force_error: false };


            let resp_json: Value = serde_json::from_str(r#"{"code":"000000","message":"","messageDetail":"","success":true,"data":[{"tokenId":"3F350C8B3621770A673159B7A19BC034","chainId":"56","chainIconUrl":"https://bin.bnbstatic.com/image/admin_mgs_image_upload/20250228/d0216ce4-a3e9-4bda-8937-4a6aa943ccf2.png","chainName":"BSC","contractAddress":"0xcf640fdf9b3d9e45cbd69fda91d7e22579c14444","name":"gorilla","symbol":"gorilla","iconUrl":"https://bin.bnbstatic.com/images/web3-data/public/token/logos/248b5406f88a4ee28913a29107875339.png","price":"0.00080595003978242023","percentChange24h":"-7.42","volume24h":"14847.711222633409558029675","marketCap":"805950.03978242","fdv":"805950.03978242","liquidity":"263192.72813121626034","totalSupply":"1000000000","circulatingSupply":"1000000000","holders":"7120","decimals":18,"listingCex":false,"hotTag":false,"cexCoinName":"","canTransfer":false,"denomination":1,"offline":false,"tradeDecimal":8,"alphaId":"ALPHA_175","offsell":false,"priceHigh24h":"0.00088873864475645879","priceLow24h":"0.0008020805165487083","count24h":"166","onlineTge":false,"onlineAirdrop":false,"score":1,"cexOffDisplay":false,"stockState":false,"listingTime":1746686700000,"mulPoint":1,"bnExclusiveState":false}]}"#).unwrap();
            let expected_response : models::TokenListResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::TokenListResponse");

            let resp = client.token_list().await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn token_list_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketDataApiClient { force_error: false };


            let resp_json: Value = serde_json::from_str(r#"{"code":"000000","message":"","messageDetail":"","success":true,"data":[{"tokenId":"3F350C8B3621770A673159B7A19BC034","chainId":"56","chainIconUrl":"https://bin.bnbstatic.com/image/admin_mgs_image_upload/20250228/d0216ce4-a3e9-4bda-8937-4a6aa943ccf2.png","chainName":"BSC","contractAddress":"0xcf640fdf9b3d9e45cbd69fda91d7e22579c14444","name":"gorilla","symbol":"gorilla","iconUrl":"https://bin.bnbstatic.com/images/web3-data/public/token/logos/248b5406f88a4ee28913a29107875339.png","price":"0.00080595003978242023","percentChange24h":"-7.42","volume24h":"14847.711222633409558029675","marketCap":"805950.03978242","fdv":"805950.03978242","liquidity":"263192.72813121626034","totalSupply":"1000000000","circulatingSupply":"1000000000","holders":"7120","decimals":18,"listingCex":false,"hotTag":false,"cexCoinName":"","canTransfer":false,"denomination":1,"offline":false,"tradeDecimal":8,"alphaId":"ALPHA_175","offsell":false,"priceHigh24h":"0.00088873864475645879","priceLow24h":"0.0008020805165487083","count24h":"166","onlineTge":false,"onlineAirdrop":false,"score":1,"cexOffDisplay":false,"stockState":false,"listingTime":1746686700000,"mulPoint":1,"bnExclusiveState":false}]}"#).unwrap();
            let expected_response : models::TokenListResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::TokenListResponse");

            let resp = client.token_list().await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn token_list_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketDataApiClient { force_error: true };

            match client.token_list().await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }
}
