/*
 * Binance Staking REST API
 *
 * OpenAPI Specification for the Binance Staking REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#![allow(unused_imports)]
use async_trait::async_trait;
use derive_builder::Builder;
use reqwest;
use rust_decimal::prelude::*;
use serde::{Deserialize, Serialize};
use serde_json::{Value, json};
use std::collections::BTreeMap;

use crate::common::{
    config::ConfigurationRestApi,
    models::{ParamBuildError, RestApiResponse},
    utils::send_request,
};
use crate::staking::rest_api::models;

const HAS_TIME_UNIT: bool = false;

#[async_trait]
pub trait EthStakingApi: Send + Sync {
    async fn eth_staking_account(
        &self,
        params: EthStakingAccountParams,
    ) -> anyhow::Result<RestApiResponse<models::EthStakingAccountResponse>>;
    async fn get_current_eth_staking_quota(
        &self,
        params: GetCurrentEthStakingQuotaParams,
    ) -> anyhow::Result<RestApiResponse<models::GetCurrentEthStakingQuotaResponse>>;
    async fn get_eth_redemption_history(
        &self,
        params: GetEthRedemptionHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetEthRedemptionHistoryResponse>>;
    async fn get_eth_staking_history(
        &self,
        params: GetEthStakingHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetEthStakingHistoryResponse>>;
    async fn get_wbeth_rate_history(
        &self,
        params: GetWbethRateHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetWbethRateHistoryResponse>>;
    async fn get_wbeth_rewards_history(
        &self,
        params: GetWbethRewardsHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetWbethRewardsHistoryResponse>>;
    async fn get_wbeth_unwrap_history(
        &self,
        params: GetWbethUnwrapHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetWbethUnwrapHistoryResponse>>;
    async fn get_wbeth_wrap_history(
        &self,
        params: GetWbethWrapHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetWbethWrapHistoryResponse>>;
    async fn redeem_eth(
        &self,
        params: RedeemEthParams,
    ) -> anyhow::Result<RestApiResponse<models::RedeemEthResponse>>;
    async fn subscribe_eth_staking(
        &self,
        params: SubscribeEthStakingParams,
    ) -> anyhow::Result<RestApiResponse<models::SubscribeEthStakingResponse>>;
    async fn wrap_beth(
        &self,
        params: WrapBethParams,
    ) -> anyhow::Result<RestApiResponse<models::WrapBethResponse>>;
}

#[derive(Debug, Clone)]
pub struct EthStakingApiClient {
    configuration: ConfigurationRestApi,
}

impl EthStakingApiClient {
    pub fn new(configuration: ConfigurationRestApi) -> Self {
        Self { configuration }
    }
}

/// Request parameters for the [`eth_staking_account`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`eth_staking_account`](#method.eth_staking_account).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct EthStakingAccountParams {
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl EthStakingAccountParams {
    /// Create a builder for [`eth_staking_account`].
    ///
    #[must_use]
    pub fn builder() -> EthStakingAccountParamsBuilder {
        EthStakingAccountParamsBuilder::default()
    }
}
/// Request parameters for the [`get_current_eth_staking_quota`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_current_eth_staking_quota`](#method.get_current_eth_staking_quota).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetCurrentEthStakingQuotaParams {
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetCurrentEthStakingQuotaParams {
    /// Create a builder for [`get_current_eth_staking_quota`].
    ///
    #[must_use]
    pub fn builder() -> GetCurrentEthStakingQuotaParamsBuilder {
        GetCurrentEthStakingQuotaParamsBuilder::default()
    }
}
/// Request parameters for the [`get_eth_redemption_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_eth_redemption_history`](#method.get_eth_redemption_history).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetEthRedemptionHistoryParams {
    ///
    /// The `start_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Currently querying page. Start from 1. Default:1
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub current: Option<i64>,
    /// Default:10, Max:100
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub size: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetEthRedemptionHistoryParams {
    /// Create a builder for [`get_eth_redemption_history`].
    ///
    #[must_use]
    pub fn builder() -> GetEthRedemptionHistoryParamsBuilder {
        GetEthRedemptionHistoryParamsBuilder::default()
    }
}
/// Request parameters for the [`get_eth_staking_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_eth_staking_history`](#method.get_eth_staking_history).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetEthStakingHistoryParams {
    ///
    /// The `start_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Currently querying page. Start from 1. Default:1
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub current: Option<i64>,
    /// Default:10, Max:100
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub size: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetEthStakingHistoryParams {
    /// Create a builder for [`get_eth_staking_history`].
    ///
    #[must_use]
    pub fn builder() -> GetEthStakingHistoryParamsBuilder {
        GetEthStakingHistoryParamsBuilder::default()
    }
}
/// Request parameters for the [`get_wbeth_rate_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_wbeth_rate_history`](#method.get_wbeth_rate_history).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetWbethRateHistoryParams {
    ///
    /// The `start_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Currently querying page. Start from 1. Default:1
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub current: Option<i64>,
    /// Default:10, Max:100
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub size: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetWbethRateHistoryParams {
    /// Create a builder for [`get_wbeth_rate_history`].
    ///
    #[must_use]
    pub fn builder() -> GetWbethRateHistoryParamsBuilder {
        GetWbethRateHistoryParamsBuilder::default()
    }
}
/// Request parameters for the [`get_wbeth_rewards_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_wbeth_rewards_history`](#method.get_wbeth_rewards_history).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetWbethRewardsHistoryParams {
    ///
    /// The `start_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Currently querying page. Start from 1. Default:1
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub current: Option<i64>,
    /// Default:10, Max:100
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub size: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetWbethRewardsHistoryParams {
    /// Create a builder for [`get_wbeth_rewards_history`].
    ///
    #[must_use]
    pub fn builder() -> GetWbethRewardsHistoryParamsBuilder {
        GetWbethRewardsHistoryParamsBuilder::default()
    }
}
/// Request parameters for the [`get_wbeth_unwrap_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_wbeth_unwrap_history`](#method.get_wbeth_unwrap_history).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetWbethUnwrapHistoryParams {
    ///
    /// The `start_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Currently querying page. Start from 1. Default:1
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub current: Option<i64>,
    /// Default:10, Max:100
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub size: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetWbethUnwrapHistoryParams {
    /// Create a builder for [`get_wbeth_unwrap_history`].
    ///
    #[must_use]
    pub fn builder() -> GetWbethUnwrapHistoryParamsBuilder {
        GetWbethUnwrapHistoryParamsBuilder::default()
    }
}
/// Request parameters for the [`get_wbeth_wrap_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_wbeth_wrap_history`](#method.get_wbeth_wrap_history).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetWbethWrapHistoryParams {
    ///
    /// The `start_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Currently querying page. Start from 1. Default:1
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub current: Option<i64>,
    /// Default:10, Max:100
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub size: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetWbethWrapHistoryParams {
    /// Create a builder for [`get_wbeth_wrap_history`].
    ///
    #[must_use]
    pub fn builder() -> GetWbethWrapHistoryParamsBuilder {
        GetWbethWrapHistoryParamsBuilder::default()
    }
}
/// Request parameters for the [`redeem_eth`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`redeem_eth`](#method.redeem_eth).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct RedeemEthParams {
    /// Amount in SOL.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub amount: rust_decimal::Decimal,
    /// WBETH or BETH, default to BETH
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub asset: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl RedeemEthParams {
    /// Create a builder for [`redeem_eth`].
    ///
    /// Required parameters:
    ///
    /// * `amount` — Amount in SOL.
    ///
    #[must_use]
    pub fn builder(amount: rust_decimal::Decimal) -> RedeemEthParamsBuilder {
        RedeemEthParamsBuilder::default().amount(amount)
    }
}
/// Request parameters for the [`subscribe_eth_staking`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`subscribe_eth_staking`](#method.subscribe_eth_staking).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct SubscribeEthStakingParams {
    /// Amount in SOL.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub amount: rust_decimal::Decimal,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl SubscribeEthStakingParams {
    /// Create a builder for [`subscribe_eth_staking`].
    ///
    /// Required parameters:
    ///
    /// * `amount` — Amount in SOL.
    ///
    #[must_use]
    pub fn builder(amount: rust_decimal::Decimal) -> SubscribeEthStakingParamsBuilder {
        SubscribeEthStakingParamsBuilder::default().amount(amount)
    }
}
/// Request parameters for the [`wrap_beth`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`wrap_beth`](#method.wrap_beth).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct WrapBethParams {
    /// Amount in SOL.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub amount: rust_decimal::Decimal,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl WrapBethParams {
    /// Create a builder for [`wrap_beth`].
    ///
    /// Required parameters:
    ///
    /// * `amount` — Amount in SOL.
    ///
    #[must_use]
    pub fn builder(amount: rust_decimal::Decimal) -> WrapBethParamsBuilder {
        WrapBethParamsBuilder::default().amount(amount)
    }
}

#[async_trait]
impl EthStakingApi for EthStakingApiClient {
    async fn eth_staking_account(
        &self,
        params: EthStakingAccountParams,
    ) -> anyhow::Result<RestApiResponse<models::EthStakingAccountResponse>> {
        let EthStakingAccountParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::EthStakingAccountResponse>(
            &self.configuration,
            "/sapi/v2/eth-staking/account",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_current_eth_staking_quota(
        &self,
        params: GetCurrentEthStakingQuotaParams,
    ) -> anyhow::Result<RestApiResponse<models::GetCurrentEthStakingQuotaResponse>> {
        let GetCurrentEthStakingQuotaParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetCurrentEthStakingQuotaResponse>(
            &self.configuration,
            "/sapi/v1/eth-staking/eth/quota",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_eth_redemption_history(
        &self,
        params: GetEthRedemptionHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetEthRedemptionHistoryResponse>> {
        let GetEthRedemptionHistoryParams {
            start_time,
            end_time,
            current,
            size,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = current {
            query_params.insert("current".to_string(), json!(rw));
        }

        if let Some(rw) = size {
            query_params.insert("size".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetEthRedemptionHistoryResponse>(
            &self.configuration,
            "/sapi/v1/eth-staking/eth/history/redemptionHistory",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_eth_staking_history(
        &self,
        params: GetEthStakingHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetEthStakingHistoryResponse>> {
        let GetEthStakingHistoryParams {
            start_time,
            end_time,
            current,
            size,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = current {
            query_params.insert("current".to_string(), json!(rw));
        }

        if let Some(rw) = size {
            query_params.insert("size".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetEthStakingHistoryResponse>(
            &self.configuration,
            "/sapi/v1/eth-staking/eth/history/stakingHistory",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_wbeth_rate_history(
        &self,
        params: GetWbethRateHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetWbethRateHistoryResponse>> {
        let GetWbethRateHistoryParams {
            start_time,
            end_time,
            current,
            size,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = current {
            query_params.insert("current".to_string(), json!(rw));
        }

        if let Some(rw) = size {
            query_params.insert("size".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetWbethRateHistoryResponse>(
            &self.configuration,
            "/sapi/v1/eth-staking/eth/history/rateHistory",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_wbeth_rewards_history(
        &self,
        params: GetWbethRewardsHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetWbethRewardsHistoryResponse>> {
        let GetWbethRewardsHistoryParams {
            start_time,
            end_time,
            current,
            size,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = current {
            query_params.insert("current".to_string(), json!(rw));
        }

        if let Some(rw) = size {
            query_params.insert("size".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetWbethRewardsHistoryResponse>(
            &self.configuration,
            "/sapi/v1/eth-staking/eth/history/wbethRewardsHistory",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_wbeth_unwrap_history(
        &self,
        params: GetWbethUnwrapHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetWbethUnwrapHistoryResponse>> {
        let GetWbethUnwrapHistoryParams {
            start_time,
            end_time,
            current,
            size,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = current {
            query_params.insert("current".to_string(), json!(rw));
        }

        if let Some(rw) = size {
            query_params.insert("size".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetWbethUnwrapHistoryResponse>(
            &self.configuration,
            "/sapi/v1/eth-staking/wbeth/history/unwrapHistory",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_wbeth_wrap_history(
        &self,
        params: GetWbethWrapHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetWbethWrapHistoryResponse>> {
        let GetWbethWrapHistoryParams {
            start_time,
            end_time,
            current,
            size,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = current {
            query_params.insert("current".to_string(), json!(rw));
        }

        if let Some(rw) = size {
            query_params.insert("size".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetWbethWrapHistoryResponse>(
            &self.configuration,
            "/sapi/v1/eth-staking/wbeth/history/wrapHistory",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn redeem_eth(
        &self,
        params: RedeemEthParams,
    ) -> anyhow::Result<RestApiResponse<models::RedeemEthResponse>> {
        let RedeemEthParams {
            amount,
            asset,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("amount".to_string(), json!(amount));

        if let Some(rw) = asset {
            query_params.insert("asset".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::RedeemEthResponse>(
            &self.configuration,
            "/sapi/v1/eth-staking/eth/redeem",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn subscribe_eth_staking(
        &self,
        params: SubscribeEthStakingParams,
    ) -> anyhow::Result<RestApiResponse<models::SubscribeEthStakingResponse>> {
        let SubscribeEthStakingParams {
            amount,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("amount".to_string(), json!(amount));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::SubscribeEthStakingResponse>(
            &self.configuration,
            "/sapi/v2/eth-staking/eth/stake",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn wrap_beth(
        &self,
        params: WrapBethParams,
    ) -> anyhow::Result<RestApiResponse<models::WrapBethResponse>> {
        let WrapBethParams {
            amount,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("amount".to_string(), json!(amount));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::WrapBethResponse>(
            &self.configuration,
            "/sapi/v1/eth-staking/wbeth/wrap",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }
}

#[cfg(all(test, feature = "staking"))]
mod tests {
    use super::*;
    use crate::TOKIO_SHARED_RT;
    use crate::{errors::ConnectorError, models::DataFuture, models::RestApiRateLimit};
    use async_trait::async_trait;
    use std::collections::HashMap;

    struct DummyRestApiResponse<T> {
        inner: Box<dyn FnOnce() -> DataFuture<Result<T, ConnectorError>> + Send + Sync>,
        status: u16,
        headers: HashMap<String, String>,
        rate_limits: Option<Vec<RestApiRateLimit>>,
    }

    impl<T> From<DummyRestApiResponse<T>> for RestApiResponse<T> {
        fn from(dummy: DummyRestApiResponse<T>) -> Self {
            Self {
                data_fn: dummy.inner,
                status: dummy.status,
                headers: dummy.headers,
                rate_limits: dummy.rate_limits,
            }
        }
    }

    struct MockEthStakingApiClient {
        force_error: bool,
    }

    #[async_trait]
    impl EthStakingApi for MockEthStakingApiClient {
        async fn eth_staking_account(
            &self,
            _params: EthStakingAccountParams,
        ) -> anyhow::Result<RestApiResponse<models::EthStakingAccountResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"holdingInETH":"1.22330928","holdings":{"wbethAmount":"1.10928781","bethAmount":"1.90002112"},"thirtyDaysProfitInETH":"0.22330928","profit":{"amountFromWBETH":"0.12330928","amountFromBETH":"0.1"}}"#).unwrap();
            let dummy_response: models::EthStakingAccountResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::EthStakingAccountResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_current_eth_staking_quota(
            &self,
            _params: GetCurrentEthStakingQuotaParams,
        ) -> anyhow::Result<RestApiResponse<models::GetCurrentEthStakingQuotaResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"leftStakingPersonalQuota":"1000","leftRedemptionPersonalQuota":"1000","minStakeAmount":"0.00010000","minRedeemAmount":"0.00000001","redeemPeriod":20,"stakeable":true,"redeemable":true,"commissionFee":"0.05000000","calculating":false}"#).unwrap();
            let dummy_response: models::GetCurrentEthStakingQuotaResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetCurrentEthStakingQuotaResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_eth_redemption_history(
            &self,
            _params: GetEthRedemptionHistoryParams,
        ) -> anyhow::Result<RestApiResponse<models::GetEthRedemptionHistoryResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"time":1575018510000,"arrivalTime":1575018510000,"asset":"WBETH","amount":"21312.23223","distributeAsset":"ETH","distributeAmount":"21338.0699","conversionRatio":"1.00121234","status":"SUCCESS"}],"total":1}"#).unwrap();
            let dummy_response: models::GetEthRedemptionHistoryResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetEthRedemptionHistoryResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_eth_staking_history(
            &self,
            _params: GetEthStakingHistoryParams,
        ) -> anyhow::Result<RestApiResponse<models::GetEthStakingHistoryResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"time":1575018510000,"asset":"ETH","amount":"21312.23223","distributeAsset":"WBETH","distributeAmount":"21286.42584","conversionRatio":"1.00121234","status":"SUCCESS"}],"total":1}"#).unwrap();
            let dummy_response: models::GetEthStakingHistoryResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetEthStakingHistoryResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_wbeth_rate_history(
            &self,
            _params: GetWbethRateHistoryParams,
        ) -> anyhow::Result<RestApiResponse<models::GetWbethRateHistoryResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"annualPercentageRate":"0.00006408","exchangeRate":"1.00121234","time":1577233578000}],"total":"1"}"#).unwrap();
            let dummy_response: models::GetWbethRateHistoryResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetWbethRateHistoryResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_wbeth_rewards_history(
            &self,
            _params: GetWbethRewardsHistoryParams,
        ) -> anyhow::Result<RestApiResponse<models::GetWbethRewardsHistoryResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"estRewardsInETH":"1.23230920","rows":[{"time":1575018510000,"amountInETH":"0.23223","holding":"2.3223","holdingInETH":"2.4231","annualPercentageRate":"0.5"}],"total":1}"#).unwrap();
            let dummy_response: models::GetWbethRewardsHistoryResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetWbethRewardsHistoryResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_wbeth_unwrap_history(
            &self,
            _params: GetWbethUnwrapHistoryParams,
        ) -> anyhow::Result<RestApiResponse<models::GetWbethUnwrapHistoryResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"time":1575018510000,"fromAsset":"WBETH","fromAmount":"21312.23223","toAsset":"BETH","toAmount":"21312.23223","exchangeRate":"1.01243253","status":"SUCCESS"}],"total":1}"#).unwrap();
            let dummy_response: models::GetWbethUnwrapHistoryResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetWbethUnwrapHistoryResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_wbeth_wrap_history(
            &self,
            _params: GetWbethWrapHistoryParams,
        ) -> anyhow::Result<RestApiResponse<models::GetWbethWrapHistoryResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"time":1575018510000,"fromAsset":"BETH","fromAmount":"21312.23223","toAsset":"WBETH","toAmount":"21312.23223","exchangeRate":"1.01243253","status":"SUCCESS"}],"total":1}"#).unwrap();
            let dummy_response: models::GetWbethWrapHistoryResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetWbethWrapHistoryResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn redeem_eth(
            &self,
            _params: RedeemEthParams,
        ) -> anyhow::Result<RestApiResponse<models::RedeemEthResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"success":true,"ethAmount":"0.23092091","conversionRatio":"1.00121234","arrivalTime":1575018510000}"#).unwrap();
            let dummy_response: models::RedeemEthResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::RedeemEthResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn subscribe_eth_staking(
            &self,
            _params: SubscribeEthStakingParams,
        ) -> anyhow::Result<RestApiResponse<models::SubscribeEthStakingResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(
                r#"{"success":true,"wbethAmount":"0.23092091","conversionRatio":"1.001212342342"}"#,
            )
            .unwrap();
            let dummy_response: models::SubscribeEthStakingResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::SubscribeEthStakingResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn wrap_beth(
            &self,
            _params: WrapBethParams,
        ) -> anyhow::Result<RestApiResponse<models::WrapBethResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(
                r#"{"success":true,"wbethAmount":"0.23092091","exchangeRate":"1.001212343432"}"#,
            )
            .unwrap();
            let dummy_response: models::WrapBethResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::WrapBethResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }
    }

    #[test]
    fn eth_staking_account_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: false };

            let params = EthStakingAccountParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"holdingInETH":"1.22330928","holdings":{"wbethAmount":"1.10928781","bethAmount":"1.90002112"},"thirtyDaysProfitInETH":"0.22330928","profit":{"amountFromWBETH":"0.12330928","amountFromBETH":"0.1"}}"#).unwrap();
            let expected_response : models::EthStakingAccountResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::EthStakingAccountResponse");

            let resp = client.eth_staking_account(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn eth_staking_account_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: false };

            let params = EthStakingAccountParams::builder().recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"holdingInETH":"1.22330928","holdings":{"wbethAmount":"1.10928781","bethAmount":"1.90002112"},"thirtyDaysProfitInETH":"0.22330928","profit":{"amountFromWBETH":"0.12330928","amountFromBETH":"0.1"}}"#).unwrap();
            let expected_response : models::EthStakingAccountResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::EthStakingAccountResponse");

            let resp = client.eth_staking_account(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn eth_staking_account_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: true };

            let params = EthStakingAccountParams::builder().build().unwrap();

            match client.eth_staking_account(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_current_eth_staking_quota_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: false };

            let params = GetCurrentEthStakingQuotaParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"leftStakingPersonalQuota":"1000","leftRedemptionPersonalQuota":"1000","minStakeAmount":"0.00010000","minRedeemAmount":"0.00000001","redeemPeriod":20,"stakeable":true,"redeemable":true,"commissionFee":"0.05000000","calculating":false}"#).unwrap();
            let expected_response : models::GetCurrentEthStakingQuotaResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetCurrentEthStakingQuotaResponse");

            let resp = client.get_current_eth_staking_quota(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_current_eth_staking_quota_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: false };

            let params = GetCurrentEthStakingQuotaParams::builder().recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"leftStakingPersonalQuota":"1000","leftRedemptionPersonalQuota":"1000","minStakeAmount":"0.00010000","minRedeemAmount":"0.00000001","redeemPeriod":20,"stakeable":true,"redeemable":true,"commissionFee":"0.05000000","calculating":false}"#).unwrap();
            let expected_response : models::GetCurrentEthStakingQuotaResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetCurrentEthStakingQuotaResponse");

            let resp = client.get_current_eth_staking_quota(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_current_eth_staking_quota_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: true };

            let params = GetCurrentEthStakingQuotaParams::builder().build().unwrap();

            match client.get_current_eth_staking_quota(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_eth_redemption_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: false };

            let params = GetEthRedemptionHistoryParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"time":1575018510000,"arrivalTime":1575018510000,"asset":"WBETH","amount":"21312.23223","distributeAsset":"ETH","distributeAmount":"21338.0699","conversionRatio":"1.00121234","status":"SUCCESS"}],"total":1}"#).unwrap();
            let expected_response : models::GetEthRedemptionHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetEthRedemptionHistoryResponse");

            let resp = client.get_eth_redemption_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_eth_redemption_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: false };

            let params = GetEthRedemptionHistoryParams::builder().start_time(1623319461670).end_time(1641782889000).current(1).size(10).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"time":1575018510000,"arrivalTime":1575018510000,"asset":"WBETH","amount":"21312.23223","distributeAsset":"ETH","distributeAmount":"21338.0699","conversionRatio":"1.00121234","status":"SUCCESS"}],"total":1}"#).unwrap();
            let expected_response : models::GetEthRedemptionHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetEthRedemptionHistoryResponse");

            let resp = client.get_eth_redemption_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_eth_redemption_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: true };

            let params = GetEthRedemptionHistoryParams::builder().build().unwrap();

            match client.get_eth_redemption_history(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_eth_staking_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: false };

            let params = GetEthStakingHistoryParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"time":1575018510000,"asset":"ETH","amount":"21312.23223","distributeAsset":"WBETH","distributeAmount":"21286.42584","conversionRatio":"1.00121234","status":"SUCCESS"}],"total":1}"#).unwrap();
            let expected_response : models::GetEthStakingHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetEthStakingHistoryResponse");

            let resp = client.get_eth_staking_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_eth_staking_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: false };

            let params = GetEthStakingHistoryParams::builder().start_time(1623319461670).end_time(1641782889000).current(1).size(10).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"time":1575018510000,"asset":"ETH","amount":"21312.23223","distributeAsset":"WBETH","distributeAmount":"21286.42584","conversionRatio":"1.00121234","status":"SUCCESS"}],"total":1}"#).unwrap();
            let expected_response : models::GetEthStakingHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetEthStakingHistoryResponse");

            let resp = client.get_eth_staking_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_eth_staking_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: true };

            let params = GetEthStakingHistoryParams::builder().build().unwrap();

            match client.get_eth_staking_history(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_wbeth_rate_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: false };

            let params = GetWbethRateHistoryParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"annualPercentageRate":"0.00006408","exchangeRate":"1.00121234","time":1577233578000}],"total":"1"}"#).unwrap();
            let expected_response : models::GetWbethRateHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetWbethRateHistoryResponse");

            let resp = client.get_wbeth_rate_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_wbeth_rate_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: false };

            let params = GetWbethRateHistoryParams::builder().start_time(1623319461670).end_time(1641782889000).current(1).size(10).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"annualPercentageRate":"0.00006408","exchangeRate":"1.00121234","time":1577233578000}],"total":"1"}"#).unwrap();
            let expected_response : models::GetWbethRateHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetWbethRateHistoryResponse");

            let resp = client.get_wbeth_rate_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_wbeth_rate_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: true };

            let params = GetWbethRateHistoryParams::builder().build().unwrap();

            match client.get_wbeth_rate_history(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_wbeth_rewards_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: false };

            let params = GetWbethRewardsHistoryParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"estRewardsInETH":"1.23230920","rows":[{"time":1575018510000,"amountInETH":"0.23223","holding":"2.3223","holdingInETH":"2.4231","annualPercentageRate":"0.5"}],"total":1}"#).unwrap();
            let expected_response : models::GetWbethRewardsHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetWbethRewardsHistoryResponse");

            let resp = client.get_wbeth_rewards_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_wbeth_rewards_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: false };

            let params = GetWbethRewardsHistoryParams::builder().start_time(1623319461670).end_time(1641782889000).current(1).size(10).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"estRewardsInETH":"1.23230920","rows":[{"time":1575018510000,"amountInETH":"0.23223","holding":"2.3223","holdingInETH":"2.4231","annualPercentageRate":"0.5"}],"total":1}"#).unwrap();
            let expected_response : models::GetWbethRewardsHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetWbethRewardsHistoryResponse");

            let resp = client.get_wbeth_rewards_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_wbeth_rewards_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: true };

            let params = GetWbethRewardsHistoryParams::builder().build().unwrap();

            match client.get_wbeth_rewards_history(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_wbeth_unwrap_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: false };

            let params = GetWbethUnwrapHistoryParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"time":1575018510000,"fromAsset":"WBETH","fromAmount":"21312.23223","toAsset":"BETH","toAmount":"21312.23223","exchangeRate":"1.01243253","status":"SUCCESS"}],"total":1}"#).unwrap();
            let expected_response : models::GetWbethUnwrapHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetWbethUnwrapHistoryResponse");

            let resp = client.get_wbeth_unwrap_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_wbeth_unwrap_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: false };

            let params = GetWbethUnwrapHistoryParams::builder().start_time(1623319461670).end_time(1641782889000).current(1).size(10).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"time":1575018510000,"fromAsset":"WBETH","fromAmount":"21312.23223","toAsset":"BETH","toAmount":"21312.23223","exchangeRate":"1.01243253","status":"SUCCESS"}],"total":1}"#).unwrap();
            let expected_response : models::GetWbethUnwrapHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetWbethUnwrapHistoryResponse");

            let resp = client.get_wbeth_unwrap_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_wbeth_unwrap_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: true };

            let params = GetWbethUnwrapHistoryParams::builder().build().unwrap();

            match client.get_wbeth_unwrap_history(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_wbeth_wrap_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: false };

            let params = GetWbethWrapHistoryParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"time":1575018510000,"fromAsset":"BETH","fromAmount":"21312.23223","toAsset":"WBETH","toAmount":"21312.23223","exchangeRate":"1.01243253","status":"SUCCESS"}],"total":1}"#).unwrap();
            let expected_response : models::GetWbethWrapHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetWbethWrapHistoryResponse");

            let resp = client.get_wbeth_wrap_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_wbeth_wrap_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: false };

            let params = GetWbethWrapHistoryParams::builder().start_time(1623319461670).end_time(1641782889000).current(1).size(10).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"time":1575018510000,"fromAsset":"BETH","fromAmount":"21312.23223","toAsset":"WBETH","toAmount":"21312.23223","exchangeRate":"1.01243253","status":"SUCCESS"}],"total":1}"#).unwrap();
            let expected_response : models::GetWbethWrapHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetWbethWrapHistoryResponse");

            let resp = client.get_wbeth_wrap_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_wbeth_wrap_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: true };

            let params = GetWbethWrapHistoryParams::builder().build().unwrap();

            match client.get_wbeth_wrap_history(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn redeem_eth_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: false };

            let params = RedeemEthParams::builder(dec!(1.0),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"success":true,"ethAmount":"0.23092091","conversionRatio":"1.00121234","arrivalTime":1575018510000}"#).unwrap();
            let expected_response : models::RedeemEthResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::RedeemEthResponse");

            let resp = client.redeem_eth(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn redeem_eth_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: false };

            let params = RedeemEthParams::builder(dec!(1.0),).asset("BETH".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"success":true,"ethAmount":"0.23092091","conversionRatio":"1.00121234","arrivalTime":1575018510000}"#).unwrap();
            let expected_response : models::RedeemEthResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::RedeemEthResponse");

            let resp = client.redeem_eth(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn redeem_eth_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: true };

            let params = RedeemEthParams::builder(dec!(1.0)).build().unwrap();

            match client.redeem_eth(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn subscribe_eth_staking_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: false };

            let params = SubscribeEthStakingParams::builder(dec!(1.0))
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"success":true,"wbethAmount":"0.23092091","conversionRatio":"1.001212342342"}"#,
            )
            .unwrap();
            let expected_response: models::SubscribeEthStakingResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::SubscribeEthStakingResponse");

            let resp = client
                .subscribe_eth_staking(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn subscribe_eth_staking_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: false };

            let params = SubscribeEthStakingParams::builder(dec!(1.0))
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"success":true,"wbethAmount":"0.23092091","conversionRatio":"1.001212342342"}"#,
            )
            .unwrap();
            let expected_response: models::SubscribeEthStakingResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::SubscribeEthStakingResponse");

            let resp = client
                .subscribe_eth_staking(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn subscribe_eth_staking_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: true };

            let params = SubscribeEthStakingParams::builder(dec!(1.0))
                .build()
                .unwrap();

            match client.subscribe_eth_staking(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn wrap_beth_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: false };

            let params = WrapBethParams::builder(dec!(1.0)).build().unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"success":true,"wbethAmount":"0.23092091","exchangeRate":"1.001212343432"}"#,
            )
            .unwrap();
            let expected_response: models::WrapBethResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::WrapBethResponse");

            let resp = client.wrap_beth(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn wrap_beth_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: false };

            let params = WrapBethParams::builder(dec!(1.0))
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"success":true,"wbethAmount":"0.23092091","exchangeRate":"1.001212343432"}"#,
            )
            .unwrap();
            let expected_response: models::WrapBethResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::WrapBethResponse");

            let resp = client.wrap_beth(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn wrap_beth_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockEthStakingApiClient { force_error: true };

            let params = WrapBethParams::builder(dec!(1.0)).build().unwrap();

            match client.wrap_beth(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }
}
