/*
 * Binance Margin Trading REST API
 *
 * OpenAPI Specification for the Binance Margin Trading REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#![allow(unused_imports)]
use async_trait::async_trait;
use derive_builder::Builder;
use reqwest;
use rust_decimal::prelude::*;
use serde::{Deserialize, Serialize};
use serde_json::{Value, json};
use std::collections::BTreeMap;

use crate::common::{
    config::ConfigurationRestApi,
    models::{ParamBuildError, RestApiResponse},
    utils::send_request,
};
use crate::margin_trading::rest_api::models;

const HAS_TIME_UNIT: bool = false;

#[async_trait]
pub trait BorrowRepayApi: Send + Sync {
    async fn get_future_hourly_interest_rate(
        &self,
        params: GetFutureHourlyInterestRateParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::GetFutureHourlyInterestRateResponseInner>>>;
    async fn get_interest_history(
        &self,
        params: GetInterestHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetInterestHistoryResponse>>;
    async fn margin_account_borrow_repay(
        &self,
        params: MarginAccountBorrowRepayParams,
    ) -> anyhow::Result<RestApiResponse<models::MarginAccountBorrowRepayResponse>>;
    async fn query_borrow_repay_records_in_margin_account(
        &self,
        params: QueryBorrowRepayRecordsInMarginAccountParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryBorrowRepayRecordsInMarginAccountResponse>>;
    async fn query_margin_interest_rate_history(
        &self,
        params: QueryMarginInterestRateHistoryParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryMarginInterestRateHistoryResponseInner>>>;
    async fn query_max_borrow(
        &self,
        params: QueryMaxBorrowParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryMaxBorrowResponse>>;
}

#[derive(Debug, Clone)]
pub struct BorrowRepayApiClient {
    configuration: ConfigurationRestApi,
}

impl BorrowRepayApiClient {
    pub fn new(configuration: ConfigurationRestApi) -> Self {
        Self { configuration }
    }
}

/// Request parameters for the [`get_future_hourly_interest_rate`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_future_hourly_interest_rate`](#method.get_future_hourly_interest_rate).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetFutureHourlyInterestRateParams {
    /// List of assets, separated by commas, up to 20
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub assets: String,
    /// for isolated margin or not, "TRUE", "FALSE"
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub is_isolated: bool,
}

impl GetFutureHourlyInterestRateParams {
    /// Create a builder for [`get_future_hourly_interest_rate`].
    ///
    /// Required parameters:
    ///
    /// * `assets` — List of assets, separated by commas, up to 20
    /// * `is_isolated` — for isolated margin or not, \"TRUE\", \"FALSE\"
    ///
    #[must_use]
    pub fn builder(assets: String, is_isolated: bool) -> GetFutureHourlyInterestRateParamsBuilder {
        GetFutureHourlyInterestRateParamsBuilder::default()
            .assets(assets)
            .is_isolated(is_isolated)
    }
}
/// Request parameters for the [`get_interest_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_interest_history`](#method.get_interest_history).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetInterestHistoryParams {
    ///
    /// The `asset` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub asset: Option<String>,
    /// isolated symbol
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub isolated_symbol: Option<String>,
    /// 只支持查询最近90天的数据
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Currently querying page. Start from 1. Default:1
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub current: Option<i64>,
    /// Default:10 Max:100
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub size: Option<i64>,
    /// No more than 60000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetInterestHistoryParams {
    /// Create a builder for [`get_interest_history`].
    ///
    #[must_use]
    pub fn builder() -> GetInterestHistoryParamsBuilder {
        GetInterestHistoryParamsBuilder::default()
    }
}
/// Request parameters for the [`margin_account_borrow_repay`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`margin_account_borrow_repay`](#method.margin_account_borrow_repay).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct MarginAccountBorrowRepayParams {
    ///
    /// The `asset` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub asset: String,
    /// `TRUE` for Isolated Margin, `FALSE` for Cross Margin, Default `FALSE`
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub is_isolated: String,
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `amount` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub amount: String,
    /// `MARGIN`,`ISOLATED`
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub r#type: String,
    /// No more than 60000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl MarginAccountBorrowRepayParams {
    /// Create a builder for [`margin_account_borrow_repay`].
    ///
    /// Required parameters:
    ///
    /// * `asset` — String
    /// * `is_isolated` — `TRUE` for Isolated Margin, `FALSE` for Cross Margin, Default `FALSE`
    /// * `symbol` — String
    /// * `amount` — String
    /// * `r#type` — `MARGIN`,`ISOLATED`
    ///
    #[must_use]
    pub fn builder(
        asset: String,
        is_isolated: String,
        symbol: String,
        amount: String,
        r#type: String,
    ) -> MarginAccountBorrowRepayParamsBuilder {
        MarginAccountBorrowRepayParamsBuilder::default()
            .asset(asset)
            .is_isolated(is_isolated)
            .symbol(symbol)
            .amount(amount)
            .r#type(r#type)
    }
}
/// Request parameters for the [`query_borrow_repay_records_in_margin_account`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_borrow_repay_records_in_margin_account`](#method.query_borrow_repay_records_in_margin_account).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryBorrowRepayRecordsInMarginAccountParams {
    /// `MARGIN`,`ISOLATED`
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub r#type: String,
    ///
    /// The `asset` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub asset: Option<String>,
    /// isolated symbol
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub isolated_symbol: Option<String>,
    /// `tranId` in `POST /sapi/v1/margin/loan`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub tx_id: Option<i64>,
    /// 只支持查询最近90天的数据
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Currently querying page. Start from 1. Default:1
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub current: Option<i64>,
    /// Default:10 Max:100
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub size: Option<i64>,
    /// No more than 60000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryBorrowRepayRecordsInMarginAccountParams {
    /// Create a builder for [`query_borrow_repay_records_in_margin_account`].
    ///
    /// Required parameters:
    ///
    /// * `r#type` — `MARGIN`,`ISOLATED`
    ///
    #[must_use]
    pub fn builder(r#type: String) -> QueryBorrowRepayRecordsInMarginAccountParamsBuilder {
        QueryBorrowRepayRecordsInMarginAccountParamsBuilder::default().r#type(r#type)
    }
}
/// Request parameters for the [`query_margin_interest_rate_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_margin_interest_rate_history`](#method.query_margin_interest_rate_history).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryMarginInterestRateHistoryParams {
    ///
    /// The `asset` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub asset: String,
    /// User's current specific margin data will be returned if vipLevel is omitted
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub vip_level: Option<i64>,
    /// 只支持查询最近90天的数据
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    ///
    /// The `end_time` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// No more than 60000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryMarginInterestRateHistoryParams {
    /// Create a builder for [`query_margin_interest_rate_history`].
    ///
    /// Required parameters:
    ///
    /// * `asset` — String
    ///
    #[must_use]
    pub fn builder(asset: String) -> QueryMarginInterestRateHistoryParamsBuilder {
        QueryMarginInterestRateHistoryParamsBuilder::default().asset(asset)
    }
}
/// Request parameters for the [`query_max_borrow`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_max_borrow`](#method.query_max_borrow).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryMaxBorrowParams {
    ///
    /// The `asset` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub asset: String,
    /// isolated symbol
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub isolated_symbol: Option<String>,
    /// No more than 60000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryMaxBorrowParams {
    /// Create a builder for [`query_max_borrow`].
    ///
    /// Required parameters:
    ///
    /// * `asset` — String
    ///
    #[must_use]
    pub fn builder(asset: String) -> QueryMaxBorrowParamsBuilder {
        QueryMaxBorrowParamsBuilder::default().asset(asset)
    }
}

#[async_trait]
impl BorrowRepayApi for BorrowRepayApiClient {
    async fn get_future_hourly_interest_rate(
        &self,
        params: GetFutureHourlyInterestRateParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::GetFutureHourlyInterestRateResponseInner>>>
    {
        let GetFutureHourlyInterestRateParams {
            assets,
            is_isolated,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("assets".to_string(), json!(assets));

        query_params.insert("isIsolated".to_string(), json!(is_isolated));

        send_request::<Vec<models::GetFutureHourlyInterestRateResponseInner>>(
            &self.configuration,
            "/sapi/v1/margin/next-hourly-interest-rate",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_interest_history(
        &self,
        params: GetInterestHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::GetInterestHistoryResponse>> {
        let GetInterestHistoryParams {
            asset,
            isolated_symbol,
            start_time,
            end_time,
            current,
            size,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = asset {
            query_params.insert("asset".to_string(), json!(rw));
        }

        if let Some(rw) = isolated_symbol {
            query_params.insert("isolatedSymbol".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = current {
            query_params.insert("current".to_string(), json!(rw));
        }

        if let Some(rw) = size {
            query_params.insert("size".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetInterestHistoryResponse>(
            &self.configuration,
            "/sapi/v1/margin/interestHistory",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn margin_account_borrow_repay(
        &self,
        params: MarginAccountBorrowRepayParams,
    ) -> anyhow::Result<RestApiResponse<models::MarginAccountBorrowRepayResponse>> {
        let MarginAccountBorrowRepayParams {
            asset,
            is_isolated,
            symbol,
            amount,
            r#type,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("asset".to_string(), json!(asset));

        query_params.insert("isIsolated".to_string(), json!(is_isolated));

        query_params.insert("symbol".to_string(), json!(symbol));

        query_params.insert("amount".to_string(), json!(amount));

        query_params.insert("type".to_string(), json!(r#type));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::MarginAccountBorrowRepayResponse>(
            &self.configuration,
            "/sapi/v1/margin/borrow-repay",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_borrow_repay_records_in_margin_account(
        &self,
        params: QueryBorrowRepayRecordsInMarginAccountParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryBorrowRepayRecordsInMarginAccountResponse>>
    {
        let QueryBorrowRepayRecordsInMarginAccountParams {
            r#type,
            asset,
            isolated_symbol,
            tx_id,
            start_time,
            end_time,
            current,
            size,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("type".to_string(), json!(r#type));

        if let Some(rw) = asset {
            query_params.insert("asset".to_string(), json!(rw));
        }

        if let Some(rw) = isolated_symbol {
            query_params.insert("isolatedSymbol".to_string(), json!(rw));
        }

        if let Some(rw) = tx_id {
            query_params.insert("txId".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = current {
            query_params.insert("current".to_string(), json!(rw));
        }

        if let Some(rw) = size {
            query_params.insert("size".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::QueryBorrowRepayRecordsInMarginAccountResponse>(
            &self.configuration,
            "/sapi/v1/margin/borrow-repay",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_margin_interest_rate_history(
        &self,
        params: QueryMarginInterestRateHistoryParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryMarginInterestRateHistoryResponseInner>>>
    {
        let QueryMarginInterestRateHistoryParams {
            asset,
            vip_level,
            start_time,
            end_time,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("asset".to_string(), json!(asset));

        if let Some(rw) = vip_level {
            query_params.insert("vipLevel".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::QueryMarginInterestRateHistoryResponseInner>>(
            &self.configuration,
            "/sapi/v1/margin/interestRateHistory",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_max_borrow(
        &self,
        params: QueryMaxBorrowParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryMaxBorrowResponse>> {
        let QueryMaxBorrowParams {
            asset,
            isolated_symbol,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("asset".to_string(), json!(asset));

        if let Some(rw) = isolated_symbol {
            query_params.insert("isolatedSymbol".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::QueryMaxBorrowResponse>(
            &self.configuration,
            "/sapi/v1/margin/maxBorrowable",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }
}

#[cfg(all(test, feature = "margin_trading"))]
mod tests {
    use super::*;
    use crate::TOKIO_SHARED_RT;
    use crate::{errors::ConnectorError, models::DataFuture, models::RestApiRateLimit};
    use async_trait::async_trait;
    use std::collections::HashMap;

    struct DummyRestApiResponse<T> {
        inner: Box<dyn FnOnce() -> DataFuture<Result<T, ConnectorError>> + Send + Sync>,
        status: u16,
        headers: HashMap<String, String>,
        rate_limits: Option<Vec<RestApiRateLimit>>,
    }

    impl<T> From<DummyRestApiResponse<T>> for RestApiResponse<T> {
        fn from(dummy: DummyRestApiResponse<T>) -> Self {
            Self {
                data_fn: dummy.inner,
                status: dummy.status,
                headers: dummy.headers,
                rate_limits: dummy.rate_limits,
            }
        }
    }

    struct MockBorrowRepayApiClient {
        force_error: bool,
    }

    #[async_trait]
    impl BorrowRepayApi for MockBorrowRepayApiClient {
        async fn get_future_hourly_interest_rate(
            &self,
            _params: GetFutureHourlyInterestRateParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::GetFutureHourlyInterestRateResponseInner>>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"asset":"BTC","nextHourlyInterestRate":"0.00000571"},{"asset":"ETH","nextHourlyInterestRate":"0.00000578"}]"#).unwrap();
            let dummy_response: Vec<models::GetFutureHourlyInterestRateResponseInner> =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into Vec<models::GetFutureHourlyInterestRateResponseInner>",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_interest_history(
            &self,
            _params: GetInterestHistoryParams,
        ) -> anyhow::Result<RestApiResponse<models::GetInterestHistoryResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"txId":1352286576452864800,"interestAccuredTime":1672160400000,"asset":"USDT","rawAsset":"USDT","principal":"45.3313","interest":"0.00024995","interestRate":"0.00013233","type":"ON_BORROW","isolatedSymbol":"BNBUSDT"}],"total":1}"#).unwrap();
            let dummy_response: models::GetInterestHistoryResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetInterestHistoryResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn margin_account_borrow_repay(
            &self,
            _params: MarginAccountBorrowRepayParams,
        ) -> anyhow::Result<RestApiResponse<models::MarginAccountBorrowRepayResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"tranId":100000001}"#).unwrap();
            let dummy_response: models::MarginAccountBorrowRepayResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::MarginAccountBorrowRepayResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_borrow_repay_records_in_margin_account(
            &self,
            _params: QueryBorrowRepayRecordsInMarginAccountParams,
        ) -> anyhow::Result<RestApiResponse<models::QueryBorrowRepayRecordsInMarginAccountResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"type":"AUTO","isolatedSymbol":"BNBUSDT","amount":"14.00000000","asset":"BNB","interest":"0.01866667","principal":"13.98133333","status":"CONFIRMED","timestamp":1563438204000,"txId":2970933056}],"total":1}"#).unwrap();
            let dummy_response: models::QueryBorrowRepayRecordsInMarginAccountResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::QueryBorrowRepayRecordsInMarginAccountResponse",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_margin_interest_rate_history(
            &self,
            _params: QueryMarginInterestRateHistoryParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::QueryMarginInterestRateHistoryResponseInner>>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"asset":"BTC","dailyInterestRate":"0.00025000","timestamp":1611544731000,"vipLevel":1},{"asset":"BTC","dailyInterestRate":"0.00035000","timestamp":1610248118000,"vipLevel":1}]"#).unwrap();
            let dummy_response: Vec<models::QueryMarginInterestRateHistoryResponseInner> =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into Vec<models::QueryMarginInterestRateHistoryResponseInner>",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_max_borrow(
            &self,
            _params: QueryMaxBorrowParams,
        ) -> anyhow::Result<RestApiResponse<models::QueryMaxBorrowResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value =
                serde_json::from_str(r#"{"amount":"1.69248805","borrowLimit":"60"}"#).unwrap();
            let dummy_response: models::QueryMaxBorrowResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::QueryMaxBorrowResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }
    }

    #[test]
    fn get_future_hourly_interest_rate_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockBorrowRepayApiClient { force_error: false };

            let params = GetFutureHourlyInterestRateParams::builder("assets_example".to_string(),false).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"asset":"BTC","nextHourlyInterestRate":"0.00000571"},{"asset":"ETH","nextHourlyInterestRate":"0.00000578"}]"#).unwrap();
            let expected_response : Vec<models::GetFutureHourlyInterestRateResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::GetFutureHourlyInterestRateResponseInner>");

            let resp = client.get_future_hourly_interest_rate(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_future_hourly_interest_rate_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockBorrowRepayApiClient { force_error: false };

            let params = GetFutureHourlyInterestRateParams::builder("assets_example".to_string(),false).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"asset":"BTC","nextHourlyInterestRate":"0.00000571"},{"asset":"ETH","nextHourlyInterestRate":"0.00000578"}]"#).unwrap();
            let expected_response : Vec<models::GetFutureHourlyInterestRateResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::GetFutureHourlyInterestRateResponseInner>");

            let resp = client.get_future_hourly_interest_rate(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_future_hourly_interest_rate_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockBorrowRepayApiClient { force_error: true };

            let params =
                GetFutureHourlyInterestRateParams::builder("assets_example".to_string(), false)
                    .build()
                    .unwrap();

            match client.get_future_hourly_interest_rate(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_interest_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockBorrowRepayApiClient { force_error: false };

            let params = GetInterestHistoryParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"txId":1352286576452864800,"interestAccuredTime":1672160400000,"asset":"USDT","rawAsset":"USDT","principal":"45.3313","interest":"0.00024995","interestRate":"0.00013233","type":"ON_BORROW","isolatedSymbol":"BNBUSDT"}],"total":1}"#).unwrap();
            let expected_response : models::GetInterestHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetInterestHistoryResponse");

            let resp = client.get_interest_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_interest_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockBorrowRepayApiClient { force_error: false };

            let params = GetInterestHistoryParams::builder().asset("asset_example".to_string()).isolated_symbol("isolated_symbol_example".to_string()).start_time(1623319461670).end_time(1641782889000).current(1).size(10).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"txId":1352286576452864800,"interestAccuredTime":1672160400000,"asset":"USDT","rawAsset":"USDT","principal":"45.3313","interest":"0.00024995","interestRate":"0.00013233","type":"ON_BORROW","isolatedSymbol":"BNBUSDT"}],"total":1}"#).unwrap();
            let expected_response : models::GetInterestHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetInterestHistoryResponse");

            let resp = client.get_interest_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_interest_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockBorrowRepayApiClient { force_error: true };

            let params = GetInterestHistoryParams::builder().build().unwrap();

            match client.get_interest_history(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn margin_account_borrow_repay_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockBorrowRepayApiClient { force_error: false };

            let params = MarginAccountBorrowRepayParams::builder(
                "asset_example".to_string(),
                "FALSE".to_string(),
                "symbol_example".to_string(),
                "amount_example".to_string(),
                "r#type_example".to_string(),
            )
            .build()
            .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"tranId":100000001}"#).unwrap();
            let expected_response: models::MarginAccountBorrowRepayResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::MarginAccountBorrowRepayResponse");

            let resp = client
                .margin_account_borrow_repay(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn margin_account_borrow_repay_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockBorrowRepayApiClient { force_error: false };

            let params = MarginAccountBorrowRepayParams::builder(
                "asset_example".to_string(),
                "FALSE".to_string(),
                "symbol_example".to_string(),
                "amount_example".to_string(),
                "r#type_example".to_string(),
            )
            .recv_window(5000)
            .build()
            .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"tranId":100000001}"#).unwrap();
            let expected_response: models::MarginAccountBorrowRepayResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::MarginAccountBorrowRepayResponse");

            let resp = client
                .margin_account_borrow_repay(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn margin_account_borrow_repay_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockBorrowRepayApiClient { force_error: true };

            let params = MarginAccountBorrowRepayParams::builder(
                "asset_example".to_string(),
                "FALSE".to_string(),
                "symbol_example".to_string(),
                "amount_example".to_string(),
                "r#type_example".to_string(),
            )
            .build()
            .unwrap();

            match client.margin_account_borrow_repay(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_borrow_repay_records_in_margin_account_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockBorrowRepayApiClient { force_error: false };

            let params = QueryBorrowRepayRecordsInMarginAccountParams::builder("r#type_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"type":"AUTO","isolatedSymbol":"BNBUSDT","amount":"14.00000000","asset":"BNB","interest":"0.01866667","principal":"13.98133333","status":"CONFIRMED","timestamp":1563438204000,"txId":2970933056}],"total":1}"#).unwrap();
            let expected_response : models::QueryBorrowRepayRecordsInMarginAccountResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryBorrowRepayRecordsInMarginAccountResponse");

            let resp = client.query_borrow_repay_records_in_margin_account(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_borrow_repay_records_in_margin_account_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockBorrowRepayApiClient { force_error: false };

            let params = QueryBorrowRepayRecordsInMarginAccountParams::builder("r#type_example".to_string(),).asset("asset_example".to_string()).isolated_symbol("isolated_symbol_example".to_string()).tx_id(1).start_time(1623319461670).end_time(1641782889000).current(1).size(10).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"type":"AUTO","isolatedSymbol":"BNBUSDT","amount":"14.00000000","asset":"BNB","interest":"0.01866667","principal":"13.98133333","status":"CONFIRMED","timestamp":1563438204000,"txId":2970933056}],"total":1}"#).unwrap();
            let expected_response : models::QueryBorrowRepayRecordsInMarginAccountResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryBorrowRepayRecordsInMarginAccountResponse");

            let resp = client.query_borrow_repay_records_in_margin_account(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_borrow_repay_records_in_margin_account_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockBorrowRepayApiClient { force_error: true };

            let params =
                QueryBorrowRepayRecordsInMarginAccountParams::builder("r#type_example".to_string())
                    .build()
                    .unwrap();

            match client
                .query_borrow_repay_records_in_margin_account(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_margin_interest_rate_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockBorrowRepayApiClient { force_error: false };

            let params = QueryMarginInterestRateHistoryParams::builder("asset_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"asset":"BTC","dailyInterestRate":"0.00025000","timestamp":1611544731000,"vipLevel":1},{"asset":"BTC","dailyInterestRate":"0.00035000","timestamp":1610248118000,"vipLevel":1}]"#).unwrap();
            let expected_response : Vec<models::QueryMarginInterestRateHistoryResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryMarginInterestRateHistoryResponseInner>");

            let resp = client.query_margin_interest_rate_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_margin_interest_rate_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockBorrowRepayApiClient { force_error: false };

            let params = QueryMarginInterestRateHistoryParams::builder("asset_example".to_string(),).vip_level(1).start_time(1623319461670).end_time(1641782889000).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"asset":"BTC","dailyInterestRate":"0.00025000","timestamp":1611544731000,"vipLevel":1},{"asset":"BTC","dailyInterestRate":"0.00035000","timestamp":1610248118000,"vipLevel":1}]"#).unwrap();
            let expected_response : Vec<models::QueryMarginInterestRateHistoryResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryMarginInterestRateHistoryResponseInner>");

            let resp = client.query_margin_interest_rate_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_margin_interest_rate_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockBorrowRepayApiClient { force_error: true };

            let params = QueryMarginInterestRateHistoryParams::builder("asset_example".to_string())
                .build()
                .unwrap();

            match client.query_margin_interest_rate_history(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_max_borrow_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockBorrowRepayApiClient { force_error: false };

            let params = QueryMaxBorrowParams::builder("asset_example".to_string())
                .build()
                .unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"amount":"1.69248805","borrowLimit":"60"}"#).unwrap();
            let expected_response: models::QueryMaxBorrowResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::QueryMaxBorrowResponse");

            let resp = client
                .query_max_borrow(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_max_borrow_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockBorrowRepayApiClient { force_error: false };

            let params = QueryMaxBorrowParams::builder("asset_example".to_string())
                .isolated_symbol("isolated_symbol_example".to_string())
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"amount":"1.69248805","borrowLimit":"60"}"#).unwrap();
            let expected_response: models::QueryMaxBorrowResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::QueryMaxBorrowResponse");

            let resp = client
                .query_max_borrow(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_max_borrow_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockBorrowRepayApiClient { force_error: true };

            let params = QueryMaxBorrowParams::builder("asset_example".to_string())
                .build()
                .unwrap();

            match client.query_max_borrow(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }
}
