/*
 * Binance Sub Account REST API
 *
 * OpenAPI Specification for the Binance Sub Account REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#![allow(unused_imports)]
use async_trait::async_trait;
use derive_builder::Builder;
use reqwest;
use rust_decimal::prelude::*;
use serde::{Deserialize, Serialize};
use serde_json::{Value, json};
use std::collections::BTreeMap;

use crate::common::{
    config::ConfigurationRestApi,
    models::{ParamBuildError, RestApiResponse},
    utils::send_request,
};
use crate::sub_account::rest_api::models;

const HAS_TIME_UNIT: bool = false;

#[async_trait]
pub trait AccountManagementApi: Send + Sync {
    async fn create_a_virtual_sub_account(
        &self,
        params: CreateAVirtualSubAccountParams,
    ) -> anyhow::Result<RestApiResponse<models::CreateAVirtualSubAccountResponse>>;
    async fn enable_futures_for_sub_account(
        &self,
        params: EnableFuturesForSubAccountParams,
    ) -> anyhow::Result<RestApiResponse<models::EnableFuturesForSubAccountResponse>>;
    async fn enable_options_for_sub_account(
        &self,
        params: EnableOptionsForSubAccountParams,
    ) -> anyhow::Result<RestApiResponse<models::EnableOptionsForSubAccountResponse>>;
    async fn get_futures_position_risk_of_sub_account(
        &self,
        params: GetFuturesPositionRiskOfSubAccountParams,
    ) -> anyhow::Result<
        RestApiResponse<
            Vec<models::GetFuturesPositionRiskOfSubAccountV2ResponseFuturePositionRiskVosInner>,
        >,
    >;
    async fn get_futures_position_risk_of_sub_account_v2(
        &self,
        params: GetFuturesPositionRiskOfSubAccountV2Params,
    ) -> anyhow::Result<RestApiResponse<models::GetFuturesPositionRiskOfSubAccountV2Response>>;
    async fn get_sub_accounts_status_on_margin_or_futures(
        &self,
        params: GetSubAccountsStatusOnMarginOrFuturesParams,
    ) -> anyhow::Result<
        RestApiResponse<Vec<models::GetSubAccountsStatusOnMarginOrFuturesResponseInner>>,
    >;
    async fn query_sub_account_list(
        &self,
        params: QuerySubAccountListParams,
    ) -> anyhow::Result<RestApiResponse<models::QuerySubAccountListResponse>>;
    async fn query_sub_account_transaction_statistics(
        &self,
        params: QuerySubAccountTransactionStatisticsParams,
    ) -> anyhow::Result<RestApiResponse<models::QuerySubAccountTransactionStatisticsResponse>>;
}

#[derive(Debug, Clone)]
pub struct AccountManagementApiClient {
    configuration: ConfigurationRestApi,
}

impl AccountManagementApiClient {
    pub fn new(configuration: ConfigurationRestApi) -> Self {
        Self { configuration }
    }
}

/// Request parameters for the [`create_a_virtual_sub_account`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`create_a_virtual_sub_account`](#method.create_a_virtual_sub_account).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct CreateAVirtualSubAccountParams {
    /// Please input a string. We will create a virtual email using that string for you to register
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub sub_account_string: String,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl CreateAVirtualSubAccountParams {
    /// Create a builder for [`create_a_virtual_sub_account`].
    ///
    /// Required parameters:
    ///
    /// * `sub_account_string` — Please input a string. We will create a virtual email using that string for you to register
    ///
    #[must_use]
    pub fn builder(sub_account_string: String) -> CreateAVirtualSubAccountParamsBuilder {
        CreateAVirtualSubAccountParamsBuilder::default().sub_account_string(sub_account_string)
    }
}
/// Request parameters for the [`enable_futures_for_sub_account`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`enable_futures_for_sub_account`](#method.enable_futures_for_sub_account).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct EnableFuturesForSubAccountParams {
    /// [Sub-account email](#email-address)
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub email: String,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl EnableFuturesForSubAccountParams {
    /// Create a builder for [`enable_futures_for_sub_account`].
    ///
    /// Required parameters:
    ///
    /// * `email` — [Sub-account email](#email-address)
    ///
    #[must_use]
    pub fn builder(email: String) -> EnableFuturesForSubAccountParamsBuilder {
        EnableFuturesForSubAccountParamsBuilder::default().email(email)
    }
}
/// Request parameters for the [`enable_options_for_sub_account`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`enable_options_for_sub_account`](#method.enable_options_for_sub_account).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct EnableOptionsForSubAccountParams {
    /// [Sub-account email](#email-address)
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub email: String,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl EnableOptionsForSubAccountParams {
    /// Create a builder for [`enable_options_for_sub_account`].
    ///
    /// Required parameters:
    ///
    /// * `email` — [Sub-account email](#email-address)
    ///
    #[must_use]
    pub fn builder(email: String) -> EnableOptionsForSubAccountParamsBuilder {
        EnableOptionsForSubAccountParamsBuilder::default().email(email)
    }
}
/// Request parameters for the [`get_futures_position_risk_of_sub_account`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_futures_position_risk_of_sub_account`](#method.get_futures_position_risk_of_sub_account).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetFuturesPositionRiskOfSubAccountParams {
    /// [Sub-account email](#email-address)
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub email: String,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetFuturesPositionRiskOfSubAccountParams {
    /// Create a builder for [`get_futures_position_risk_of_sub_account`].
    ///
    /// Required parameters:
    ///
    /// * `email` — [Sub-account email](#email-address)
    ///
    #[must_use]
    pub fn builder(email: String) -> GetFuturesPositionRiskOfSubAccountParamsBuilder {
        GetFuturesPositionRiskOfSubAccountParamsBuilder::default().email(email)
    }
}
/// Request parameters for the [`get_futures_position_risk_of_sub_account_v2`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_futures_position_risk_of_sub_account_v2`](#method.get_futures_position_risk_of_sub_account_v2).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetFuturesPositionRiskOfSubAccountV2Params {
    /// [Sub-account email](#email-address)
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub email: String,
    /// 1:USDT-margined Futures，2: Coin-margined Futures
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub futures_type: i64,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetFuturesPositionRiskOfSubAccountV2Params {
    /// Create a builder for [`get_futures_position_risk_of_sub_account_v2`].
    ///
    /// Required parameters:
    ///
    /// * `email` — [Sub-account email](#email-address)
    /// * `futures_type` — 1:USDT-margined Futures，2: Coin-margined Futures
    ///
    #[must_use]
    pub fn builder(
        email: String,
        futures_type: i64,
    ) -> GetFuturesPositionRiskOfSubAccountV2ParamsBuilder {
        GetFuturesPositionRiskOfSubAccountV2ParamsBuilder::default()
            .email(email)
            .futures_type(futures_type)
    }
}
/// Request parameters for the [`get_sub_accounts_status_on_margin_or_futures`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_sub_accounts_status_on_margin_or_futures`](#method.get_sub_accounts_status_on_margin_or_futures).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetSubAccountsStatusOnMarginOrFuturesParams {
    /// Managed sub-account email
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub email: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetSubAccountsStatusOnMarginOrFuturesParams {
    /// Create a builder for [`get_sub_accounts_status_on_margin_or_futures`].
    ///
    #[must_use]
    pub fn builder() -> GetSubAccountsStatusOnMarginOrFuturesParamsBuilder {
        GetSubAccountsStatusOnMarginOrFuturesParamsBuilder::default()
    }
}
/// Request parameters for the [`query_sub_account_list`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_sub_account_list`](#method.query_sub_account_list).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QuerySubAccountListParams {
    /// Managed sub-account email
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub email: Option<String>,
    /// true or false
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub is_freeze: Option<String>,
    /// Default value: 1
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub page: Option<i64>,
    /// Default value: 1, Max value: 200
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QuerySubAccountListParams {
    /// Create a builder for [`query_sub_account_list`].
    ///
    #[must_use]
    pub fn builder() -> QuerySubAccountListParamsBuilder {
        QuerySubAccountListParamsBuilder::default()
    }
}
/// Request parameters for the [`query_sub_account_transaction_statistics`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_sub_account_transaction_statistics`](#method.query_sub_account_transaction_statistics).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QuerySubAccountTransactionStatisticsParams {
    /// Managed sub-account email
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub email: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QuerySubAccountTransactionStatisticsParams {
    /// Create a builder for [`query_sub_account_transaction_statistics`].
    ///
    #[must_use]
    pub fn builder() -> QuerySubAccountTransactionStatisticsParamsBuilder {
        QuerySubAccountTransactionStatisticsParamsBuilder::default()
    }
}

#[async_trait]
impl AccountManagementApi for AccountManagementApiClient {
    async fn create_a_virtual_sub_account(
        &self,
        params: CreateAVirtualSubAccountParams,
    ) -> anyhow::Result<RestApiResponse<models::CreateAVirtualSubAccountResponse>> {
        let CreateAVirtualSubAccountParams {
            sub_account_string,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("subAccountString".to_string(), json!(sub_account_string));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::CreateAVirtualSubAccountResponse>(
            &self.configuration,
            "/sapi/v1/sub-account/virtualSubAccount",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn enable_futures_for_sub_account(
        &self,
        params: EnableFuturesForSubAccountParams,
    ) -> anyhow::Result<RestApiResponse<models::EnableFuturesForSubAccountResponse>> {
        let EnableFuturesForSubAccountParams { email, recv_window } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("email".to_string(), json!(email));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::EnableFuturesForSubAccountResponse>(
            &self.configuration,
            "/sapi/v1/sub-account/futures/enable",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn enable_options_for_sub_account(
        &self,
        params: EnableOptionsForSubAccountParams,
    ) -> anyhow::Result<RestApiResponse<models::EnableOptionsForSubAccountResponse>> {
        let EnableOptionsForSubAccountParams { email, recv_window } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("email".to_string(), json!(email));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::EnableOptionsForSubAccountResponse>(
            &self.configuration,
            "/sapi/v1/sub-account/eoptions/enable",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_futures_position_risk_of_sub_account(
        &self,
        params: GetFuturesPositionRiskOfSubAccountParams,
    ) -> anyhow::Result<
        RestApiResponse<
            Vec<models::GetFuturesPositionRiskOfSubAccountV2ResponseFuturePositionRiskVosInner>,
        >,
    > {
        let GetFuturesPositionRiskOfSubAccountParams { email, recv_window } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("email".to_string(), json!(email));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<
            Vec<models::GetFuturesPositionRiskOfSubAccountV2ResponseFuturePositionRiskVosInner>,
        >(
            &self.configuration,
            "/sapi/v1/sub-account/futures/positionRisk",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_futures_position_risk_of_sub_account_v2(
        &self,
        params: GetFuturesPositionRiskOfSubAccountV2Params,
    ) -> anyhow::Result<RestApiResponse<models::GetFuturesPositionRiskOfSubAccountV2Response>> {
        let GetFuturesPositionRiskOfSubAccountV2Params {
            email,
            futures_type,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("email".to_string(), json!(email));

        query_params.insert("futuresType".to_string(), json!(futures_type));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetFuturesPositionRiskOfSubAccountV2Response>(
            &self.configuration,
            "/sapi/v2/sub-account/futures/positionRisk",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_sub_accounts_status_on_margin_or_futures(
        &self,
        params: GetSubAccountsStatusOnMarginOrFuturesParams,
    ) -> anyhow::Result<
        RestApiResponse<Vec<models::GetSubAccountsStatusOnMarginOrFuturesResponseInner>>,
    > {
        let GetSubAccountsStatusOnMarginOrFuturesParams { email, recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = email {
            query_params.insert("email".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::GetSubAccountsStatusOnMarginOrFuturesResponseInner>>(
            &self.configuration,
            "/sapi/v1/sub-account/status",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_sub_account_list(
        &self,
        params: QuerySubAccountListParams,
    ) -> anyhow::Result<RestApiResponse<models::QuerySubAccountListResponse>> {
        let QuerySubAccountListParams {
            email,
            is_freeze,
            page,
            limit,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = email {
            query_params.insert("email".to_string(), json!(rw));
        }

        if let Some(rw) = is_freeze {
            query_params.insert("isFreeze".to_string(), json!(rw));
        }

        if let Some(rw) = page {
            query_params.insert("page".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::QuerySubAccountListResponse>(
            &self.configuration,
            "/sapi/v1/sub-account/list",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_sub_account_transaction_statistics(
        &self,
        params: QuerySubAccountTransactionStatisticsParams,
    ) -> anyhow::Result<RestApiResponse<models::QuerySubAccountTransactionStatisticsResponse>> {
        let QuerySubAccountTransactionStatisticsParams { email, recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = email {
            query_params.insert("email".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::QuerySubAccountTransactionStatisticsResponse>(
            &self.configuration,
            "/sapi/v1/sub-account/transaction-statistics",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }
}

#[cfg(all(test, feature = "sub_account"))]
mod tests {
    use super::*;
    use crate::TOKIO_SHARED_RT;
    use crate::{errors::ConnectorError, models::DataFuture, models::RestApiRateLimit};
    use async_trait::async_trait;
    use std::collections::HashMap;

    struct DummyRestApiResponse<T> {
        inner: Box<dyn FnOnce() -> DataFuture<Result<T, ConnectorError>> + Send + Sync>,
        status: u16,
        headers: HashMap<String, String>,
        rate_limits: Option<Vec<RestApiRateLimit>>,
    }

    impl<T> From<DummyRestApiResponse<T>> for RestApiResponse<T> {
        fn from(dummy: DummyRestApiResponse<T>) -> Self {
            Self {
                data_fn: dummy.inner,
                status: dummy.status,
                headers: dummy.headers,
                rate_limits: dummy.rate_limits,
            }
        }
    }

    struct MockAccountManagementApiClient {
        force_error: bool,
    }

    #[async_trait]
    impl AccountManagementApi for MockAccountManagementApiClient {
        async fn create_a_virtual_sub_account(
            &self,
            _params: CreateAVirtualSubAccountParams,
        ) -> anyhow::Result<RestApiResponse<models::CreateAVirtualSubAccountResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value =
                serde_json::from_str(r#"{"email":"addsdd_virtual@aasaixwqnoemail.com"}"#).unwrap();
            let dummy_response: models::CreateAVirtualSubAccountResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::CreateAVirtualSubAccountResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn enable_futures_for_sub_account(
            &self,
            _params: EnableFuturesForSubAccountParams,
        ) -> anyhow::Result<RestApiResponse<models::EnableFuturesForSubAccountResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value =
                serde_json::from_str(r#"{"email":"123@test.com","isFuturesEnabled":true}"#)
                    .unwrap();
            let dummy_response: models::EnableFuturesForSubAccountResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::EnableFuturesForSubAccountResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn enable_options_for_sub_account(
            &self,
            _params: EnableOptionsForSubAccountParams,
        ) -> anyhow::Result<RestApiResponse<models::EnableOptionsForSubAccountResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value =
                serde_json::from_str(r#"{"email":"123@test.com","isEOptionsEnabled":true}"#)
                    .unwrap();
            let dummy_response: models::EnableOptionsForSubAccountResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::EnableOptionsForSubAccountResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_futures_position_risk_of_sub_account(
            &self,
            _params: GetFuturesPositionRiskOfSubAccountParams,
        ) -> anyhow::Result<
            RestApiResponse<
                Vec<models::GetFuturesPositionRiskOfSubAccountV2ResponseFuturePositionRiskVosInner>,
            >,
        > {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"entryPrice":"9975.12000","leverage":"50","maxNotional":"1000000","liquidationPrice":"7963.54","markPrice":"9973.50770517","positionAmount":"0.010","symbol":"BTCUSDT","unrealizedProfit":"-0.01612295"}]"#).unwrap();
            let dummy_response : Vec<models::GetFuturesPositionRiskOfSubAccountV2ResponseFuturePositionRiskVosInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::GetFuturesPositionRiskOfSubAccountV2ResponseFuturePositionRiskVosInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_futures_position_risk_of_sub_account_v2(
            &self,
            _params: GetFuturesPositionRiskOfSubAccountV2Params,
        ) -> anyhow::Result<RestApiResponse<models::GetFuturesPositionRiskOfSubAccountV2Response>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"futurePositionRiskVos":[{"entryPrice":"9975.12000","leverage":"50","maxNotional":"1000000","liquidationPrice":"7963.54","markPrice":"9973.50770517","positionAmount":"0.010","symbol":"BTCUSDT","unrealizedProfit":"-0.01612295"}],"deliveryPositionRiskVos":[{"entryPrice":"9975.12000","markPrice":"9973.50770517","leverage":"20","isolated":"false","isolatedWallet":"9973.50770517","isolatedMargin":"0.00000000","isAutoAddMargin":"false","positionSide":"BOTH","positionAmount":"1.230","symbol":"BTCUSD_201225","unrealizedProfit":"-0.01612295"}]}"#).unwrap();
            let dummy_response: models::GetFuturesPositionRiskOfSubAccountV2Response =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::GetFuturesPositionRiskOfSubAccountV2Response",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_sub_accounts_status_on_margin_or_futures(
            &self,
            _params: GetSubAccountsStatusOnMarginOrFuturesParams,
        ) -> anyhow::Result<
            RestApiResponse<Vec<models::GetSubAccountsStatusOnMarginOrFuturesResponseInner>>,
        > {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"email":"123@test.com","isSubUserEnabled":true,"isUserActive":true,"insertTime":1570791523523,"isMarginEnabled":true,"isFutureEnabled":true,"mobile":1570791523523}]"#).unwrap();
            let dummy_response : Vec<models::GetSubAccountsStatusOnMarginOrFuturesResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::GetSubAccountsStatusOnMarginOrFuturesResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_sub_account_list(
            &self,
            _params: QuerySubAccountListParams,
        ) -> anyhow::Result<RestApiResponse<models::QuerySubAccountListResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"subAccounts":[{"subUserId":123456,"email":"testsub@gmail.com","remark":"remark","isFreeze":false,"createTime":1544433328000,"isManagedSubAccount":false,"isAssetManagementSubAccount":false},{"subUserId":1234567,"email":"virtual@oxebmvfonoemail.com","remark":"remarks","isFreeze":false,"createTime":1544433328000,"isManagedSubAccount":false,"isAssetManagementSubAccount":false}]}"#).unwrap();
            let dummy_response: models::QuerySubAccountListResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::QuerySubAccountListResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_sub_account_transaction_statistics(
            &self,
            _params: QuerySubAccountTransactionStatisticsParams,
        ) -> anyhow::Result<RestApiResponse<models::QuerySubAccountTransactionStatisticsResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"recent30BtcTotal":"0","recent30BtcFuturesTotal":"0","recent30BtcMarginTotal":"0","recent30BusdTotal":"0","recent30BusdFuturesTotal":"0","recent30BusdMarginTotal":"0","tradeInfoVos":[{"userId":1000138138384,"btc":0,"btcFutures":0,"btcMargin":0,"busd":0,"busdFutures":0,"busdMargin":0,"date":1676851200000},{"userId":1000138138384,"btc":0,"btcFutures":0,"btcMargin":0,"busd":0,"busdFutures":0,"busdMargin":0,"date":1677110400000},{"userId":1000138138384,"btc":0,"btcFutures":0,"btcMargin":0,"busd":0,"busdFutures":0,"busdMargin":0,"date":1677369600000}]}"#).unwrap();
            let dummy_response: models::QuerySubAccountTransactionStatisticsResponse =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into models::QuerySubAccountTransactionStatisticsResponse",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }
    }

    #[test]
    fn create_a_virtual_sub_account_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountManagementApiClient { force_error: false };

            let params =
                CreateAVirtualSubAccountParams::builder("sub_account_string_example".to_string())
                    .build()
                    .unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"email":"addsdd_virtual@aasaixwqnoemail.com"}"#).unwrap();
            let expected_response: models::CreateAVirtualSubAccountResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::CreateAVirtualSubAccountResponse");

            let resp = client
                .create_a_virtual_sub_account(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn create_a_virtual_sub_account_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountManagementApiClient { force_error: false };

            let params =
                CreateAVirtualSubAccountParams::builder("sub_account_string_example".to_string())
                    .recv_window(5000)
                    .build()
                    .unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"email":"addsdd_virtual@aasaixwqnoemail.com"}"#).unwrap();
            let expected_response: models::CreateAVirtualSubAccountResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::CreateAVirtualSubAccountResponse");

            let resp = client
                .create_a_virtual_sub_account(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn create_a_virtual_sub_account_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountManagementApiClient { force_error: true };

            let params =
                CreateAVirtualSubAccountParams::builder("sub_account_string_example".to_string())
                    .build()
                    .unwrap();

            match client.create_a_virtual_sub_account(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn enable_futures_for_sub_account_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountManagementApiClient { force_error: false };

            let params = EnableFuturesForSubAccountParams::builder(
                "sub-account-email@email.com".to_string(),
            )
            .build()
            .unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"email":"123@test.com","isFuturesEnabled":true}"#)
                    .unwrap();
            let expected_response: models::EnableFuturesForSubAccountResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::EnableFuturesForSubAccountResponse");

            let resp = client
                .enable_futures_for_sub_account(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn enable_futures_for_sub_account_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountManagementApiClient { force_error: false };

            let params = EnableFuturesForSubAccountParams::builder(
                "sub-account-email@email.com".to_string(),
            )
            .recv_window(5000)
            .build()
            .unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"email":"123@test.com","isFuturesEnabled":true}"#)
                    .unwrap();
            let expected_response: models::EnableFuturesForSubAccountResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::EnableFuturesForSubAccountResponse");

            let resp = client
                .enable_futures_for_sub_account(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn enable_futures_for_sub_account_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountManagementApiClient { force_error: true };

            let params = EnableFuturesForSubAccountParams::builder(
                "sub-account-email@email.com".to_string(),
            )
            .build()
            .unwrap();

            match client.enable_futures_for_sub_account(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn enable_options_for_sub_account_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountManagementApiClient { force_error: false };

            let params = EnableOptionsForSubAccountParams::builder(
                "sub-account-email@email.com".to_string(),
            )
            .build()
            .unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"email":"123@test.com","isEOptionsEnabled":true}"#)
                    .unwrap();
            let expected_response: models::EnableOptionsForSubAccountResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::EnableOptionsForSubAccountResponse");

            let resp = client
                .enable_options_for_sub_account(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn enable_options_for_sub_account_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountManagementApiClient { force_error: false };

            let params = EnableOptionsForSubAccountParams::builder(
                "sub-account-email@email.com".to_string(),
            )
            .recv_window(5000)
            .build()
            .unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"email":"123@test.com","isEOptionsEnabled":true}"#)
                    .unwrap();
            let expected_response: models::EnableOptionsForSubAccountResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::EnableOptionsForSubAccountResponse");

            let resp = client
                .enable_options_for_sub_account(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn enable_options_for_sub_account_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountManagementApiClient { force_error: true };

            let params = EnableOptionsForSubAccountParams::builder(
                "sub-account-email@email.com".to_string(),
            )
            .build()
            .unwrap();

            match client.enable_options_for_sub_account(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_futures_position_risk_of_sub_account_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountManagementApiClient { force_error: false };

            let params = GetFuturesPositionRiskOfSubAccountParams::builder("sub-account-email@email.com".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"entryPrice":"9975.12000","leverage":"50","maxNotional":"1000000","liquidationPrice":"7963.54","markPrice":"9973.50770517","positionAmount":"0.010","symbol":"BTCUSDT","unrealizedProfit":"-0.01612295"}]"#).unwrap();
            let expected_response : Vec<models::GetFuturesPositionRiskOfSubAccountV2ResponseFuturePositionRiskVosInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::GetFuturesPositionRiskOfSubAccountV2ResponseFuturePositionRiskVosInner>");

            let resp = client.get_futures_position_risk_of_sub_account(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_futures_position_risk_of_sub_account_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountManagementApiClient { force_error: false };

            let params = GetFuturesPositionRiskOfSubAccountParams::builder("sub-account-email@email.com".to_string(),).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"entryPrice":"9975.12000","leverage":"50","maxNotional":"1000000","liquidationPrice":"7963.54","markPrice":"9973.50770517","positionAmount":"0.010","symbol":"BTCUSDT","unrealizedProfit":"-0.01612295"}]"#).unwrap();
            let expected_response : Vec<models::GetFuturesPositionRiskOfSubAccountV2ResponseFuturePositionRiskVosInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::GetFuturesPositionRiskOfSubAccountV2ResponseFuturePositionRiskVosInner>");

            let resp = client.get_futures_position_risk_of_sub_account(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_futures_position_risk_of_sub_account_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountManagementApiClient { force_error: true };

            let params = GetFuturesPositionRiskOfSubAccountParams::builder(
                "sub-account-email@email.com".to_string(),
            )
            .build()
            .unwrap();

            match client
                .get_futures_position_risk_of_sub_account(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_futures_position_risk_of_sub_account_v2_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountManagementApiClient { force_error: false };

            let params = GetFuturesPositionRiskOfSubAccountV2Params::builder("sub-account-email@email.com".to_string(),789,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"futurePositionRiskVos":[{"entryPrice":"9975.12000","leverage":"50","maxNotional":"1000000","liquidationPrice":"7963.54","markPrice":"9973.50770517","positionAmount":"0.010","symbol":"BTCUSDT","unrealizedProfit":"-0.01612295"}],"deliveryPositionRiskVos":[{"entryPrice":"9975.12000","markPrice":"9973.50770517","leverage":"20","isolated":"false","isolatedWallet":"9973.50770517","isolatedMargin":"0.00000000","isAutoAddMargin":"false","positionSide":"BOTH","positionAmount":"1.230","symbol":"BTCUSD_201225","unrealizedProfit":"-0.01612295"}]}"#).unwrap();
            let expected_response : models::GetFuturesPositionRiskOfSubAccountV2Response = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetFuturesPositionRiskOfSubAccountV2Response");

            let resp = client.get_futures_position_risk_of_sub_account_v2(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_futures_position_risk_of_sub_account_v2_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountManagementApiClient { force_error: false };

            let params = GetFuturesPositionRiskOfSubAccountV2Params::builder("sub-account-email@email.com".to_string(),789,).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"futurePositionRiskVos":[{"entryPrice":"9975.12000","leverage":"50","maxNotional":"1000000","liquidationPrice":"7963.54","markPrice":"9973.50770517","positionAmount":"0.010","symbol":"BTCUSDT","unrealizedProfit":"-0.01612295"}],"deliveryPositionRiskVos":[{"entryPrice":"9975.12000","markPrice":"9973.50770517","leverage":"20","isolated":"false","isolatedWallet":"9973.50770517","isolatedMargin":"0.00000000","isAutoAddMargin":"false","positionSide":"BOTH","positionAmount":"1.230","symbol":"BTCUSD_201225","unrealizedProfit":"-0.01612295"}]}"#).unwrap();
            let expected_response : models::GetFuturesPositionRiskOfSubAccountV2Response = serde_json::from_value(resp_json.clone()).expect("should parse into models::GetFuturesPositionRiskOfSubAccountV2Response");

            let resp = client.get_futures_position_risk_of_sub_account_v2(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_futures_position_risk_of_sub_account_v2_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountManagementApiClient { force_error: true };

            let params = GetFuturesPositionRiskOfSubAccountV2Params::builder(
                "sub-account-email@email.com".to_string(),
                789,
            )
            .build()
            .unwrap();

            match client
                .get_futures_position_risk_of_sub_account_v2(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_sub_accounts_status_on_margin_or_futures_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountManagementApiClient { force_error: false };

            let params = GetSubAccountsStatusOnMarginOrFuturesParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"email":"123@test.com","isSubUserEnabled":true,"isUserActive":true,"insertTime":1570791523523,"isMarginEnabled":true,"isFutureEnabled":true,"mobile":1570791523523}]"#).unwrap();
            let expected_response : Vec<models::GetSubAccountsStatusOnMarginOrFuturesResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::GetSubAccountsStatusOnMarginOrFuturesResponseInner>");

            let resp = client.get_sub_accounts_status_on_margin_or_futures(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_sub_accounts_status_on_margin_or_futures_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountManagementApiClient { force_error: false };

            let params = GetSubAccountsStatusOnMarginOrFuturesParams::builder().email("email_example".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"email":"123@test.com","isSubUserEnabled":true,"isUserActive":true,"insertTime":1570791523523,"isMarginEnabled":true,"isFutureEnabled":true,"mobile":1570791523523}]"#).unwrap();
            let expected_response : Vec<models::GetSubAccountsStatusOnMarginOrFuturesResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::GetSubAccountsStatusOnMarginOrFuturesResponseInner>");

            let resp = client.get_sub_accounts_status_on_margin_or_futures(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_sub_accounts_status_on_margin_or_futures_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountManagementApiClient { force_error: true };

            let params = GetSubAccountsStatusOnMarginOrFuturesParams::builder()
                .build()
                .unwrap();

            match client
                .get_sub_accounts_status_on_margin_or_futures(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_sub_account_list_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountManagementApiClient { force_error: false };

            let params = QuerySubAccountListParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"subAccounts":[{"subUserId":123456,"email":"testsub@gmail.com","remark":"remark","isFreeze":false,"createTime":1544433328000,"isManagedSubAccount":false,"isAssetManagementSubAccount":false},{"subUserId":1234567,"email":"virtual@oxebmvfonoemail.com","remark":"remarks","isFreeze":false,"createTime":1544433328000,"isManagedSubAccount":false,"isAssetManagementSubAccount":false}]}"#).unwrap();
            let expected_response : models::QuerySubAccountListResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QuerySubAccountListResponse");

            let resp = client.query_sub_account_list(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_sub_account_list_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountManagementApiClient { force_error: false };

            let params = QuerySubAccountListParams::builder().email("email_example".to_string()).is_freeze("is_freeze_example".to_string()).page(1).limit(1).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"subAccounts":[{"subUserId":123456,"email":"testsub@gmail.com","remark":"remark","isFreeze":false,"createTime":1544433328000,"isManagedSubAccount":false,"isAssetManagementSubAccount":false},{"subUserId":1234567,"email":"virtual@oxebmvfonoemail.com","remark":"remarks","isFreeze":false,"createTime":1544433328000,"isManagedSubAccount":false,"isAssetManagementSubAccount":false}]}"#).unwrap();
            let expected_response : models::QuerySubAccountListResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QuerySubAccountListResponse");

            let resp = client.query_sub_account_list(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_sub_account_list_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountManagementApiClient { force_error: true };

            let params = QuerySubAccountListParams::builder().build().unwrap();

            match client.query_sub_account_list(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_sub_account_transaction_statistics_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountManagementApiClient { force_error: false };

            let params = QuerySubAccountTransactionStatisticsParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"recent30BtcTotal":"0","recent30BtcFuturesTotal":"0","recent30BtcMarginTotal":"0","recent30BusdTotal":"0","recent30BusdFuturesTotal":"0","recent30BusdMarginTotal":"0","tradeInfoVos":[{"userId":1000138138384,"btc":0,"btcFutures":0,"btcMargin":0,"busd":0,"busdFutures":0,"busdMargin":0,"date":1676851200000},{"userId":1000138138384,"btc":0,"btcFutures":0,"btcMargin":0,"busd":0,"busdFutures":0,"busdMargin":0,"date":1677110400000},{"userId":1000138138384,"btc":0,"btcFutures":0,"btcMargin":0,"busd":0,"busdFutures":0,"busdMargin":0,"date":1677369600000}]}"#).unwrap();
            let expected_response : models::QuerySubAccountTransactionStatisticsResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QuerySubAccountTransactionStatisticsResponse");

            let resp = client.query_sub_account_transaction_statistics(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_sub_account_transaction_statistics_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountManagementApiClient { force_error: false };

            let params = QuerySubAccountTransactionStatisticsParams::builder().email("email_example".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"recent30BtcTotal":"0","recent30BtcFuturesTotal":"0","recent30BtcMarginTotal":"0","recent30BusdTotal":"0","recent30BusdFuturesTotal":"0","recent30BusdMarginTotal":"0","tradeInfoVos":[{"userId":1000138138384,"btc":0,"btcFutures":0,"btcMargin":0,"busd":0,"busdFutures":0,"busdMargin":0,"date":1676851200000},{"userId":1000138138384,"btc":0,"btcFutures":0,"btcMargin":0,"busd":0,"busdFutures":0,"busdMargin":0,"date":1677110400000},{"userId":1000138138384,"btc":0,"btcFutures":0,"btcMargin":0,"busd":0,"busdFutures":0,"busdMargin":0,"date":1677369600000}]}"#).unwrap();
            let expected_response : models::QuerySubAccountTransactionStatisticsResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QuerySubAccountTransactionStatisticsResponse");

            let resp = client.query_sub_account_transaction_statistics(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_sub_account_transaction_statistics_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockAccountManagementApiClient { force_error: true };

            let params = QuerySubAccountTransactionStatisticsParams::builder()
                .build()
                .unwrap();

            match client
                .query_sub_account_transaction_statistics(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }
}
