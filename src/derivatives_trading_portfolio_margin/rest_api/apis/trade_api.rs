/*
 * Binance Derivatives Trading Portfolio Margin REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading Portfolio Margin REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#![allow(unused_imports)]
use async_trait::async_trait;
use derive_builder::Builder;
use reqwest;
use rust_decimal::prelude::*;
use serde::{Deserialize, Serialize};
use serde_json::{Value, json};
use std::collections::BTreeMap;

use crate::common::{
    config::ConfigurationRestApi,
    models::{ParamBuildError, RestApiResponse},
    utils::send_request,
};
use crate::derivatives_trading_portfolio_margin::rest_api::models;

const HAS_TIME_UNIT: bool = false;

#[async_trait]
pub trait TradeApi: Send + Sync {
    async fn cancel_all_cm_open_conditional_orders(
        &self,
        params: CancelAllCmOpenConditionalOrdersParams,
    ) -> anyhow::Result<RestApiResponse<models::CancelAllCmOpenConditionalOrdersResponse>>;
    async fn cancel_all_cm_open_orders(
        &self,
        params: CancelAllCmOpenOrdersParams,
    ) -> anyhow::Result<RestApiResponse<models::CancelAllCmOpenOrdersResponse>>;
    async fn cancel_all_um_open_conditional_orders(
        &self,
        params: CancelAllUmOpenConditionalOrdersParams,
    ) -> anyhow::Result<RestApiResponse<models::CancelAllUmOpenConditionalOrdersResponse>>;
    async fn cancel_all_um_open_orders(
        &self,
        params: CancelAllUmOpenOrdersParams,
    ) -> anyhow::Result<RestApiResponse<models::CancelAllUmOpenOrdersResponse>>;
    async fn cancel_cm_conditional_order(
        &self,
        params: CancelCmConditionalOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::CancelCmConditionalOrderResponse>>;
    async fn cancel_cm_order(
        &self,
        params: CancelCmOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::CancelCmOrderResponse>>;
    async fn cancel_margin_account_all_open_orders_on_a_symbol(
        &self,
        params: CancelMarginAccountAllOpenOrdersOnASymbolParams,
    ) -> anyhow::Result<
        RestApiResponse<Vec<models::CancelMarginAccountAllOpenOrdersOnASymbolResponseInner>>,
    >;
    async fn cancel_margin_account_oco_orders(
        &self,
        params: CancelMarginAccountOcoOrdersParams,
    ) -> anyhow::Result<RestApiResponse<models::CancelMarginAccountOcoOrdersResponse>>;
    async fn cancel_margin_account_order(
        &self,
        params: CancelMarginAccountOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::CancelMarginAccountOrderResponse>>;
    async fn cancel_um_conditional_order(
        &self,
        params: CancelUmConditionalOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::CancelUmConditionalOrderResponse>>;
    async fn cancel_um_order(
        &self,
        params: CancelUmOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::CancelUmOrderResponse>>;
    async fn cm_account_trade_list(
        &self,
        params: CmAccountTradeListParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::CmAccountTradeListResponseInner>>>;
    async fn cm_position_adl_quantile_estimation(
        &self,
        params: CmPositionAdlQuantileEstimationParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::CmPositionAdlQuantileEstimationResponseInner>>>;
    async fn get_um_futures_bnb_burn_status(
        &self,
        params: GetUmFuturesBnbBurnStatusParams,
    ) -> anyhow::Result<RestApiResponse<models::GetUmFuturesBnbBurnStatusResponse>>;
    async fn margin_account_borrow(
        &self,
        params: MarginAccountBorrowParams,
    ) -> anyhow::Result<RestApiResponse<models::MarginAccountBorrowResponse>>;
    async fn margin_account_new_oco(
        &self,
        params: MarginAccountNewOcoParams,
    ) -> anyhow::Result<RestApiResponse<models::MarginAccountNewOcoResponse>>;
    async fn margin_account_repay(
        &self,
        params: MarginAccountRepayParams,
    ) -> anyhow::Result<RestApiResponse<models::MarginAccountRepayResponse>>;
    async fn margin_account_repay_debt(
        &self,
        params: MarginAccountRepayDebtParams,
    ) -> anyhow::Result<RestApiResponse<models::MarginAccountRepayDebtResponse>>;
    async fn margin_account_trade_list(
        &self,
        params: MarginAccountTradeListParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::MarginAccountTradeListResponseInner>>>;
    async fn modify_cm_order(
        &self,
        params: ModifyCmOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::ModifyCmOrderResponse>>;
    async fn modify_um_order(
        &self,
        params: ModifyUmOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::ModifyUmOrderResponse>>;
    async fn new_cm_conditional_order(
        &self,
        params: NewCmConditionalOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::NewCmConditionalOrderResponse>>;
    async fn new_cm_order(
        &self,
        params: NewCmOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::NewCmOrderResponse>>;
    async fn new_margin_order(
        &self,
        params: NewMarginOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::NewMarginOrderResponse>>;
    async fn new_um_conditional_order(
        &self,
        params: NewUmConditionalOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::NewUmConditionalOrderResponse>>;
    async fn new_um_order(
        &self,
        params: NewUmOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::NewUmOrderResponse>>;
    async fn query_all_cm_conditional_orders(
        &self,
        params: QueryAllCmConditionalOrdersParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryAllCmConditionalOrdersResponseInner>>>;
    async fn query_all_cm_orders(
        &self,
        params: QueryAllCmOrdersParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryAllCmOrdersResponseInner>>>;
    async fn query_all_current_cm_open_conditional_orders(
        &self,
        params: QueryAllCurrentCmOpenConditionalOrdersParams,
    ) -> anyhow::Result<
        RestApiResponse<Vec<models::QueryAllCurrentCmOpenConditionalOrdersResponseInner>>,
    >;
    async fn query_all_current_cm_open_orders(
        &self,
        params: QueryAllCurrentCmOpenOrdersParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryAllCmOrdersResponseInner>>>;
    async fn query_all_current_um_open_conditional_orders(
        &self,
        params: QueryAllCurrentUmOpenConditionalOrdersParams,
    ) -> anyhow::Result<
        RestApiResponse<Vec<models::QueryAllCurrentUmOpenConditionalOrdersResponseInner>>,
    >;
    async fn query_all_current_um_open_orders(
        &self,
        params: QueryAllCurrentUmOpenOrdersParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryAllCurrentUmOpenOrdersResponseInner>>>;
    async fn query_all_margin_account_orders(
        &self,
        params: QueryAllMarginAccountOrdersParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryAllMarginAccountOrdersResponseInner>>>;
    async fn query_all_um_conditional_orders(
        &self,
        params: QueryAllUmConditionalOrdersParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryAllUmConditionalOrdersResponseInner>>>;
    async fn query_all_um_orders(
        &self,
        params: QueryAllUmOrdersParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryAllCurrentUmOpenOrdersResponseInner>>>;
    async fn query_cm_conditional_order_history(
        &self,
        params: QueryCmConditionalOrderHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryCmConditionalOrderHistoryResponse>>;
    async fn query_cm_modify_order_history(
        &self,
        params: QueryCmModifyOrderHistoryParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryCmModifyOrderHistoryResponseInner>>>;
    async fn query_cm_order(
        &self,
        params: QueryCmOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryCmOrderResponse>>;
    async fn query_current_cm_open_conditional_order(
        &self,
        params: QueryCurrentCmOpenConditionalOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryCurrentCmOpenConditionalOrderResponse>>;
    async fn query_current_cm_open_order(
        &self,
        params: QueryCurrentCmOpenOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryCurrentCmOpenOrderResponse>>;
    async fn query_current_margin_open_order(
        &self,
        params: QueryCurrentMarginOpenOrderParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryCurrentMarginOpenOrderResponseInner>>>;
    async fn query_current_um_open_conditional_order(
        &self,
        params: QueryCurrentUmOpenConditionalOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryCurrentUmOpenConditionalOrderResponse>>;
    async fn query_current_um_open_order(
        &self,
        params: QueryCurrentUmOpenOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryCurrentUmOpenOrderResponse>>;
    async fn query_margin_account_order(
        &self,
        params: QueryMarginAccountOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryMarginAccountOrderResponse>>;
    async fn query_margin_accounts_all_oco(
        &self,
        params: QueryMarginAccountsAllOcoParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryMarginAccountsAllOcoResponseInner>>>;
    async fn query_margin_accounts_oco(
        &self,
        params: QueryMarginAccountsOcoParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryMarginAccountsOcoResponse>>;
    async fn query_margin_accounts_open_oco(
        &self,
        params: QueryMarginAccountsOpenOcoParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryMarginAccountsOpenOcoResponseInner>>>;
    async fn query_um_conditional_order_history(
        &self,
        params: QueryUmConditionalOrderHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryUmConditionalOrderHistoryResponse>>;
    async fn query_um_modify_order_history(
        &self,
        params: QueryUmModifyOrderHistoryParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryUmModifyOrderHistoryResponseInner>>>;
    async fn query_um_order(
        &self,
        params: QueryUmOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryUmOrderResponse>>;
    async fn query_users_cm_force_orders(
        &self,
        params: QueryUsersCmForceOrdersParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryUsersCmForceOrdersResponseInner>>>;
    async fn query_users_margin_force_orders(
        &self,
        params: QueryUsersMarginForceOrdersParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryUsersMarginForceOrdersResponse>>;
    async fn query_users_um_force_orders(
        &self,
        params: QueryUsersUmForceOrdersParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryUsersUmForceOrdersResponseInner>>>;
    async fn toggle_bnb_burn_on_um_futures_trade(
        &self,
        params: ToggleBnbBurnOnUmFuturesTradeParams,
    ) -> anyhow::Result<RestApiResponse<models::ToggleBnbBurnOnUmFuturesTradeResponse>>;
    async fn um_account_trade_list(
        &self,
        params: UmAccountTradeListParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::UmAccountTradeListResponseInner>>>;
    async fn um_position_adl_quantile_estimation(
        &self,
        params: UmPositionAdlQuantileEstimationParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::UmPositionAdlQuantileEstimationResponseInner>>>;
}

#[derive(Debug, Clone)]
pub struct TradeApiClient {
    configuration: ConfigurationRestApi,
}

impl TradeApiClient {
    pub fn new(configuration: ConfigurationRestApi) -> Self {
        Self { configuration }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MarginAccountNewOcoSideEnum {
    #[serde(rename = "BUY")]
    Buy,
    #[serde(rename = "SELL")]
    Sell,
}

impl MarginAccountNewOcoSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Buy => "BUY",
            Self::Sell => "SELL",
        }
    }
}

impl std::str::FromStr for MarginAccountNewOcoSideEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "BUY" => Ok(Self::Buy),
            "SELL" => Ok(Self::Sell),
            other => Err(format!("invalid MarginAccountNewOcoSideEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MarginAccountNewOcoStopLimitTimeInForceEnum {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "IOC")]
    Ioc,
    #[serde(rename = "FOK")]
    Fok,
}

impl MarginAccountNewOcoStopLimitTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Gtc => "GTC",
            Self::Ioc => "IOC",
            Self::Fok => "FOK",
        }
    }
}

impl std::str::FromStr for MarginAccountNewOcoStopLimitTimeInForceEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "GTC" => Ok(Self::Gtc),
            "IOC" => Ok(Self::Ioc),
            "FOK" => Ok(Self::Fok),
            other => Err(format!(
                "invalid MarginAccountNewOcoStopLimitTimeInForceEnum: {}",
                other
            )
            .into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MarginAccountNewOcoNewOrderRespTypeEnum {
    #[serde(rename = "ACK")]
    Ack,
    #[serde(rename = "RESULT")]
    Result,
}

impl MarginAccountNewOcoNewOrderRespTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Ack => "ACK",
            Self::Result => "RESULT",
        }
    }
}

impl std::str::FromStr for MarginAccountNewOcoNewOrderRespTypeEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "ACK" => Ok(Self::Ack),
            "RESULT" => Ok(Self::Result),
            other => {
                Err(format!("invalid MarginAccountNewOcoNewOrderRespTypeEnum: {}", other).into())
            }
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MarginAccountNewOcoSideEffectTypeEnum {
    #[serde(rename = "NO_SIDE_EFFECT")]
    NoSideEffect,
    #[serde(rename = "MARGIN_BUY")]
    MarginBuy,
    #[serde(rename = "AUTO_REPAY")]
    AutoRepay,
}

impl MarginAccountNewOcoSideEffectTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::NoSideEffect => "NO_SIDE_EFFECT",
            Self::MarginBuy => "MARGIN_BUY",
            Self::AutoRepay => "AUTO_REPAY",
        }
    }
}

impl std::str::FromStr for MarginAccountNewOcoSideEffectTypeEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "NO_SIDE_EFFECT" => Ok(Self::NoSideEffect),
            "MARGIN_BUY" => Ok(Self::MarginBuy),
            "AUTO_REPAY" => Ok(Self::AutoRepay),
            other => {
                Err(format!("invalid MarginAccountNewOcoSideEffectTypeEnum: {}", other).into())
            }
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ModifyCmOrderSideEnum {
    #[serde(rename = "BUY")]
    Buy,
    #[serde(rename = "SELL")]
    Sell,
}

impl ModifyCmOrderSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Buy => "BUY",
            Self::Sell => "SELL",
        }
    }
}

impl std::str::FromStr for ModifyCmOrderSideEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "BUY" => Ok(Self::Buy),
            "SELL" => Ok(Self::Sell),
            other => Err(format!("invalid ModifyCmOrderSideEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ModifyCmOrderPriceMatchEnum {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "OPPONENT")]
    Opponent,
    #[serde(rename = "OPPONENT_5")]
    Opponent5,
    #[serde(rename = "OPPONENT_10")]
    Opponent10,
    #[serde(rename = "OPPONENT_20")]
    Opponent20,
    #[serde(rename = "QUEUE")]
    Queue,
    #[serde(rename = "QUEUE_5")]
    Queue5,
    #[serde(rename = "QUEUE_10")]
    Queue10,
    #[serde(rename = "QUEUE_20")]
    Queue20,
}

impl ModifyCmOrderPriceMatchEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::None => "NONE",
            Self::Opponent => "OPPONENT",
            Self::Opponent5 => "OPPONENT_5",
            Self::Opponent10 => "OPPONENT_10",
            Self::Opponent20 => "OPPONENT_20",
            Self::Queue => "QUEUE",
            Self::Queue5 => "QUEUE_5",
            Self::Queue10 => "QUEUE_10",
            Self::Queue20 => "QUEUE_20",
        }
    }
}

impl std::str::FromStr for ModifyCmOrderPriceMatchEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "NONE" => Ok(Self::None),
            "OPPONENT" => Ok(Self::Opponent),
            "OPPONENT_5" => Ok(Self::Opponent5),
            "OPPONENT_10" => Ok(Self::Opponent10),
            "OPPONENT_20" => Ok(Self::Opponent20),
            "QUEUE" => Ok(Self::Queue),
            "QUEUE_5" => Ok(Self::Queue5),
            "QUEUE_10" => Ok(Self::Queue10),
            "QUEUE_20" => Ok(Self::Queue20),
            other => Err(format!("invalid ModifyCmOrderPriceMatchEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ModifyUmOrderSideEnum {
    #[serde(rename = "BUY")]
    Buy,
    #[serde(rename = "SELL")]
    Sell,
}

impl ModifyUmOrderSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Buy => "BUY",
            Self::Sell => "SELL",
        }
    }
}

impl std::str::FromStr for ModifyUmOrderSideEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "BUY" => Ok(Self::Buy),
            "SELL" => Ok(Self::Sell),
            other => Err(format!("invalid ModifyUmOrderSideEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ModifyUmOrderPriceMatchEnum {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "OPPONENT")]
    Opponent,
    #[serde(rename = "OPPONENT_5")]
    Opponent5,
    #[serde(rename = "OPPONENT_10")]
    Opponent10,
    #[serde(rename = "OPPONENT_20")]
    Opponent20,
    #[serde(rename = "QUEUE")]
    Queue,
    #[serde(rename = "QUEUE_5")]
    Queue5,
    #[serde(rename = "QUEUE_10")]
    Queue10,
    #[serde(rename = "QUEUE_20")]
    Queue20,
}

impl ModifyUmOrderPriceMatchEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::None => "NONE",
            Self::Opponent => "OPPONENT",
            Self::Opponent5 => "OPPONENT_5",
            Self::Opponent10 => "OPPONENT_10",
            Self::Opponent20 => "OPPONENT_20",
            Self::Queue => "QUEUE",
            Self::Queue5 => "QUEUE_5",
            Self::Queue10 => "QUEUE_10",
            Self::Queue20 => "QUEUE_20",
        }
    }
}

impl std::str::FromStr for ModifyUmOrderPriceMatchEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "NONE" => Ok(Self::None),
            "OPPONENT" => Ok(Self::Opponent),
            "OPPONENT_5" => Ok(Self::Opponent5),
            "OPPONENT_10" => Ok(Self::Opponent10),
            "OPPONENT_20" => Ok(Self::Opponent20),
            "QUEUE" => Ok(Self::Queue),
            "QUEUE_5" => Ok(Self::Queue5),
            "QUEUE_10" => Ok(Self::Queue10),
            "QUEUE_20" => Ok(Self::Queue20),
            other => Err(format!("invalid ModifyUmOrderPriceMatchEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewCmConditionalOrderSideEnum {
    #[serde(rename = "BUY")]
    Buy,
    #[serde(rename = "SELL")]
    Sell,
}

impl NewCmConditionalOrderSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Buy => "BUY",
            Self::Sell => "SELL",
        }
    }
}

impl std::str::FromStr for NewCmConditionalOrderSideEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "BUY" => Ok(Self::Buy),
            "SELL" => Ok(Self::Sell),
            other => Err(format!("invalid NewCmConditionalOrderSideEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewCmConditionalOrderStrategyTypeEnum {
    #[serde(rename = "STOP")]
    Stop,
    #[serde(rename = "STOP_MARKET")]
    StopMarket,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "TAKE_PROFIT_MARKET")]
    TakeProfitMarket,
    #[serde(rename = "TRAILING_STOP_MARKET")]
    TrailingStopMarket,
}

impl NewCmConditionalOrderStrategyTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Stop => "STOP",
            Self::StopMarket => "STOP_MARKET",
            Self::TakeProfit => "TAKE_PROFIT",
            Self::TakeProfitMarket => "TAKE_PROFIT_MARKET",
            Self::TrailingStopMarket => "TRAILING_STOP_MARKET",
        }
    }
}

impl std::str::FromStr for NewCmConditionalOrderStrategyTypeEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "STOP" => Ok(Self::Stop),
            "STOP_MARKET" => Ok(Self::StopMarket),
            "TAKE_PROFIT" => Ok(Self::TakeProfit),
            "TAKE_PROFIT_MARKET" => Ok(Self::TakeProfitMarket),
            "TRAILING_STOP_MARKET" => Ok(Self::TrailingStopMarket),
            other => {
                Err(format!("invalid NewCmConditionalOrderStrategyTypeEnum: {}", other).into())
            }
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewCmConditionalOrderPositionSideEnum {
    #[serde(rename = "BOTH")]
    Both,
    #[serde(rename = "LONG")]
    Long,
    #[serde(rename = "SHORT")]
    Short,
}

impl NewCmConditionalOrderPositionSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Both => "BOTH",
            Self::Long => "LONG",
            Self::Short => "SHORT",
        }
    }
}

impl std::str::FromStr for NewCmConditionalOrderPositionSideEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "BOTH" => Ok(Self::Both),
            "LONG" => Ok(Self::Long),
            "SHORT" => Ok(Self::Short),
            other => {
                Err(format!("invalid NewCmConditionalOrderPositionSideEnum: {}", other).into())
            }
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewCmConditionalOrderTimeInForceEnum {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "IOC")]
    Ioc,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "GTX")]
    Gtx,
}

impl NewCmConditionalOrderTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Gtc => "GTC",
            Self::Ioc => "IOC",
            Self::Fok => "FOK",
            Self::Gtx => "GTX",
        }
    }
}

impl std::str::FromStr for NewCmConditionalOrderTimeInForceEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "GTC" => Ok(Self::Gtc),
            "IOC" => Ok(Self::Ioc),
            "FOK" => Ok(Self::Fok),
            "GTX" => Ok(Self::Gtx),
            other => Err(format!("invalid NewCmConditionalOrderTimeInForceEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewCmConditionalOrderWorkingTypeEnum {
    #[serde(rename = "MARK_PRICE")]
    MarkPrice,
}

impl NewCmConditionalOrderWorkingTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::MarkPrice => "MARK_PRICE",
        }
    }
}

impl std::str::FromStr for NewCmConditionalOrderWorkingTypeEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "MARK_PRICE" => Ok(Self::MarkPrice),
            other => Err(format!("invalid NewCmConditionalOrderWorkingTypeEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewCmOrderSideEnum {
    #[serde(rename = "BUY")]
    Buy,
    #[serde(rename = "SELL")]
    Sell,
}

impl NewCmOrderSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Buy => "BUY",
            Self::Sell => "SELL",
        }
    }
}

impl std::str::FromStr for NewCmOrderSideEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "BUY" => Ok(Self::Buy),
            "SELL" => Ok(Self::Sell),
            other => Err(format!("invalid NewCmOrderSideEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewCmOrderTypeEnum {
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "MARKET")]
    Market,
}

impl NewCmOrderTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Limit => "LIMIT",
            Self::Market => "MARKET",
        }
    }
}

impl std::str::FromStr for NewCmOrderTypeEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "LIMIT" => Ok(Self::Limit),
            "MARKET" => Ok(Self::Market),
            other => Err(format!("invalid NewCmOrderTypeEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewCmOrderPositionSideEnum {
    #[serde(rename = "BOTH")]
    Both,
    #[serde(rename = "LONG")]
    Long,
    #[serde(rename = "SHORT")]
    Short,
}

impl NewCmOrderPositionSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Both => "BOTH",
            Self::Long => "LONG",
            Self::Short => "SHORT",
        }
    }
}

impl std::str::FromStr for NewCmOrderPositionSideEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "BOTH" => Ok(Self::Both),
            "LONG" => Ok(Self::Long),
            "SHORT" => Ok(Self::Short),
            other => Err(format!("invalid NewCmOrderPositionSideEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewCmOrderTimeInForceEnum {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "IOC")]
    Ioc,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "GTX")]
    Gtx,
}

impl NewCmOrderTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Gtc => "GTC",
            Self::Ioc => "IOC",
            Self::Fok => "FOK",
            Self::Gtx => "GTX",
        }
    }
}

impl std::str::FromStr for NewCmOrderTimeInForceEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "GTC" => Ok(Self::Gtc),
            "IOC" => Ok(Self::Ioc),
            "FOK" => Ok(Self::Fok),
            "GTX" => Ok(Self::Gtx),
            other => Err(format!("invalid NewCmOrderTimeInForceEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewCmOrderPriceMatchEnum {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "OPPONENT")]
    Opponent,
    #[serde(rename = "OPPONENT_5")]
    Opponent5,
    #[serde(rename = "OPPONENT_10")]
    Opponent10,
    #[serde(rename = "OPPONENT_20")]
    Opponent20,
    #[serde(rename = "QUEUE")]
    Queue,
    #[serde(rename = "QUEUE_5")]
    Queue5,
    #[serde(rename = "QUEUE_10")]
    Queue10,
    #[serde(rename = "QUEUE_20")]
    Queue20,
}

impl NewCmOrderPriceMatchEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::None => "NONE",
            Self::Opponent => "OPPONENT",
            Self::Opponent5 => "OPPONENT_5",
            Self::Opponent10 => "OPPONENT_10",
            Self::Opponent20 => "OPPONENT_20",
            Self::Queue => "QUEUE",
            Self::Queue5 => "QUEUE_5",
            Self::Queue10 => "QUEUE_10",
            Self::Queue20 => "QUEUE_20",
        }
    }
}

impl std::str::FromStr for NewCmOrderPriceMatchEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "NONE" => Ok(Self::None),
            "OPPONENT" => Ok(Self::Opponent),
            "OPPONENT_5" => Ok(Self::Opponent5),
            "OPPONENT_10" => Ok(Self::Opponent10),
            "OPPONENT_20" => Ok(Self::Opponent20),
            "QUEUE" => Ok(Self::Queue),
            "QUEUE_5" => Ok(Self::Queue5),
            "QUEUE_10" => Ok(Self::Queue10),
            "QUEUE_20" => Ok(Self::Queue20),
            other => Err(format!("invalid NewCmOrderPriceMatchEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewCmOrderNewOrderRespTypeEnum {
    #[serde(rename = "ACK")]
    Ack,
    #[serde(rename = "RESULT")]
    Result,
}

impl NewCmOrderNewOrderRespTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Ack => "ACK",
            Self::Result => "RESULT",
        }
    }
}

impl std::str::FromStr for NewCmOrderNewOrderRespTypeEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "ACK" => Ok(Self::Ack),
            "RESULT" => Ok(Self::Result),
            other => Err(format!("invalid NewCmOrderNewOrderRespTypeEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewMarginOrderSideEnum {
    #[serde(rename = "BUY")]
    Buy,
    #[serde(rename = "SELL")]
    Sell,
}

impl NewMarginOrderSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Buy => "BUY",
            Self::Sell => "SELL",
        }
    }
}

impl std::str::FromStr for NewMarginOrderSideEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "BUY" => Ok(Self::Buy),
            "SELL" => Ok(Self::Sell),
            other => Err(format!("invalid NewMarginOrderSideEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewMarginOrderTypeEnum {
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "MARKET")]
    Market,
}

impl NewMarginOrderTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Limit => "LIMIT",
            Self::Market => "MARKET",
        }
    }
}

impl std::str::FromStr for NewMarginOrderTypeEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "LIMIT" => Ok(Self::Limit),
            "MARKET" => Ok(Self::Market),
            other => Err(format!("invalid NewMarginOrderTypeEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewMarginOrderNewOrderRespTypeEnum {
    #[serde(rename = "ACK")]
    Ack,
    #[serde(rename = "RESULT")]
    Result,
}

impl NewMarginOrderNewOrderRespTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Ack => "ACK",
            Self::Result => "RESULT",
        }
    }
}

impl std::str::FromStr for NewMarginOrderNewOrderRespTypeEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "ACK" => Ok(Self::Ack),
            "RESULT" => Ok(Self::Result),
            other => Err(format!("invalid NewMarginOrderNewOrderRespTypeEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewMarginOrderSideEffectTypeEnum {
    #[serde(rename = "NO_SIDE_EFFECT")]
    NoSideEffect,
    #[serde(rename = "MARGIN_BUY")]
    MarginBuy,
    #[serde(rename = "AUTO_REPAY")]
    AutoRepay,
}

impl NewMarginOrderSideEffectTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::NoSideEffect => "NO_SIDE_EFFECT",
            Self::MarginBuy => "MARGIN_BUY",
            Self::AutoRepay => "AUTO_REPAY",
        }
    }
}

impl std::str::FromStr for NewMarginOrderSideEffectTypeEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "NO_SIDE_EFFECT" => Ok(Self::NoSideEffect),
            "MARGIN_BUY" => Ok(Self::MarginBuy),
            "AUTO_REPAY" => Ok(Self::AutoRepay),
            other => Err(format!("invalid NewMarginOrderSideEffectTypeEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewMarginOrderTimeInForceEnum {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "IOC")]
    Ioc,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "GTX")]
    Gtx,
}

impl NewMarginOrderTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Gtc => "GTC",
            Self::Ioc => "IOC",
            Self::Fok => "FOK",
            Self::Gtx => "GTX",
        }
    }
}

impl std::str::FromStr for NewMarginOrderTimeInForceEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "GTC" => Ok(Self::Gtc),
            "IOC" => Ok(Self::Ioc),
            "FOK" => Ok(Self::Fok),
            "GTX" => Ok(Self::Gtx),
            other => Err(format!("invalid NewMarginOrderTimeInForceEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewMarginOrderSelfTradePreventionModeEnum {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "EXPIRE_TAKER")]
    ExpireTaker,
    #[serde(rename = "EXPIRE_BOTH")]
    ExpireBoth,
    #[serde(rename = "EXPIRE_MAKER")]
    ExpireMaker,
}

impl NewMarginOrderSelfTradePreventionModeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::None => "NONE",
            Self::ExpireTaker => "EXPIRE_TAKER",
            Self::ExpireBoth => "EXPIRE_BOTH",
            Self::ExpireMaker => "EXPIRE_MAKER",
        }
    }
}

impl std::str::FromStr for NewMarginOrderSelfTradePreventionModeEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "NONE" => Ok(Self::None),
            "EXPIRE_TAKER" => Ok(Self::ExpireTaker),
            "EXPIRE_BOTH" => Ok(Self::ExpireBoth),
            "EXPIRE_MAKER" => Ok(Self::ExpireMaker),
            other => Err(format!(
                "invalid NewMarginOrderSelfTradePreventionModeEnum: {}",
                other
            )
            .into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewUmConditionalOrderSideEnum {
    #[serde(rename = "BUY")]
    Buy,
    #[serde(rename = "SELL")]
    Sell,
}

impl NewUmConditionalOrderSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Buy => "BUY",
            Self::Sell => "SELL",
        }
    }
}

impl std::str::FromStr for NewUmConditionalOrderSideEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "BUY" => Ok(Self::Buy),
            "SELL" => Ok(Self::Sell),
            other => Err(format!("invalid NewUmConditionalOrderSideEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewUmConditionalOrderStrategyTypeEnum {
    #[serde(rename = "STOP")]
    Stop,
    #[serde(rename = "STOP_MARKET")]
    StopMarket,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "TAKE_PROFIT_MARKET")]
    TakeProfitMarket,
    #[serde(rename = "TRAILING_STOP_MARKET")]
    TrailingStopMarket,
}

impl NewUmConditionalOrderStrategyTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Stop => "STOP",
            Self::StopMarket => "STOP_MARKET",
            Self::TakeProfit => "TAKE_PROFIT",
            Self::TakeProfitMarket => "TAKE_PROFIT_MARKET",
            Self::TrailingStopMarket => "TRAILING_STOP_MARKET",
        }
    }
}

impl std::str::FromStr for NewUmConditionalOrderStrategyTypeEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "STOP" => Ok(Self::Stop),
            "STOP_MARKET" => Ok(Self::StopMarket),
            "TAKE_PROFIT" => Ok(Self::TakeProfit),
            "TAKE_PROFIT_MARKET" => Ok(Self::TakeProfitMarket),
            "TRAILING_STOP_MARKET" => Ok(Self::TrailingStopMarket),
            other => {
                Err(format!("invalid NewUmConditionalOrderStrategyTypeEnum: {}", other).into())
            }
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewUmConditionalOrderPositionSideEnum {
    #[serde(rename = "BOTH")]
    Both,
    #[serde(rename = "LONG")]
    Long,
    #[serde(rename = "SHORT")]
    Short,
}

impl NewUmConditionalOrderPositionSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Both => "BOTH",
            Self::Long => "LONG",
            Self::Short => "SHORT",
        }
    }
}

impl std::str::FromStr for NewUmConditionalOrderPositionSideEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "BOTH" => Ok(Self::Both),
            "LONG" => Ok(Self::Long),
            "SHORT" => Ok(Self::Short),
            other => {
                Err(format!("invalid NewUmConditionalOrderPositionSideEnum: {}", other).into())
            }
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewUmConditionalOrderTimeInForceEnum {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "IOC")]
    Ioc,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "GTX")]
    Gtx,
}

impl NewUmConditionalOrderTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Gtc => "GTC",
            Self::Ioc => "IOC",
            Self::Fok => "FOK",
            Self::Gtx => "GTX",
        }
    }
}

impl std::str::FromStr for NewUmConditionalOrderTimeInForceEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "GTC" => Ok(Self::Gtc),
            "IOC" => Ok(Self::Ioc),
            "FOK" => Ok(Self::Fok),
            "GTX" => Ok(Self::Gtx),
            other => Err(format!("invalid NewUmConditionalOrderTimeInForceEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewUmConditionalOrderWorkingTypeEnum {
    #[serde(rename = "MARK_PRICE")]
    MarkPrice,
}

impl NewUmConditionalOrderWorkingTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::MarkPrice => "MARK_PRICE",
        }
    }
}

impl std::str::FromStr for NewUmConditionalOrderWorkingTypeEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "MARK_PRICE" => Ok(Self::MarkPrice),
            other => Err(format!("invalid NewUmConditionalOrderWorkingTypeEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewUmConditionalOrderPriceMatchEnum {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "OPPONENT")]
    Opponent,
    #[serde(rename = "OPPONENT_5")]
    Opponent5,
    #[serde(rename = "OPPONENT_10")]
    Opponent10,
    #[serde(rename = "OPPONENT_20")]
    Opponent20,
    #[serde(rename = "QUEUE")]
    Queue,
    #[serde(rename = "QUEUE_5")]
    Queue5,
    #[serde(rename = "QUEUE_10")]
    Queue10,
    #[serde(rename = "QUEUE_20")]
    Queue20,
}

impl NewUmConditionalOrderPriceMatchEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::None => "NONE",
            Self::Opponent => "OPPONENT",
            Self::Opponent5 => "OPPONENT_5",
            Self::Opponent10 => "OPPONENT_10",
            Self::Opponent20 => "OPPONENT_20",
            Self::Queue => "QUEUE",
            Self::Queue5 => "QUEUE_5",
            Self::Queue10 => "QUEUE_10",
            Self::Queue20 => "QUEUE_20",
        }
    }
}

impl std::str::FromStr for NewUmConditionalOrderPriceMatchEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "NONE" => Ok(Self::None),
            "OPPONENT" => Ok(Self::Opponent),
            "OPPONENT_5" => Ok(Self::Opponent5),
            "OPPONENT_10" => Ok(Self::Opponent10),
            "OPPONENT_20" => Ok(Self::Opponent20),
            "QUEUE" => Ok(Self::Queue),
            "QUEUE_5" => Ok(Self::Queue5),
            "QUEUE_10" => Ok(Self::Queue10),
            "QUEUE_20" => Ok(Self::Queue20),
            other => Err(format!("invalid NewUmConditionalOrderPriceMatchEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewUmConditionalOrderSelfTradePreventionModeEnum {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "EXPIRE_TAKER")]
    ExpireTaker,
    #[serde(rename = "EXPIRE_BOTH")]
    ExpireBoth,
    #[serde(rename = "EXPIRE_MAKER")]
    ExpireMaker,
}

impl NewUmConditionalOrderSelfTradePreventionModeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::None => "NONE",
            Self::ExpireTaker => "EXPIRE_TAKER",
            Self::ExpireBoth => "EXPIRE_BOTH",
            Self::ExpireMaker => "EXPIRE_MAKER",
        }
    }
}

impl std::str::FromStr for NewUmConditionalOrderSelfTradePreventionModeEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "NONE" => Ok(Self::None),
            "EXPIRE_TAKER" => Ok(Self::ExpireTaker),
            "EXPIRE_BOTH" => Ok(Self::ExpireBoth),
            "EXPIRE_MAKER" => Ok(Self::ExpireMaker),
            other => Err(format!(
                "invalid NewUmConditionalOrderSelfTradePreventionModeEnum: {}",
                other
            )
            .into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewUmOrderSideEnum {
    #[serde(rename = "BUY")]
    Buy,
    #[serde(rename = "SELL")]
    Sell,
}

impl NewUmOrderSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Buy => "BUY",
            Self::Sell => "SELL",
        }
    }
}

impl std::str::FromStr for NewUmOrderSideEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "BUY" => Ok(Self::Buy),
            "SELL" => Ok(Self::Sell),
            other => Err(format!("invalid NewUmOrderSideEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewUmOrderTypeEnum {
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "MARKET")]
    Market,
}

impl NewUmOrderTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Limit => "LIMIT",
            Self::Market => "MARKET",
        }
    }
}

impl std::str::FromStr for NewUmOrderTypeEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "LIMIT" => Ok(Self::Limit),
            "MARKET" => Ok(Self::Market),
            other => Err(format!("invalid NewUmOrderTypeEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewUmOrderPositionSideEnum {
    #[serde(rename = "BOTH")]
    Both,
    #[serde(rename = "LONG")]
    Long,
    #[serde(rename = "SHORT")]
    Short,
}

impl NewUmOrderPositionSideEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Both => "BOTH",
            Self::Long => "LONG",
            Self::Short => "SHORT",
        }
    }
}

impl std::str::FromStr for NewUmOrderPositionSideEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "BOTH" => Ok(Self::Both),
            "LONG" => Ok(Self::Long),
            "SHORT" => Ok(Self::Short),
            other => Err(format!("invalid NewUmOrderPositionSideEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewUmOrderTimeInForceEnum {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "IOC")]
    Ioc,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "GTX")]
    Gtx,
}

impl NewUmOrderTimeInForceEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Gtc => "GTC",
            Self::Ioc => "IOC",
            Self::Fok => "FOK",
            Self::Gtx => "GTX",
        }
    }
}

impl std::str::FromStr for NewUmOrderTimeInForceEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "GTC" => Ok(Self::Gtc),
            "IOC" => Ok(Self::Ioc),
            "FOK" => Ok(Self::Fok),
            "GTX" => Ok(Self::Gtx),
            other => Err(format!("invalid NewUmOrderTimeInForceEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewUmOrderNewOrderRespTypeEnum {
    #[serde(rename = "ACK")]
    Ack,
    #[serde(rename = "RESULT")]
    Result,
}

impl NewUmOrderNewOrderRespTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Ack => "ACK",
            Self::Result => "RESULT",
        }
    }
}

impl std::str::FromStr for NewUmOrderNewOrderRespTypeEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "ACK" => Ok(Self::Ack),
            "RESULT" => Ok(Self::Result),
            other => Err(format!("invalid NewUmOrderNewOrderRespTypeEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewUmOrderPriceMatchEnum {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "OPPONENT")]
    Opponent,
    #[serde(rename = "OPPONENT_5")]
    Opponent5,
    #[serde(rename = "OPPONENT_10")]
    Opponent10,
    #[serde(rename = "OPPONENT_20")]
    Opponent20,
    #[serde(rename = "QUEUE")]
    Queue,
    #[serde(rename = "QUEUE_5")]
    Queue5,
    #[serde(rename = "QUEUE_10")]
    Queue10,
    #[serde(rename = "QUEUE_20")]
    Queue20,
}

impl NewUmOrderPriceMatchEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::None => "NONE",
            Self::Opponent => "OPPONENT",
            Self::Opponent5 => "OPPONENT_5",
            Self::Opponent10 => "OPPONENT_10",
            Self::Opponent20 => "OPPONENT_20",
            Self::Queue => "QUEUE",
            Self::Queue5 => "QUEUE_5",
            Self::Queue10 => "QUEUE_10",
            Self::Queue20 => "QUEUE_20",
        }
    }
}

impl std::str::FromStr for NewUmOrderPriceMatchEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "NONE" => Ok(Self::None),
            "OPPONENT" => Ok(Self::Opponent),
            "OPPONENT_5" => Ok(Self::Opponent5),
            "OPPONENT_10" => Ok(Self::Opponent10),
            "OPPONENT_20" => Ok(Self::Opponent20),
            "QUEUE" => Ok(Self::Queue),
            "QUEUE_5" => Ok(Self::Queue5),
            "QUEUE_10" => Ok(Self::Queue10),
            "QUEUE_20" => Ok(Self::Queue20),
            other => Err(format!("invalid NewUmOrderPriceMatchEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NewUmOrderSelfTradePreventionModeEnum {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "EXPIRE_TAKER")]
    ExpireTaker,
    #[serde(rename = "EXPIRE_BOTH")]
    ExpireBoth,
    #[serde(rename = "EXPIRE_MAKER")]
    ExpireMaker,
}

impl NewUmOrderSelfTradePreventionModeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::None => "NONE",
            Self::ExpireTaker => "EXPIRE_TAKER",
            Self::ExpireBoth => "EXPIRE_BOTH",
            Self::ExpireMaker => "EXPIRE_MAKER",
        }
    }
}

impl std::str::FromStr for NewUmOrderSelfTradePreventionModeEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "NONE" => Ok(Self::None),
            "EXPIRE_TAKER" => Ok(Self::ExpireTaker),
            "EXPIRE_BOTH" => Ok(Self::ExpireBoth),
            "EXPIRE_MAKER" => Ok(Self::ExpireMaker),
            other => {
                Err(format!("invalid NewUmOrderSelfTradePreventionModeEnum: {}", other).into())
            }
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum QueryUsersCmForceOrdersAutoCloseTypeEnum {
    #[serde(rename = "LIQUIDATION")]
    Liquidation,
    #[serde(rename = "ADL")]
    Adl,
}

impl QueryUsersCmForceOrdersAutoCloseTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Liquidation => "LIQUIDATION",
            Self::Adl => "ADL",
        }
    }
}

impl std::str::FromStr for QueryUsersCmForceOrdersAutoCloseTypeEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "LIQUIDATION" => Ok(Self::Liquidation),
            "ADL" => Ok(Self::Adl),
            other => Err(format!(
                "invalid QueryUsersCmForceOrdersAutoCloseTypeEnum: {}",
                other
            )
            .into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum QueryUsersUmForceOrdersAutoCloseTypeEnum {
    #[serde(rename = "LIQUIDATION")]
    Liquidation,
    #[serde(rename = "ADL")]
    Adl,
}

impl QueryUsersUmForceOrdersAutoCloseTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Liquidation => "LIQUIDATION",
            Self::Adl => "ADL",
        }
    }
}

impl std::str::FromStr for QueryUsersUmForceOrdersAutoCloseTypeEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "LIQUIDATION" => Ok(Self::Liquidation),
            "ADL" => Ok(Self::Adl),
            other => Err(format!(
                "invalid QueryUsersUmForceOrdersAutoCloseTypeEnum: {}",
                other
            )
            .into()),
        }
    }
}

/// Request parameters for the [`cancel_all_cm_open_conditional_orders`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`cancel_all_cm_open_conditional_orders`](#method.cancel_all_cm_open_conditional_orders).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct CancelAllCmOpenConditionalOrdersParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl CancelAllCmOpenConditionalOrdersParams {
    /// Create a builder for [`cancel_all_cm_open_conditional_orders`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> CancelAllCmOpenConditionalOrdersParamsBuilder {
        CancelAllCmOpenConditionalOrdersParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`cancel_all_cm_open_orders`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`cancel_all_cm_open_orders`](#method.cancel_all_cm_open_orders).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct CancelAllCmOpenOrdersParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl CancelAllCmOpenOrdersParams {
    /// Create a builder for [`cancel_all_cm_open_orders`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> CancelAllCmOpenOrdersParamsBuilder {
        CancelAllCmOpenOrdersParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`cancel_all_um_open_conditional_orders`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`cancel_all_um_open_conditional_orders`](#method.cancel_all_um_open_conditional_orders).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct CancelAllUmOpenConditionalOrdersParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl CancelAllUmOpenConditionalOrdersParams {
    /// Create a builder for [`cancel_all_um_open_conditional_orders`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> CancelAllUmOpenConditionalOrdersParamsBuilder {
        CancelAllUmOpenConditionalOrdersParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`cancel_all_um_open_orders`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`cancel_all_um_open_orders`](#method.cancel_all_um_open_orders).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct CancelAllUmOpenOrdersParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl CancelAllUmOpenOrdersParams {
    /// Create a builder for [`cancel_all_um_open_orders`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> CancelAllUmOpenOrdersParamsBuilder {
        CancelAllUmOpenOrdersParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`cancel_cm_conditional_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`cancel_cm_conditional_order`](#method.cancel_cm_conditional_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct CancelCmConditionalOrderParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `strategy_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub strategy_id: Option<i64>,
    ///
    /// The `new_client_strategy_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_strategy_id: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl CancelCmConditionalOrderParams {
    /// Create a builder for [`cancel_cm_conditional_order`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> CancelCmConditionalOrderParamsBuilder {
        CancelCmConditionalOrderParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`cancel_cm_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`cancel_cm_order`](#method.cancel_cm_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct CancelCmOrderParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_id: Option<i64>,
    ///
    /// The `orig_client_order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub orig_client_order_id: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl CancelCmOrderParams {
    /// Create a builder for [`cancel_cm_order`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> CancelCmOrderParamsBuilder {
        CancelCmOrderParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`cancel_margin_account_all_open_orders_on_a_symbol`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`cancel_margin_account_all_open_orders_on_a_symbol`](#method.cancel_margin_account_all_open_orders_on_a_symbol).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct CancelMarginAccountAllOpenOrdersOnASymbolParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl CancelMarginAccountAllOpenOrdersOnASymbolParams {
    /// Create a builder for [`cancel_margin_account_all_open_orders_on_a_symbol`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> CancelMarginAccountAllOpenOrdersOnASymbolParamsBuilder {
        CancelMarginAccountAllOpenOrdersOnASymbolParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`cancel_margin_account_oco_orders`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`cancel_margin_account_oco_orders`](#method.cancel_margin_account_oco_orders).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct CancelMarginAccountOcoOrdersParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// Either `orderListId` or `listClientOrderId` must be provided
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_list_id: Option<i64>,
    /// Either `orderListId` or `listClientOrderId` must be provided
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub list_client_order_id: Option<String>,
    /// Used to uniquely identify this cancel. Automatically generated by default
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_order_id: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl CancelMarginAccountOcoOrdersParams {
    /// Create a builder for [`cancel_margin_account_oco_orders`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> CancelMarginAccountOcoOrdersParamsBuilder {
        CancelMarginAccountOcoOrdersParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`cancel_margin_account_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`cancel_margin_account_order`](#method.cancel_margin_account_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct CancelMarginAccountOrderParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_id: Option<i64>,
    ///
    /// The `orig_client_order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub orig_client_order_id: Option<String>,
    /// Used to uniquely identify this cancel. Automatically generated by default
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_order_id: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl CancelMarginAccountOrderParams {
    /// Create a builder for [`cancel_margin_account_order`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> CancelMarginAccountOrderParamsBuilder {
        CancelMarginAccountOrderParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`cancel_um_conditional_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`cancel_um_conditional_order`](#method.cancel_um_conditional_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct CancelUmConditionalOrderParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `strategy_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub strategy_id: Option<i64>,
    ///
    /// The `new_client_strategy_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_strategy_id: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl CancelUmConditionalOrderParams {
    /// Create a builder for [`cancel_um_conditional_order`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> CancelUmConditionalOrderParamsBuilder {
        CancelUmConditionalOrderParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`cancel_um_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`cancel_um_order`](#method.cancel_um_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct CancelUmOrderParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_id: Option<i64>,
    ///
    /// The `orig_client_order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub orig_client_order_id: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl CancelUmOrderParams {
    /// Create a builder for [`cancel_um_order`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> CancelUmOrderParamsBuilder {
        CancelUmOrderParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`cm_account_trade_list`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`cm_account_trade_list`](#method.cm_account_trade_list).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct CmAccountTradeListParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    ///
    /// The `pair` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pair: Option<String>,
    /// Timestamp in ms to get funding from INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    /// Timestamp in ms to get funding until INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Trade id to fetch from. Default gets most recent trades.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub from_id: Option<i64>,
    /// Default 100; max 1000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl CmAccountTradeListParams {
    /// Create a builder for [`cm_account_trade_list`].
    ///
    #[must_use]
    pub fn builder() -> CmAccountTradeListParamsBuilder {
        CmAccountTradeListParamsBuilder::default()
    }
}
/// Request parameters for the [`cm_position_adl_quantile_estimation`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`cm_position_adl_quantile_estimation`](#method.cm_position_adl_quantile_estimation).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct CmPositionAdlQuantileEstimationParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl CmPositionAdlQuantileEstimationParams {
    /// Create a builder for [`cm_position_adl_quantile_estimation`].
    ///
    #[must_use]
    pub fn builder() -> CmPositionAdlQuantileEstimationParamsBuilder {
        CmPositionAdlQuantileEstimationParamsBuilder::default()
    }
}
/// Request parameters for the [`get_um_futures_bnb_burn_status`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_um_futures_bnb_burn_status`](#method.get_um_futures_bnb_burn_status).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetUmFuturesBnbBurnStatusParams {
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl GetUmFuturesBnbBurnStatusParams {
    /// Create a builder for [`get_um_futures_bnb_burn_status`].
    ///
    #[must_use]
    pub fn builder() -> GetUmFuturesBnbBurnStatusParamsBuilder {
        GetUmFuturesBnbBurnStatusParamsBuilder::default()
    }
}
/// Request parameters for the [`margin_account_borrow`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`margin_account_borrow`](#method.margin_account_borrow).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct MarginAccountBorrowParams {
    ///
    /// The `asset` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub asset: String,
    ///
    /// The `amount` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub amount: rust_decimal::Decimal,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl MarginAccountBorrowParams {
    /// Create a builder for [`margin_account_borrow`].
    ///
    /// Required parameters:
    ///
    /// * `asset` — String
    /// * `amount` — `rust_decimal::Decimal`
    ///
    #[must_use]
    pub fn builder(
        asset: String,
        amount: rust_decimal::Decimal,
    ) -> MarginAccountBorrowParamsBuilder {
        MarginAccountBorrowParamsBuilder::default()
            .asset(asset)
            .amount(amount)
    }
}
/// Request parameters for the [`margin_account_new_oco`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`margin_account_new_oco`](#method.margin_account_new_oco).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct MarginAccountNewOcoParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub side: MarginAccountNewOcoSideEnum,
    /// Order quantity
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub quantity: rust_decimal::Decimal,
    ///
    /// The `price` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub price: rust_decimal::Decimal,
    ///
    /// The `stop_price` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub stop_price: rust_decimal::Decimal,
    /// Either `orderListId` or `listClientOrderId` must be provided
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub list_client_order_id: Option<String>,
    /// A unique Id for the limit order
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit_client_order_id: Option<String>,
    ///
    /// The `limit_iceberg_qty` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit_iceberg_qty: Option<rust_decimal::Decimal>,
    /// A unique Id for the stop loss/stop loss limit leg
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub stop_client_order_id: Option<String>,
    /// If provided, stopLimitTimeInForce is required.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub stop_limit_price: Option<rust_decimal::Decimal>,
    ///
    /// The `stop_iceberg_qty` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub stop_iceberg_qty: Option<rust_decimal::Decimal>,
    /// Valid values are `GTC/FOK/IOC`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub stop_limit_time_in_force: Option<MarginAccountNewOcoStopLimitTimeInForceEnum>,
    /// "ACK", "RESULT", default "ACK"
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_order_resp_type: Option<MarginAccountNewOcoNewOrderRespTypeEnum>,
    /// `NO_SIDE_EFFECT`, `MARGIN_BUY`, `AUTO_REPAY`; default `NO_SIDE_EFFECT`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub side_effect_type: Option<MarginAccountNewOcoSideEffectTypeEnum>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl MarginAccountNewOcoParams {
    /// Create a builder for [`margin_account_new_oco`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `side` — String
    /// * `quantity` — Order quantity
    /// * `price` — `rust_decimal::Decimal`
    /// * `stop_price` — `rust_decimal::Decimal`
    ///
    #[must_use]
    pub fn builder(
        symbol: String,
        side: MarginAccountNewOcoSideEnum,
        quantity: rust_decimal::Decimal,
        price: rust_decimal::Decimal,
        stop_price: rust_decimal::Decimal,
    ) -> MarginAccountNewOcoParamsBuilder {
        MarginAccountNewOcoParamsBuilder::default()
            .symbol(symbol)
            .side(side)
            .quantity(quantity)
            .price(price)
            .stop_price(stop_price)
    }
}
/// Request parameters for the [`margin_account_repay`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`margin_account_repay`](#method.margin_account_repay).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct MarginAccountRepayParams {
    ///
    /// The `asset` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub asset: String,
    ///
    /// The `amount` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub amount: rust_decimal::Decimal,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl MarginAccountRepayParams {
    /// Create a builder for [`margin_account_repay`].
    ///
    /// Required parameters:
    ///
    /// * `asset` — String
    /// * `amount` — `rust_decimal::Decimal`
    ///
    #[must_use]
    pub fn builder(
        asset: String,
        amount: rust_decimal::Decimal,
    ) -> MarginAccountRepayParamsBuilder {
        MarginAccountRepayParamsBuilder::default()
            .asset(asset)
            .amount(amount)
    }
}
/// Request parameters for the [`margin_account_repay_debt`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`margin_account_repay_debt`](#method.margin_account_repay_debt).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct MarginAccountRepayDebtParams {
    ///
    /// The `asset` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub asset: String,
    ///
    /// The `amount` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub amount: Option<String>,
    /// Specific asset list to repay debt; Can be added in batch, separated by commas
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub specify_repay_assets: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl MarginAccountRepayDebtParams {
    /// Create a builder for [`margin_account_repay_debt`].
    ///
    /// Required parameters:
    ///
    /// * `asset` — String
    ///
    #[must_use]
    pub fn builder(asset: String) -> MarginAccountRepayDebtParamsBuilder {
        MarginAccountRepayDebtParamsBuilder::default().asset(asset)
    }
}
/// Request parameters for the [`margin_account_trade_list`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`margin_account_trade_list`](#method.margin_account_trade_list).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct MarginAccountTradeListParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_id: Option<i64>,
    /// Timestamp in ms to get funding from INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    /// Timestamp in ms to get funding until INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Trade id to fetch from. Default gets most recent trades.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub from_id: Option<i64>,
    /// Default 100; max 1000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl MarginAccountTradeListParams {
    /// Create a builder for [`margin_account_trade_list`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> MarginAccountTradeListParamsBuilder {
        MarginAccountTradeListParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`modify_cm_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`modify_cm_order`](#method.modify_cm_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct ModifyCmOrderParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub side: ModifyCmOrderSideEnum,
    /// Order quantity
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub quantity: rust_decimal::Decimal,
    ///
    /// The `price` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub price: rust_decimal::Decimal,
    ///
    /// The `order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_id: Option<i64>,
    ///
    /// The `orig_client_order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub orig_client_order_id: Option<String>,
    /// only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub price_match: Option<ModifyCmOrderPriceMatchEnum>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl ModifyCmOrderParams {
    /// Create a builder for [`modify_cm_order`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `side` — String
    /// * `quantity` — Order quantity
    /// * `price` — `rust_decimal::Decimal`
    ///
    #[must_use]
    pub fn builder(
        symbol: String,
        side: ModifyCmOrderSideEnum,
        quantity: rust_decimal::Decimal,
        price: rust_decimal::Decimal,
    ) -> ModifyCmOrderParamsBuilder {
        ModifyCmOrderParamsBuilder::default()
            .symbol(symbol)
            .side(side)
            .quantity(quantity)
            .price(price)
    }
}
/// Request parameters for the [`modify_um_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`modify_um_order`](#method.modify_um_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct ModifyUmOrderParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub side: ModifyUmOrderSideEnum,
    /// Order quantity
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub quantity: rust_decimal::Decimal,
    ///
    /// The `price` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub price: rust_decimal::Decimal,
    ///
    /// The `order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_id: Option<i64>,
    ///
    /// The `orig_client_order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub orig_client_order_id: Option<String>,
    /// only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub price_match: Option<ModifyUmOrderPriceMatchEnum>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl ModifyUmOrderParams {
    /// Create a builder for [`modify_um_order`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `side` — String
    /// * `quantity` — Order quantity
    /// * `price` — `rust_decimal::Decimal`
    ///
    #[must_use]
    pub fn builder(
        symbol: String,
        side: ModifyUmOrderSideEnum,
        quantity: rust_decimal::Decimal,
        price: rust_decimal::Decimal,
    ) -> ModifyUmOrderParamsBuilder {
        ModifyUmOrderParamsBuilder::default()
            .symbol(symbol)
            .side(side)
            .quantity(quantity)
            .price(price)
    }
}
/// Request parameters for the [`new_cm_conditional_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`new_cm_conditional_order`](#method.new_cm_conditional_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct NewCmConditionalOrderParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub side: NewCmConditionalOrderSideEnum,
    /// "STOP", "`STOP_MARKET`", "`TAKE_PROFIT`", "`TAKE_PROFIT_MARKET`", and "`TRAILING_STOP_MARKET`"
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub strategy_type: NewCmConditionalOrderStrategyTypeEnum,
    /// Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent in Hedge Mode.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub position_side: Option<NewCmConditionalOrderPositionSideEnum>,
    ///
    /// The `time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub time_in_force: Option<NewCmConditionalOrderTimeInForceEnum>,
    ///
    /// The `quantity` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub quantity: Option<rust_decimal::Decimal>,
    /// "true" or "false". default "false". Cannot be sent in Hedge Mode .
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub reduce_only: Option<String>,
    ///
    /// The `price` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub price: Option<rust_decimal::Decimal>,
    /// stopPrice triggered by: "`MARK_PRICE`", "`CONTRACT_PRICE`". Default "`CONTRACT_PRICE`"
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub working_type: Option<NewCmConditionalOrderWorkingTypeEnum>,
    /// "TRUE" or "FALSE", default "FALSE". Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub price_protect: Option<String>,
    ///
    /// The `new_client_strategy_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_strategy_id: Option<String>,
    /// Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub stop_price: Option<rust_decimal::Decimal>,
    /// Used with `TRAILING_STOP_MARKET` orders, default as the mark price
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub activation_price: Option<rust_decimal::Decimal>,
    /// Used with `TRAILING_STOP_MARKET` orders, min 0.1, max 5 where 1 for 1%
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub callback_rate: Option<rust_decimal::Decimal>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl NewCmConditionalOrderParams {
    /// Create a builder for [`new_cm_conditional_order`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `side` — String
    /// * `strategy_type` — \"STOP\", \"`STOP_MARKET`\", \"`TAKE_PROFIT`\", \"`TAKE_PROFIT_MARKET`\", and \"`TRAILING_STOP_MARKET`\"
    ///
    #[must_use]
    pub fn builder(
        symbol: String,
        side: NewCmConditionalOrderSideEnum,
        strategy_type: NewCmConditionalOrderStrategyTypeEnum,
    ) -> NewCmConditionalOrderParamsBuilder {
        NewCmConditionalOrderParamsBuilder::default()
            .symbol(symbol)
            .side(side)
            .strategy_type(strategy_type)
    }
}
/// Request parameters for the [`new_cm_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`new_cm_order`](#method.new_cm_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct NewCmOrderParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub side: NewCmOrderSideEnum,
    /// `LIMIT`, `MARKET`
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub r#type: NewCmOrderTypeEnum,
    /// Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent in Hedge Mode.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub position_side: Option<NewCmOrderPositionSideEnum>,
    ///
    /// The `time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub time_in_force: Option<NewCmOrderTimeInForceEnum>,
    ///
    /// The `quantity` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub quantity: Option<rust_decimal::Decimal>,
    /// "true" or "false". default "false". Cannot be sent in Hedge Mode .
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub reduce_only: Option<String>,
    ///
    /// The `price` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub price: Option<rust_decimal::Decimal>,
    /// only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub price_match: Option<NewCmOrderPriceMatchEnum>,
    /// Used to uniquely identify this cancel. Automatically generated by default
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_order_id: Option<String>,
    /// "ACK", "RESULT", default "ACK"
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_order_resp_type: Option<NewCmOrderNewOrderRespTypeEnum>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl NewCmOrderParams {
    /// Create a builder for [`new_cm_order`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `side` — String
    /// * `r#type` — `LIMIT`, `MARKET`
    ///
    #[must_use]
    pub fn builder(
        symbol: String,
        side: NewCmOrderSideEnum,
        r#type: NewCmOrderTypeEnum,
    ) -> NewCmOrderParamsBuilder {
        NewCmOrderParamsBuilder::default()
            .symbol(symbol)
            .side(side)
            .r#type(r#type)
    }
}
/// Request parameters for the [`new_margin_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`new_margin_order`](#method.new_margin_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct NewMarginOrderParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub side: NewMarginOrderSideEnum,
    /// `LIMIT`, `MARKET`
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub r#type: NewMarginOrderTypeEnum,
    ///
    /// The `quantity` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub quantity: Option<rust_decimal::Decimal>,
    ///
    /// The `quote_order_qty` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub quote_order_qty: Option<rust_decimal::Decimal>,
    ///
    /// The `price` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub price: Option<rust_decimal::Decimal>,
    /// Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub stop_price: Option<rust_decimal::Decimal>,
    /// Used to uniquely identify this cancel. Automatically generated by default
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_order_id: Option<String>,
    /// "ACK", "RESULT", default "ACK"
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_order_resp_type: Option<NewMarginOrderNewOrderRespTypeEnum>,
    /// Used with `LIMIT`, `STOP_LOSS_LIMIT`, and `TAKE_PROFIT_LIMIT` to create an iceberg order
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub iceberg_qty: Option<rust_decimal::Decimal>,
    /// `NO_SIDE_EFFECT`, `MARGIN_BUY`, `AUTO_REPAY`; default `NO_SIDE_EFFECT`.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub side_effect_type: Option<NewMarginOrderSideEffectTypeEnum>,
    ///
    /// The `time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub time_in_force: Option<NewMarginOrderTimeInForceEnum>,
    /// `NONE`:No STP / `EXPIRE_TAKER`:expire taker order when STP triggers/ `EXPIRE_MAKER`:expire taker order when STP triggers/ `EXPIRE_BOTH`:expire both orders when STP triggers
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub self_trade_prevention_mode: Option<NewMarginOrderSelfTradePreventionModeEnum>,
    /// 只有在自动借款单或者自动借还单生效，true表示的是撤单后需要把订单产生的借款归还，默认为true
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub auto_repay_at_cancel: Option<bool>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl NewMarginOrderParams {
    /// Create a builder for [`new_margin_order`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `side` — String
    /// * `r#type` — `LIMIT`, `MARKET`
    ///
    #[must_use]
    pub fn builder(
        symbol: String,
        side: NewMarginOrderSideEnum,
        r#type: NewMarginOrderTypeEnum,
    ) -> NewMarginOrderParamsBuilder {
        NewMarginOrderParamsBuilder::default()
            .symbol(symbol)
            .side(side)
            .r#type(r#type)
    }
}
/// Request parameters for the [`new_um_conditional_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`new_um_conditional_order`](#method.new_um_conditional_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct NewUmConditionalOrderParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub side: NewUmConditionalOrderSideEnum,
    /// "STOP", "`STOP_MARKET`", "`TAKE_PROFIT`", "`TAKE_PROFIT_MARKET`", and "`TRAILING_STOP_MARKET`"
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub strategy_type: NewUmConditionalOrderStrategyTypeEnum,
    /// Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent in Hedge Mode.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub position_side: Option<NewUmConditionalOrderPositionSideEnum>,
    ///
    /// The `time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub time_in_force: Option<NewUmConditionalOrderTimeInForceEnum>,
    ///
    /// The `quantity` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub quantity: Option<rust_decimal::Decimal>,
    /// "true" or "false". default "false". Cannot be sent in Hedge Mode .
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub reduce_only: Option<String>,
    ///
    /// The `price` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub price: Option<rust_decimal::Decimal>,
    /// stopPrice triggered by: "`MARK_PRICE`", "`CONTRACT_PRICE`". Default "`CONTRACT_PRICE`"
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub working_type: Option<NewUmConditionalOrderWorkingTypeEnum>,
    /// "TRUE" or "FALSE", default "FALSE". Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub price_protect: Option<String>,
    ///
    /// The `new_client_strategy_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_strategy_id: Option<String>,
    /// Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub stop_price: Option<rust_decimal::Decimal>,
    /// Used with `TRAILING_STOP_MARKET` orders, default as the mark price
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub activation_price: Option<rust_decimal::Decimal>,
    /// Used with `TRAILING_STOP_MARKET` orders, min 0.1, max 5 where 1 for 1%
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub callback_rate: Option<rust_decimal::Decimal>,
    /// only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub price_match: Option<NewUmConditionalOrderPriceMatchEnum>,
    /// `NONE`:No STP / `EXPIRE_TAKER`:expire taker order when STP triggers/ `EXPIRE_MAKER`:expire taker order when STP triggers/ `EXPIRE_BOTH`:expire both orders when STP triggers
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub self_trade_prevention_mode: Option<NewUmConditionalOrderSelfTradePreventionModeEnum>,
    /// order cancel time for timeInForce `GTD`, mandatory when `timeInforce` set to `GTD`; order the timestamp only retains second-level precision, ms part will be ignored; The goodTillDate timestamp must be greater than the current time plus 600 seconds and smaller than 253402300799000Mode. It must be sent in Hedge Mode.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub good_till_date: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl NewUmConditionalOrderParams {
    /// Create a builder for [`new_um_conditional_order`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `side` — String
    /// * `strategy_type` — \"STOP\", \"`STOP_MARKET`\", \"`TAKE_PROFIT`\", \"`TAKE_PROFIT_MARKET`\", and \"`TRAILING_STOP_MARKET`\"
    ///
    #[must_use]
    pub fn builder(
        symbol: String,
        side: NewUmConditionalOrderSideEnum,
        strategy_type: NewUmConditionalOrderStrategyTypeEnum,
    ) -> NewUmConditionalOrderParamsBuilder {
        NewUmConditionalOrderParamsBuilder::default()
            .symbol(symbol)
            .side(side)
            .strategy_type(strategy_type)
    }
}
/// Request parameters for the [`new_um_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`new_um_order`](#method.new_um_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct NewUmOrderParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `side` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub side: NewUmOrderSideEnum,
    /// `LIMIT`, `MARKET`
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub r#type: NewUmOrderTypeEnum,
    /// Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent in Hedge Mode.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub position_side: Option<NewUmOrderPositionSideEnum>,
    ///
    /// The `time_in_force` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub time_in_force: Option<NewUmOrderTimeInForceEnum>,
    ///
    /// The `quantity` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub quantity: Option<rust_decimal::Decimal>,
    /// "true" or "false". default "false". Cannot be sent in Hedge Mode .
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub reduce_only: Option<String>,
    ///
    /// The `price` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub price: Option<rust_decimal::Decimal>,
    /// Used to uniquely identify this cancel. Automatically generated by default
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_order_id: Option<String>,
    /// "ACK", "RESULT", default "ACK"
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_order_resp_type: Option<NewUmOrderNewOrderRespTypeEnum>,
    /// only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub price_match: Option<NewUmOrderPriceMatchEnum>,
    /// `NONE`:No STP / `EXPIRE_TAKER`:expire taker order when STP triggers/ `EXPIRE_MAKER`:expire taker order when STP triggers/ `EXPIRE_BOTH`:expire both orders when STP triggers
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub self_trade_prevention_mode: Option<NewUmOrderSelfTradePreventionModeEnum>,
    /// order cancel time for timeInForce `GTD`, mandatory when `timeInforce` set to `GTD`; order the timestamp only retains second-level precision, ms part will be ignored; The goodTillDate timestamp must be greater than the current time plus 600 seconds and smaller than 253402300799000Mode. It must be sent in Hedge Mode.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub good_till_date: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl NewUmOrderParams {
    /// Create a builder for [`new_um_order`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `side` — String
    /// * `r#type` — `LIMIT`, `MARKET`
    ///
    #[must_use]
    pub fn builder(
        symbol: String,
        side: NewUmOrderSideEnum,
        r#type: NewUmOrderTypeEnum,
    ) -> NewUmOrderParamsBuilder {
        NewUmOrderParamsBuilder::default()
            .symbol(symbol)
            .side(side)
            .r#type(r#type)
    }
}
/// Request parameters for the [`query_all_cm_conditional_orders`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_all_cm_conditional_orders`](#method.query_all_cm_conditional_orders).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryAllCmConditionalOrdersParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    ///
    /// The `strategy_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub strategy_id: Option<i64>,
    /// Timestamp in ms to get funding from INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    /// Timestamp in ms to get funding until INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Default 100; max 1000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryAllCmConditionalOrdersParams {
    /// Create a builder for [`query_all_cm_conditional_orders`].
    ///
    #[must_use]
    pub fn builder() -> QueryAllCmConditionalOrdersParamsBuilder {
        QueryAllCmConditionalOrdersParamsBuilder::default()
    }
}
/// Request parameters for the [`query_all_cm_orders`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_all_cm_orders`](#method.query_all_cm_orders).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryAllCmOrdersParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `pair` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pair: Option<String>,
    ///
    /// The `order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_id: Option<i64>,
    /// Timestamp in ms to get funding from INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    /// Timestamp in ms to get funding until INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Default 100; max 1000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryAllCmOrdersParams {
    /// Create a builder for [`query_all_cm_orders`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> QueryAllCmOrdersParamsBuilder {
        QueryAllCmOrdersParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`query_all_current_cm_open_conditional_orders`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_all_current_cm_open_conditional_orders`](#method.query_all_current_cm_open_conditional_orders).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryAllCurrentCmOpenConditionalOrdersParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryAllCurrentCmOpenConditionalOrdersParams {
    /// Create a builder for [`query_all_current_cm_open_conditional_orders`].
    ///
    #[must_use]
    pub fn builder() -> QueryAllCurrentCmOpenConditionalOrdersParamsBuilder {
        QueryAllCurrentCmOpenConditionalOrdersParamsBuilder::default()
    }
}
/// Request parameters for the [`query_all_current_cm_open_orders`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_all_current_cm_open_orders`](#method.query_all_current_cm_open_orders).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryAllCurrentCmOpenOrdersParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    ///
    /// The `pair` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub pair: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryAllCurrentCmOpenOrdersParams {
    /// Create a builder for [`query_all_current_cm_open_orders`].
    ///
    #[must_use]
    pub fn builder() -> QueryAllCurrentCmOpenOrdersParamsBuilder {
        QueryAllCurrentCmOpenOrdersParamsBuilder::default()
    }
}
/// Request parameters for the [`query_all_current_um_open_conditional_orders`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_all_current_um_open_conditional_orders`](#method.query_all_current_um_open_conditional_orders).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryAllCurrentUmOpenConditionalOrdersParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryAllCurrentUmOpenConditionalOrdersParams {
    /// Create a builder for [`query_all_current_um_open_conditional_orders`].
    ///
    #[must_use]
    pub fn builder() -> QueryAllCurrentUmOpenConditionalOrdersParamsBuilder {
        QueryAllCurrentUmOpenConditionalOrdersParamsBuilder::default()
    }
}
/// Request parameters for the [`query_all_current_um_open_orders`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_all_current_um_open_orders`](#method.query_all_current_um_open_orders).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryAllCurrentUmOpenOrdersParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryAllCurrentUmOpenOrdersParams {
    /// Create a builder for [`query_all_current_um_open_orders`].
    ///
    #[must_use]
    pub fn builder() -> QueryAllCurrentUmOpenOrdersParamsBuilder {
        QueryAllCurrentUmOpenOrdersParamsBuilder::default()
    }
}
/// Request parameters for the [`query_all_margin_account_orders`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_all_margin_account_orders`](#method.query_all_margin_account_orders).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryAllMarginAccountOrdersParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_id: Option<i64>,
    /// Timestamp in ms to get funding from INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    /// Timestamp in ms to get funding until INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Default 100; max 1000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryAllMarginAccountOrdersParams {
    /// Create a builder for [`query_all_margin_account_orders`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> QueryAllMarginAccountOrdersParamsBuilder {
        QueryAllMarginAccountOrdersParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`query_all_um_conditional_orders`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_all_um_conditional_orders`](#method.query_all_um_conditional_orders).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryAllUmConditionalOrdersParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    ///
    /// The `strategy_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub strategy_id: Option<i64>,
    /// Timestamp in ms to get funding from INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    /// Timestamp in ms to get funding until INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Default 100; max 1000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryAllUmConditionalOrdersParams {
    /// Create a builder for [`query_all_um_conditional_orders`].
    ///
    #[must_use]
    pub fn builder() -> QueryAllUmConditionalOrdersParamsBuilder {
        QueryAllUmConditionalOrdersParamsBuilder::default()
    }
}
/// Request parameters for the [`query_all_um_orders`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_all_um_orders`](#method.query_all_um_orders).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryAllUmOrdersParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_id: Option<i64>,
    /// Timestamp in ms to get funding from INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    /// Timestamp in ms to get funding until INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Default 100; max 1000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryAllUmOrdersParams {
    /// Create a builder for [`query_all_um_orders`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> QueryAllUmOrdersParamsBuilder {
        QueryAllUmOrdersParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`query_cm_conditional_order_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_cm_conditional_order_history`](#method.query_cm_conditional_order_history).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryCmConditionalOrderHistoryParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `strategy_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub strategy_id: Option<i64>,
    ///
    /// The `new_client_strategy_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_strategy_id: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryCmConditionalOrderHistoryParams {
    /// Create a builder for [`query_cm_conditional_order_history`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> QueryCmConditionalOrderHistoryParamsBuilder {
        QueryCmConditionalOrderHistoryParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`query_cm_modify_order_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_cm_modify_order_history`](#method.query_cm_modify_order_history).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryCmModifyOrderHistoryParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_id: Option<i64>,
    ///
    /// The `orig_client_order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub orig_client_order_id: Option<String>,
    /// Timestamp in ms to get funding from INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    /// Timestamp in ms to get funding until INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Default 100; max 1000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryCmModifyOrderHistoryParams {
    /// Create a builder for [`query_cm_modify_order_history`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> QueryCmModifyOrderHistoryParamsBuilder {
        QueryCmModifyOrderHistoryParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`query_cm_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_cm_order`](#method.query_cm_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryCmOrderParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_id: Option<i64>,
    ///
    /// The `orig_client_order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub orig_client_order_id: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryCmOrderParams {
    /// Create a builder for [`query_cm_order`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> QueryCmOrderParamsBuilder {
        QueryCmOrderParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`query_current_cm_open_conditional_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_current_cm_open_conditional_order`](#method.query_current_cm_open_conditional_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryCurrentCmOpenConditionalOrderParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `strategy_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub strategy_id: Option<i64>,
    ///
    /// The `new_client_strategy_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_strategy_id: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryCurrentCmOpenConditionalOrderParams {
    /// Create a builder for [`query_current_cm_open_conditional_order`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> QueryCurrentCmOpenConditionalOrderParamsBuilder {
        QueryCurrentCmOpenConditionalOrderParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`query_current_cm_open_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_current_cm_open_order`](#method.query_current_cm_open_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryCurrentCmOpenOrderParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_id: Option<i64>,
    ///
    /// The `orig_client_order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub orig_client_order_id: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryCurrentCmOpenOrderParams {
    /// Create a builder for [`query_current_cm_open_order`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> QueryCurrentCmOpenOrderParamsBuilder {
        QueryCurrentCmOpenOrderParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`query_current_margin_open_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_current_margin_open_order`](#method.query_current_margin_open_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryCurrentMarginOpenOrderParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryCurrentMarginOpenOrderParams {
    /// Create a builder for [`query_current_margin_open_order`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> QueryCurrentMarginOpenOrderParamsBuilder {
        QueryCurrentMarginOpenOrderParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`query_current_um_open_conditional_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_current_um_open_conditional_order`](#method.query_current_um_open_conditional_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryCurrentUmOpenConditionalOrderParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `strategy_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub strategy_id: Option<i64>,
    ///
    /// The `new_client_strategy_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_strategy_id: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryCurrentUmOpenConditionalOrderParams {
    /// Create a builder for [`query_current_um_open_conditional_order`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> QueryCurrentUmOpenConditionalOrderParamsBuilder {
        QueryCurrentUmOpenConditionalOrderParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`query_current_um_open_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_current_um_open_order`](#method.query_current_um_open_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryCurrentUmOpenOrderParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_id: Option<i64>,
    ///
    /// The `orig_client_order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub orig_client_order_id: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryCurrentUmOpenOrderParams {
    /// Create a builder for [`query_current_um_open_order`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> QueryCurrentUmOpenOrderParamsBuilder {
        QueryCurrentUmOpenOrderParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`query_margin_account_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_margin_account_order`](#method.query_margin_account_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryMarginAccountOrderParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_id: Option<i64>,
    ///
    /// The `orig_client_order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub orig_client_order_id: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryMarginAccountOrderParams {
    /// Create a builder for [`query_margin_account_order`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> QueryMarginAccountOrderParamsBuilder {
        QueryMarginAccountOrderParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`query_margin_accounts_all_oco`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_margin_accounts_all_oco`](#method.query_margin_accounts_all_oco).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryMarginAccountsAllOcoParams {
    /// Trade id to fetch from. Default gets most recent trades.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub from_id: Option<i64>,
    /// Timestamp in ms to get funding from INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    /// Timestamp in ms to get funding until INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Default 100; max 1000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryMarginAccountsAllOcoParams {
    /// Create a builder for [`query_margin_accounts_all_oco`].
    ///
    #[must_use]
    pub fn builder() -> QueryMarginAccountsAllOcoParamsBuilder {
        QueryMarginAccountsAllOcoParamsBuilder::default()
    }
}
/// Request parameters for the [`query_margin_accounts_oco`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_margin_accounts_oco`](#method.query_margin_accounts_oco).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryMarginAccountsOcoParams {
    /// Either `orderListId` or `listClientOrderId` must be provided
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_list_id: Option<i64>,
    ///
    /// The `orig_client_order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub orig_client_order_id: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryMarginAccountsOcoParams {
    /// Create a builder for [`query_margin_accounts_oco`].
    ///
    #[must_use]
    pub fn builder() -> QueryMarginAccountsOcoParamsBuilder {
        QueryMarginAccountsOcoParamsBuilder::default()
    }
}
/// Request parameters for the [`query_margin_accounts_open_oco`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_margin_accounts_open_oco`](#method.query_margin_accounts_open_oco).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryMarginAccountsOpenOcoParams {
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryMarginAccountsOpenOcoParams {
    /// Create a builder for [`query_margin_accounts_open_oco`].
    ///
    #[must_use]
    pub fn builder() -> QueryMarginAccountsOpenOcoParamsBuilder {
        QueryMarginAccountsOpenOcoParamsBuilder::default()
    }
}
/// Request parameters for the [`query_um_conditional_order_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_um_conditional_order_history`](#method.query_um_conditional_order_history).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryUmConditionalOrderHistoryParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `strategy_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub strategy_id: Option<i64>,
    ///
    /// The `new_client_strategy_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub new_client_strategy_id: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryUmConditionalOrderHistoryParams {
    /// Create a builder for [`query_um_conditional_order_history`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> QueryUmConditionalOrderHistoryParamsBuilder {
        QueryUmConditionalOrderHistoryParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`query_um_modify_order_history`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_um_modify_order_history`](#method.query_um_modify_order_history).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryUmModifyOrderHistoryParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_id: Option<i64>,
    ///
    /// The `orig_client_order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub orig_client_order_id: Option<String>,
    /// Timestamp in ms to get funding from INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    /// Timestamp in ms to get funding until INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Default 100; max 1000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryUmModifyOrderHistoryParams {
    /// Create a builder for [`query_um_modify_order_history`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> QueryUmModifyOrderHistoryParamsBuilder {
        QueryUmModifyOrderHistoryParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`query_um_order`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_um_order`](#method.query_um_order).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryUmOrderParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub order_id: Option<i64>,
    ///
    /// The `orig_client_order_id` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub orig_client_order_id: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryUmOrderParams {
    /// Create a builder for [`query_um_order`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> QueryUmOrderParamsBuilder {
        QueryUmOrderParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`query_users_cm_force_orders`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_users_cm_force_orders`](#method.query_users_cm_force_orders).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryUsersCmForceOrdersParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    /// `LIQUIDATION` for liquidation orders, `ADL` for ADL orders.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub auto_close_type: Option<QueryUsersCmForceOrdersAutoCloseTypeEnum>,
    /// Timestamp in ms to get funding from INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    /// Timestamp in ms to get funding until INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Default 100; max 1000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryUsersCmForceOrdersParams {
    /// Create a builder for [`query_users_cm_force_orders`].
    ///
    #[must_use]
    pub fn builder() -> QueryUsersCmForceOrdersParamsBuilder {
        QueryUsersCmForceOrdersParamsBuilder::default()
    }
}
/// Request parameters for the [`query_users_margin_force_orders`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_users_margin_force_orders`](#method.query_users_margin_force_orders).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryUsersMarginForceOrdersParams {
    /// Timestamp in ms to get funding from INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    /// Timestamp in ms to get funding until INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Currently querying page. Start from 1. Default:1
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub current: Option<i64>,
    /// Default:10 Max:100
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub size: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryUsersMarginForceOrdersParams {
    /// Create a builder for [`query_users_margin_force_orders`].
    ///
    #[must_use]
    pub fn builder() -> QueryUsersMarginForceOrdersParamsBuilder {
        QueryUsersMarginForceOrdersParamsBuilder::default()
    }
}
/// Request parameters for the [`query_users_um_force_orders`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`query_users_um_force_orders`](#method.query_users_um_force_orders).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct QueryUsersUmForceOrdersParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    /// `LIQUIDATION` for liquidation orders, `ADL` for ADL orders.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub auto_close_type: Option<QueryUsersUmForceOrdersAutoCloseTypeEnum>,
    /// Timestamp in ms to get funding from INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    /// Timestamp in ms to get funding until INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Default 100; max 1000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl QueryUsersUmForceOrdersParams {
    /// Create a builder for [`query_users_um_force_orders`].
    ///
    #[must_use]
    pub fn builder() -> QueryUsersUmForceOrdersParamsBuilder {
        QueryUsersUmForceOrdersParamsBuilder::default()
    }
}
/// Request parameters for the [`toggle_bnb_burn_on_um_futures_trade`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`toggle_bnb_burn_on_um_futures_trade`](#method.toggle_bnb_burn_on_um_futures_trade).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct ToggleBnbBurnOnUmFuturesTradeParams {
    /// "true": Fee Discount On; "false": Fee Discount Off
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub fee_burn: String,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl ToggleBnbBurnOnUmFuturesTradeParams {
    /// Create a builder for [`toggle_bnb_burn_on_um_futures_trade`].
    ///
    /// Required parameters:
    ///
    /// * `fee_burn` — \"true\": Fee Discount On; \"false\": Fee Discount Off
    ///
    #[must_use]
    pub fn builder(fee_burn: String) -> ToggleBnbBurnOnUmFuturesTradeParamsBuilder {
        ToggleBnbBurnOnUmFuturesTradeParamsBuilder::default().fee_burn(fee_burn)
    }
}
/// Request parameters for the [`um_account_trade_list`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`um_account_trade_list`](#method.um_account_trade_list).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct UmAccountTradeListParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// Timestamp in ms to get funding from INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    /// Timestamp in ms to get funding until INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Trade id to fetch from. Default gets most recent trades.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub from_id: Option<i64>,
    /// Default 100; max 1000
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i64>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl UmAccountTradeListParams {
    /// Create a builder for [`um_account_trade_list`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> UmAccountTradeListParamsBuilder {
        UmAccountTradeListParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`um_position_adl_quantile_estimation`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`um_position_adl_quantile_estimation`](#method.um_position_adl_quantile_estimation).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct UmPositionAdlQuantileEstimationParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    ///
    /// The `recv_window` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub recv_window: Option<i64>,
}

impl UmPositionAdlQuantileEstimationParams {
    /// Create a builder for [`um_position_adl_quantile_estimation`].
    ///
    #[must_use]
    pub fn builder() -> UmPositionAdlQuantileEstimationParamsBuilder {
        UmPositionAdlQuantileEstimationParamsBuilder::default()
    }
}

#[async_trait]
impl TradeApi for TradeApiClient {
    async fn cancel_all_cm_open_conditional_orders(
        &self,
        params: CancelAllCmOpenConditionalOrdersParams,
    ) -> anyhow::Result<RestApiResponse<models::CancelAllCmOpenConditionalOrdersResponse>> {
        let CancelAllCmOpenConditionalOrdersParams {
            symbol,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::CancelAllCmOpenConditionalOrdersResponse>(
            &self.configuration,
            "/papi/v1/cm/conditional/allOpenOrders",
            reqwest::Method::DELETE,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn cancel_all_cm_open_orders(
        &self,
        params: CancelAllCmOpenOrdersParams,
    ) -> anyhow::Result<RestApiResponse<models::CancelAllCmOpenOrdersResponse>> {
        let CancelAllCmOpenOrdersParams {
            symbol,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::CancelAllCmOpenOrdersResponse>(
            &self.configuration,
            "/papi/v1/cm/allOpenOrders",
            reqwest::Method::DELETE,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn cancel_all_um_open_conditional_orders(
        &self,
        params: CancelAllUmOpenConditionalOrdersParams,
    ) -> anyhow::Result<RestApiResponse<models::CancelAllUmOpenConditionalOrdersResponse>> {
        let CancelAllUmOpenConditionalOrdersParams {
            symbol,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::CancelAllUmOpenConditionalOrdersResponse>(
            &self.configuration,
            "/papi/v1/um/conditional/allOpenOrders",
            reqwest::Method::DELETE,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn cancel_all_um_open_orders(
        &self,
        params: CancelAllUmOpenOrdersParams,
    ) -> anyhow::Result<RestApiResponse<models::CancelAllUmOpenOrdersResponse>> {
        let CancelAllUmOpenOrdersParams {
            symbol,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::CancelAllUmOpenOrdersResponse>(
            &self.configuration,
            "/papi/v1/um/allOpenOrders",
            reqwest::Method::DELETE,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn cancel_cm_conditional_order(
        &self,
        params: CancelCmConditionalOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::CancelCmConditionalOrderResponse>> {
        let CancelCmConditionalOrderParams {
            symbol,
            strategy_id,
            new_client_strategy_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = strategy_id {
            query_params.insert("strategyId".to_string(), json!(rw));
        }

        if let Some(rw) = new_client_strategy_id {
            query_params.insert("newClientStrategyId".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::CancelCmConditionalOrderResponse>(
            &self.configuration,
            "/papi/v1/cm/conditional/order",
            reqwest::Method::DELETE,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn cancel_cm_order(
        &self,
        params: CancelCmOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::CancelCmOrderResponse>> {
        let CancelCmOrderParams {
            symbol,
            order_id,
            orig_client_order_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = order_id {
            query_params.insert("orderId".to_string(), json!(rw));
        }

        if let Some(rw) = orig_client_order_id {
            query_params.insert("origClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::CancelCmOrderResponse>(
            &self.configuration,
            "/papi/v1/cm/order",
            reqwest::Method::DELETE,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn cancel_margin_account_all_open_orders_on_a_symbol(
        &self,
        params: CancelMarginAccountAllOpenOrdersOnASymbolParams,
    ) -> anyhow::Result<
        RestApiResponse<Vec<models::CancelMarginAccountAllOpenOrdersOnASymbolResponseInner>>,
    > {
        let CancelMarginAccountAllOpenOrdersOnASymbolParams {
            symbol,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::CancelMarginAccountAllOpenOrdersOnASymbolResponseInner>>(
            &self.configuration,
            "/papi/v1/margin/allOpenOrders",
            reqwest::Method::DELETE,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn cancel_margin_account_oco_orders(
        &self,
        params: CancelMarginAccountOcoOrdersParams,
    ) -> anyhow::Result<RestApiResponse<models::CancelMarginAccountOcoOrdersResponse>> {
        let CancelMarginAccountOcoOrdersParams {
            symbol,
            order_list_id,
            list_client_order_id,
            new_client_order_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = order_list_id {
            query_params.insert("orderListId".to_string(), json!(rw));
        }

        if let Some(rw) = list_client_order_id {
            query_params.insert("listClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = new_client_order_id {
            query_params.insert("newClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::CancelMarginAccountOcoOrdersResponse>(
            &self.configuration,
            "/papi/v1/margin/orderList",
            reqwest::Method::DELETE,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn cancel_margin_account_order(
        &self,
        params: CancelMarginAccountOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::CancelMarginAccountOrderResponse>> {
        let CancelMarginAccountOrderParams {
            symbol,
            order_id,
            orig_client_order_id,
            new_client_order_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = order_id {
            query_params.insert("orderId".to_string(), json!(rw));
        }

        if let Some(rw) = orig_client_order_id {
            query_params.insert("origClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = new_client_order_id {
            query_params.insert("newClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::CancelMarginAccountOrderResponse>(
            &self.configuration,
            "/papi/v1/margin/order",
            reqwest::Method::DELETE,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn cancel_um_conditional_order(
        &self,
        params: CancelUmConditionalOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::CancelUmConditionalOrderResponse>> {
        let CancelUmConditionalOrderParams {
            symbol,
            strategy_id,
            new_client_strategy_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = strategy_id {
            query_params.insert("strategyId".to_string(), json!(rw));
        }

        if let Some(rw) = new_client_strategy_id {
            query_params.insert("newClientStrategyId".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::CancelUmConditionalOrderResponse>(
            &self.configuration,
            "/papi/v1/um/conditional/order",
            reqwest::Method::DELETE,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn cancel_um_order(
        &self,
        params: CancelUmOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::CancelUmOrderResponse>> {
        let CancelUmOrderParams {
            symbol,
            order_id,
            orig_client_order_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = order_id {
            query_params.insert("orderId".to_string(), json!(rw));
        }

        if let Some(rw) = orig_client_order_id {
            query_params.insert("origClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::CancelUmOrderResponse>(
            &self.configuration,
            "/papi/v1/um/order",
            reqwest::Method::DELETE,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn cm_account_trade_list(
        &self,
        params: CmAccountTradeListParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::CmAccountTradeListResponseInner>>> {
        let CmAccountTradeListParams {
            symbol,
            pair,
            start_time,
            end_time,
            from_id,
            limit,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = pair {
            query_params.insert("pair".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = from_id {
            query_params.insert("fromId".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::CmAccountTradeListResponseInner>>(
            &self.configuration,
            "/papi/v1/cm/userTrades",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn cm_position_adl_quantile_estimation(
        &self,
        params: CmPositionAdlQuantileEstimationParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::CmPositionAdlQuantileEstimationResponseInner>>>
    {
        let CmPositionAdlQuantileEstimationParams {
            symbol,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::CmPositionAdlQuantileEstimationResponseInner>>(
            &self.configuration,
            "/papi/v1/cm/adlQuantile",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn get_um_futures_bnb_burn_status(
        &self,
        params: GetUmFuturesBnbBurnStatusParams,
    ) -> anyhow::Result<RestApiResponse<models::GetUmFuturesBnbBurnStatusResponse>> {
        let GetUmFuturesBnbBurnStatusParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::GetUmFuturesBnbBurnStatusResponse>(
            &self.configuration,
            "/papi/v1/um/feeBurn",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn margin_account_borrow(
        &self,
        params: MarginAccountBorrowParams,
    ) -> anyhow::Result<RestApiResponse<models::MarginAccountBorrowResponse>> {
        let MarginAccountBorrowParams {
            asset,
            amount,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("asset".to_string(), json!(asset));

        query_params.insert("amount".to_string(), json!(amount));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::MarginAccountBorrowResponse>(
            &self.configuration,
            "/papi/v1/marginLoan",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn margin_account_new_oco(
        &self,
        params: MarginAccountNewOcoParams,
    ) -> anyhow::Result<RestApiResponse<models::MarginAccountNewOcoResponse>> {
        let MarginAccountNewOcoParams {
            symbol,
            side,
            quantity,
            price,
            stop_price,
            list_client_order_id,
            limit_client_order_id,
            limit_iceberg_qty,
            stop_client_order_id,
            stop_limit_price,
            stop_iceberg_qty,
            stop_limit_time_in_force,
            new_order_resp_type,
            side_effect_type,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        query_params.insert("side".to_string(), json!(side));

        query_params.insert("quantity".to_string(), json!(quantity));

        query_params.insert("price".to_string(), json!(price));

        query_params.insert("stopPrice".to_string(), json!(stop_price));

        if let Some(rw) = list_client_order_id {
            query_params.insert("listClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = limit_client_order_id {
            query_params.insert("limitClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = limit_iceberg_qty {
            query_params.insert("limitIcebergQty".to_string(), json!(rw));
        }

        if let Some(rw) = stop_client_order_id {
            query_params.insert("stopClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = stop_limit_price {
            query_params.insert("stopLimitPrice".to_string(), json!(rw));
        }

        if let Some(rw) = stop_iceberg_qty {
            query_params.insert("stopIcebergQty".to_string(), json!(rw));
        }

        if let Some(rw) = stop_limit_time_in_force {
            query_params.insert("stopLimitTimeInForce".to_string(), json!(rw));
        }

        if let Some(rw) = new_order_resp_type {
            query_params.insert("newOrderRespType".to_string(), json!(rw));
        }

        if let Some(rw) = side_effect_type {
            query_params.insert("sideEffectType".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::MarginAccountNewOcoResponse>(
            &self.configuration,
            "/papi/v1/margin/order/oco",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn margin_account_repay(
        &self,
        params: MarginAccountRepayParams,
    ) -> anyhow::Result<RestApiResponse<models::MarginAccountRepayResponse>> {
        let MarginAccountRepayParams {
            asset,
            amount,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("asset".to_string(), json!(asset));

        query_params.insert("amount".to_string(), json!(amount));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::MarginAccountRepayResponse>(
            &self.configuration,
            "/papi/v1/repayLoan",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn margin_account_repay_debt(
        &self,
        params: MarginAccountRepayDebtParams,
    ) -> anyhow::Result<RestApiResponse<models::MarginAccountRepayDebtResponse>> {
        let MarginAccountRepayDebtParams {
            asset,
            amount,
            specify_repay_assets,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("asset".to_string(), json!(asset));

        if let Some(rw) = amount {
            query_params.insert("amount".to_string(), json!(rw));
        }

        if let Some(rw) = specify_repay_assets {
            query_params.insert("specifyRepayAssets".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::MarginAccountRepayDebtResponse>(
            &self.configuration,
            "/papi/v1/margin/repay-debt",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn margin_account_trade_list(
        &self,
        params: MarginAccountTradeListParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::MarginAccountTradeListResponseInner>>> {
        let MarginAccountTradeListParams {
            symbol,
            order_id,
            start_time,
            end_time,
            from_id,
            limit,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = order_id {
            query_params.insert("orderId".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = from_id {
            query_params.insert("fromId".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::MarginAccountTradeListResponseInner>>(
            &self.configuration,
            "/papi/v1/margin/myTrades",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn modify_cm_order(
        &self,
        params: ModifyCmOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::ModifyCmOrderResponse>> {
        let ModifyCmOrderParams {
            symbol,
            side,
            quantity,
            price,
            order_id,
            orig_client_order_id,
            price_match,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        query_params.insert("side".to_string(), json!(side));

        query_params.insert("quantity".to_string(), json!(quantity));

        query_params.insert("price".to_string(), json!(price));

        if let Some(rw) = order_id {
            query_params.insert("orderId".to_string(), json!(rw));
        }

        if let Some(rw) = orig_client_order_id {
            query_params.insert("origClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = price_match {
            query_params.insert("priceMatch".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::ModifyCmOrderResponse>(
            &self.configuration,
            "/papi/v1/cm/order",
            reqwest::Method::PUT,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn modify_um_order(
        &self,
        params: ModifyUmOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::ModifyUmOrderResponse>> {
        let ModifyUmOrderParams {
            symbol,
            side,
            quantity,
            price,
            order_id,
            orig_client_order_id,
            price_match,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        query_params.insert("side".to_string(), json!(side));

        query_params.insert("quantity".to_string(), json!(quantity));

        query_params.insert("price".to_string(), json!(price));

        if let Some(rw) = order_id {
            query_params.insert("orderId".to_string(), json!(rw));
        }

        if let Some(rw) = orig_client_order_id {
            query_params.insert("origClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = price_match {
            query_params.insert("priceMatch".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::ModifyUmOrderResponse>(
            &self.configuration,
            "/papi/v1/um/order",
            reqwest::Method::PUT,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn new_cm_conditional_order(
        &self,
        params: NewCmConditionalOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::NewCmConditionalOrderResponse>> {
        let NewCmConditionalOrderParams {
            symbol,
            side,
            strategy_type,
            position_side,
            time_in_force,
            quantity,
            reduce_only,
            price,
            working_type,
            price_protect,
            new_client_strategy_id,
            stop_price,
            activation_price,
            callback_rate,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        query_params.insert("side".to_string(), json!(side));

        query_params.insert("strategyType".to_string(), json!(strategy_type));

        if let Some(rw) = position_side {
            query_params.insert("positionSide".to_string(), json!(rw));
        }

        if let Some(rw) = time_in_force {
            query_params.insert("timeInForce".to_string(), json!(rw));
        }

        if let Some(rw) = quantity {
            query_params.insert("quantity".to_string(), json!(rw));
        }

        if let Some(rw) = reduce_only {
            query_params.insert("reduceOnly".to_string(), json!(rw));
        }

        if let Some(rw) = price {
            query_params.insert("price".to_string(), json!(rw));
        }

        if let Some(rw) = working_type {
            query_params.insert("workingType".to_string(), json!(rw));
        }

        if let Some(rw) = price_protect {
            query_params.insert("priceProtect".to_string(), json!(rw));
        }

        if let Some(rw) = new_client_strategy_id {
            query_params.insert("newClientStrategyId".to_string(), json!(rw));
        }

        if let Some(rw) = stop_price {
            query_params.insert("stopPrice".to_string(), json!(rw));
        }

        if let Some(rw) = activation_price {
            query_params.insert("activationPrice".to_string(), json!(rw));
        }

        if let Some(rw) = callback_rate {
            query_params.insert("callbackRate".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::NewCmConditionalOrderResponse>(
            &self.configuration,
            "/papi/v1/cm/conditional/order",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn new_cm_order(
        &self,
        params: NewCmOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::NewCmOrderResponse>> {
        let NewCmOrderParams {
            symbol,
            side,
            r#type,
            position_side,
            time_in_force,
            quantity,
            reduce_only,
            price,
            price_match,
            new_client_order_id,
            new_order_resp_type,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        query_params.insert("side".to_string(), json!(side));

        query_params.insert("type".to_string(), json!(r#type));

        if let Some(rw) = position_side {
            query_params.insert("positionSide".to_string(), json!(rw));
        }

        if let Some(rw) = time_in_force {
            query_params.insert("timeInForce".to_string(), json!(rw));
        }

        if let Some(rw) = quantity {
            query_params.insert("quantity".to_string(), json!(rw));
        }

        if let Some(rw) = reduce_only {
            query_params.insert("reduceOnly".to_string(), json!(rw));
        }

        if let Some(rw) = price {
            query_params.insert("price".to_string(), json!(rw));
        }

        if let Some(rw) = price_match {
            query_params.insert("priceMatch".to_string(), json!(rw));
        }

        if let Some(rw) = new_client_order_id {
            query_params.insert("newClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = new_order_resp_type {
            query_params.insert("newOrderRespType".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::NewCmOrderResponse>(
            &self.configuration,
            "/papi/v1/cm/order",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn new_margin_order(
        &self,
        params: NewMarginOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::NewMarginOrderResponse>> {
        let NewMarginOrderParams {
            symbol,
            side,
            r#type,
            quantity,
            quote_order_qty,
            price,
            stop_price,
            new_client_order_id,
            new_order_resp_type,
            iceberg_qty,
            side_effect_type,
            time_in_force,
            self_trade_prevention_mode,
            auto_repay_at_cancel,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        query_params.insert("side".to_string(), json!(side));

        query_params.insert("type".to_string(), json!(r#type));

        if let Some(rw) = quantity {
            query_params.insert("quantity".to_string(), json!(rw));
        }

        if let Some(rw) = quote_order_qty {
            query_params.insert("quoteOrderQty".to_string(), json!(rw));
        }

        if let Some(rw) = price {
            query_params.insert("price".to_string(), json!(rw));
        }

        if let Some(rw) = stop_price {
            query_params.insert("stopPrice".to_string(), json!(rw));
        }

        if let Some(rw) = new_client_order_id {
            query_params.insert("newClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = new_order_resp_type {
            query_params.insert("newOrderRespType".to_string(), json!(rw));
        }

        if let Some(rw) = iceberg_qty {
            query_params.insert("icebergQty".to_string(), json!(rw));
        }

        if let Some(rw) = side_effect_type {
            query_params.insert("sideEffectType".to_string(), json!(rw));
        }

        if let Some(rw) = time_in_force {
            query_params.insert("timeInForce".to_string(), json!(rw));
        }

        if let Some(rw) = self_trade_prevention_mode {
            query_params.insert("selfTradePreventionMode".to_string(), json!(rw));
        }

        if let Some(rw) = auto_repay_at_cancel {
            query_params.insert("autoRepayAtCancel".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::NewMarginOrderResponse>(
            &self.configuration,
            "/papi/v1/margin/order",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn new_um_conditional_order(
        &self,
        params: NewUmConditionalOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::NewUmConditionalOrderResponse>> {
        let NewUmConditionalOrderParams {
            symbol,
            side,
            strategy_type,
            position_side,
            time_in_force,
            quantity,
            reduce_only,
            price,
            working_type,
            price_protect,
            new_client_strategy_id,
            stop_price,
            activation_price,
            callback_rate,
            price_match,
            self_trade_prevention_mode,
            good_till_date,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        query_params.insert("side".to_string(), json!(side));

        query_params.insert("strategyType".to_string(), json!(strategy_type));

        if let Some(rw) = position_side {
            query_params.insert("positionSide".to_string(), json!(rw));
        }

        if let Some(rw) = time_in_force {
            query_params.insert("timeInForce".to_string(), json!(rw));
        }

        if let Some(rw) = quantity {
            query_params.insert("quantity".to_string(), json!(rw));
        }

        if let Some(rw) = reduce_only {
            query_params.insert("reduceOnly".to_string(), json!(rw));
        }

        if let Some(rw) = price {
            query_params.insert("price".to_string(), json!(rw));
        }

        if let Some(rw) = working_type {
            query_params.insert("workingType".to_string(), json!(rw));
        }

        if let Some(rw) = price_protect {
            query_params.insert("priceProtect".to_string(), json!(rw));
        }

        if let Some(rw) = new_client_strategy_id {
            query_params.insert("newClientStrategyId".to_string(), json!(rw));
        }

        if let Some(rw) = stop_price {
            query_params.insert("stopPrice".to_string(), json!(rw));
        }

        if let Some(rw) = activation_price {
            query_params.insert("activationPrice".to_string(), json!(rw));
        }

        if let Some(rw) = callback_rate {
            query_params.insert("callbackRate".to_string(), json!(rw));
        }

        if let Some(rw) = price_match {
            query_params.insert("priceMatch".to_string(), json!(rw));
        }

        if let Some(rw) = self_trade_prevention_mode {
            query_params.insert("selfTradePreventionMode".to_string(), json!(rw));
        }

        if let Some(rw) = good_till_date {
            query_params.insert("goodTillDate".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::NewUmConditionalOrderResponse>(
            &self.configuration,
            "/papi/v1/um/conditional/order",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn new_um_order(
        &self,
        params: NewUmOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::NewUmOrderResponse>> {
        let NewUmOrderParams {
            symbol,
            side,
            r#type,
            position_side,
            time_in_force,
            quantity,
            reduce_only,
            price,
            new_client_order_id,
            new_order_resp_type,
            price_match,
            self_trade_prevention_mode,
            good_till_date,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        query_params.insert("side".to_string(), json!(side));

        query_params.insert("type".to_string(), json!(r#type));

        if let Some(rw) = position_side {
            query_params.insert("positionSide".to_string(), json!(rw));
        }

        if let Some(rw) = time_in_force {
            query_params.insert("timeInForce".to_string(), json!(rw));
        }

        if let Some(rw) = quantity {
            query_params.insert("quantity".to_string(), json!(rw));
        }

        if let Some(rw) = reduce_only {
            query_params.insert("reduceOnly".to_string(), json!(rw));
        }

        if let Some(rw) = price {
            query_params.insert("price".to_string(), json!(rw));
        }

        if let Some(rw) = new_client_order_id {
            query_params.insert("newClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = new_order_resp_type {
            query_params.insert("newOrderRespType".to_string(), json!(rw));
        }

        if let Some(rw) = price_match {
            query_params.insert("priceMatch".to_string(), json!(rw));
        }

        if let Some(rw) = self_trade_prevention_mode {
            query_params.insert("selfTradePreventionMode".to_string(), json!(rw));
        }

        if let Some(rw) = good_till_date {
            query_params.insert("goodTillDate".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::NewUmOrderResponse>(
            &self.configuration,
            "/papi/v1/um/order",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_all_cm_conditional_orders(
        &self,
        params: QueryAllCmConditionalOrdersParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryAllCmConditionalOrdersResponseInner>>>
    {
        let QueryAllCmConditionalOrdersParams {
            symbol,
            strategy_id,
            start_time,
            end_time,
            limit,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = strategy_id {
            query_params.insert("strategyId".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::QueryAllCmConditionalOrdersResponseInner>>(
            &self.configuration,
            "/papi/v1/cm/conditional/allOrders",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_all_cm_orders(
        &self,
        params: QueryAllCmOrdersParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryAllCmOrdersResponseInner>>> {
        let QueryAllCmOrdersParams {
            symbol,
            pair,
            order_id,
            start_time,
            end_time,
            limit,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = pair {
            query_params.insert("pair".to_string(), json!(rw));
        }

        if let Some(rw) = order_id {
            query_params.insert("orderId".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::QueryAllCmOrdersResponseInner>>(
            &self.configuration,
            "/papi/v1/cm/allOrders",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_all_current_cm_open_conditional_orders(
        &self,
        params: QueryAllCurrentCmOpenConditionalOrdersParams,
    ) -> anyhow::Result<
        RestApiResponse<Vec<models::QueryAllCurrentCmOpenConditionalOrdersResponseInner>>,
    > {
        let QueryAllCurrentCmOpenConditionalOrdersParams {
            symbol,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::QueryAllCurrentCmOpenConditionalOrdersResponseInner>>(
            &self.configuration,
            "/papi/v1/cm/conditional/openOrders",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_all_current_cm_open_orders(
        &self,
        params: QueryAllCurrentCmOpenOrdersParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryAllCmOrdersResponseInner>>> {
        let QueryAllCurrentCmOpenOrdersParams {
            symbol,
            pair,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = pair {
            query_params.insert("pair".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::QueryAllCmOrdersResponseInner>>(
            &self.configuration,
            "/papi/v1/cm/openOrders",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_all_current_um_open_conditional_orders(
        &self,
        params: QueryAllCurrentUmOpenConditionalOrdersParams,
    ) -> anyhow::Result<
        RestApiResponse<Vec<models::QueryAllCurrentUmOpenConditionalOrdersResponseInner>>,
    > {
        let QueryAllCurrentUmOpenConditionalOrdersParams {
            symbol,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::QueryAllCurrentUmOpenConditionalOrdersResponseInner>>(
            &self.configuration,
            "/papi/v1/um/conditional/openOrders",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_all_current_um_open_orders(
        &self,
        params: QueryAllCurrentUmOpenOrdersParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryAllCurrentUmOpenOrdersResponseInner>>>
    {
        let QueryAllCurrentUmOpenOrdersParams {
            symbol,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::QueryAllCurrentUmOpenOrdersResponseInner>>(
            &self.configuration,
            "/papi/v1/um/openOrders",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_all_margin_account_orders(
        &self,
        params: QueryAllMarginAccountOrdersParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryAllMarginAccountOrdersResponseInner>>>
    {
        let QueryAllMarginAccountOrdersParams {
            symbol,
            order_id,
            start_time,
            end_time,
            limit,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = order_id {
            query_params.insert("orderId".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::QueryAllMarginAccountOrdersResponseInner>>(
            &self.configuration,
            "/papi/v1/margin/allOrders",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_all_um_conditional_orders(
        &self,
        params: QueryAllUmConditionalOrdersParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryAllUmConditionalOrdersResponseInner>>>
    {
        let QueryAllUmConditionalOrdersParams {
            symbol,
            strategy_id,
            start_time,
            end_time,
            limit,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = strategy_id {
            query_params.insert("strategyId".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::QueryAllUmConditionalOrdersResponseInner>>(
            &self.configuration,
            "/papi/v1/um/conditional/allOrders",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_all_um_orders(
        &self,
        params: QueryAllUmOrdersParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryAllCurrentUmOpenOrdersResponseInner>>>
    {
        let QueryAllUmOrdersParams {
            symbol,
            order_id,
            start_time,
            end_time,
            limit,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = order_id {
            query_params.insert("orderId".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::QueryAllCurrentUmOpenOrdersResponseInner>>(
            &self.configuration,
            "/papi/v1/um/allOrders",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_cm_conditional_order_history(
        &self,
        params: QueryCmConditionalOrderHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryCmConditionalOrderHistoryResponse>> {
        let QueryCmConditionalOrderHistoryParams {
            symbol,
            strategy_id,
            new_client_strategy_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = strategy_id {
            query_params.insert("strategyId".to_string(), json!(rw));
        }

        if let Some(rw) = new_client_strategy_id {
            query_params.insert("newClientStrategyId".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::QueryCmConditionalOrderHistoryResponse>(
            &self.configuration,
            "/papi/v1/cm/conditional/orderHistory",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_cm_modify_order_history(
        &self,
        params: QueryCmModifyOrderHistoryParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryCmModifyOrderHistoryResponseInner>>> {
        let QueryCmModifyOrderHistoryParams {
            symbol,
            order_id,
            orig_client_order_id,
            start_time,
            end_time,
            limit,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = order_id {
            query_params.insert("orderId".to_string(), json!(rw));
        }

        if let Some(rw) = orig_client_order_id {
            query_params.insert("origClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::QueryCmModifyOrderHistoryResponseInner>>(
            &self.configuration,
            "/papi/v1/cm/orderAmendment",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_cm_order(
        &self,
        params: QueryCmOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryCmOrderResponse>> {
        let QueryCmOrderParams {
            symbol,
            order_id,
            orig_client_order_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = order_id {
            query_params.insert("orderId".to_string(), json!(rw));
        }

        if let Some(rw) = orig_client_order_id {
            query_params.insert("origClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::QueryCmOrderResponse>(
            &self.configuration,
            "/papi/v1/cm/order",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_current_cm_open_conditional_order(
        &self,
        params: QueryCurrentCmOpenConditionalOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryCurrentCmOpenConditionalOrderResponse>> {
        let QueryCurrentCmOpenConditionalOrderParams {
            symbol,
            strategy_id,
            new_client_strategy_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = strategy_id {
            query_params.insert("strategyId".to_string(), json!(rw));
        }

        if let Some(rw) = new_client_strategy_id {
            query_params.insert("newClientStrategyId".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::QueryCurrentCmOpenConditionalOrderResponse>(
            &self.configuration,
            "/papi/v1/cm/conditional/openOrder",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_current_cm_open_order(
        &self,
        params: QueryCurrentCmOpenOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryCurrentCmOpenOrderResponse>> {
        let QueryCurrentCmOpenOrderParams {
            symbol,
            order_id,
            orig_client_order_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = order_id {
            query_params.insert("orderId".to_string(), json!(rw));
        }

        if let Some(rw) = orig_client_order_id {
            query_params.insert("origClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::QueryCurrentCmOpenOrderResponse>(
            &self.configuration,
            "/papi/v1/cm/openOrder",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_current_margin_open_order(
        &self,
        params: QueryCurrentMarginOpenOrderParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryCurrentMarginOpenOrderResponseInner>>>
    {
        let QueryCurrentMarginOpenOrderParams {
            symbol,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::QueryCurrentMarginOpenOrderResponseInner>>(
            &self.configuration,
            "/papi/v1/margin/openOrders",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_current_um_open_conditional_order(
        &self,
        params: QueryCurrentUmOpenConditionalOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryCurrentUmOpenConditionalOrderResponse>> {
        let QueryCurrentUmOpenConditionalOrderParams {
            symbol,
            strategy_id,
            new_client_strategy_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = strategy_id {
            query_params.insert("strategyId".to_string(), json!(rw));
        }

        if let Some(rw) = new_client_strategy_id {
            query_params.insert("newClientStrategyId".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::QueryCurrentUmOpenConditionalOrderResponse>(
            &self.configuration,
            "/papi/v1/um/conditional/openOrder",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_current_um_open_order(
        &self,
        params: QueryCurrentUmOpenOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryCurrentUmOpenOrderResponse>> {
        let QueryCurrentUmOpenOrderParams {
            symbol,
            order_id,
            orig_client_order_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = order_id {
            query_params.insert("orderId".to_string(), json!(rw));
        }

        if let Some(rw) = orig_client_order_id {
            query_params.insert("origClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::QueryCurrentUmOpenOrderResponse>(
            &self.configuration,
            "/papi/v1/um/openOrder",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_margin_account_order(
        &self,
        params: QueryMarginAccountOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryMarginAccountOrderResponse>> {
        let QueryMarginAccountOrderParams {
            symbol,
            order_id,
            orig_client_order_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = order_id {
            query_params.insert("orderId".to_string(), json!(rw));
        }

        if let Some(rw) = orig_client_order_id {
            query_params.insert("origClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::QueryMarginAccountOrderResponse>(
            &self.configuration,
            "/papi/v1/margin/order",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_margin_accounts_all_oco(
        &self,
        params: QueryMarginAccountsAllOcoParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryMarginAccountsAllOcoResponseInner>>> {
        let QueryMarginAccountsAllOcoParams {
            from_id,
            start_time,
            end_time,
            limit,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = from_id {
            query_params.insert("fromId".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::QueryMarginAccountsAllOcoResponseInner>>(
            &self.configuration,
            "/papi/v1/margin/allOrderList",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_margin_accounts_oco(
        &self,
        params: QueryMarginAccountsOcoParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryMarginAccountsOcoResponse>> {
        let QueryMarginAccountsOcoParams {
            order_list_id,
            orig_client_order_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = order_list_id {
            query_params.insert("orderListId".to_string(), json!(rw));
        }

        if let Some(rw) = orig_client_order_id {
            query_params.insert("origClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::QueryMarginAccountsOcoResponse>(
            &self.configuration,
            "/papi/v1/margin/orderList",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_margin_accounts_open_oco(
        &self,
        params: QueryMarginAccountsOpenOcoParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryMarginAccountsOpenOcoResponseInner>>> {
        let QueryMarginAccountsOpenOcoParams { recv_window } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::QueryMarginAccountsOpenOcoResponseInner>>(
            &self.configuration,
            "/papi/v1/margin/openOrderList",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_um_conditional_order_history(
        &self,
        params: QueryUmConditionalOrderHistoryParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryUmConditionalOrderHistoryResponse>> {
        let QueryUmConditionalOrderHistoryParams {
            symbol,
            strategy_id,
            new_client_strategy_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = strategy_id {
            query_params.insert("strategyId".to_string(), json!(rw));
        }

        if let Some(rw) = new_client_strategy_id {
            query_params.insert("newClientStrategyId".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::QueryUmConditionalOrderHistoryResponse>(
            &self.configuration,
            "/papi/v1/um/conditional/orderHistory",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_um_modify_order_history(
        &self,
        params: QueryUmModifyOrderHistoryParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryUmModifyOrderHistoryResponseInner>>> {
        let QueryUmModifyOrderHistoryParams {
            symbol,
            order_id,
            orig_client_order_id,
            start_time,
            end_time,
            limit,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = order_id {
            query_params.insert("orderId".to_string(), json!(rw));
        }

        if let Some(rw) = orig_client_order_id {
            query_params.insert("origClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::QueryUmModifyOrderHistoryResponseInner>>(
            &self.configuration,
            "/papi/v1/um/orderAmendment",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_um_order(
        &self,
        params: QueryUmOrderParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryUmOrderResponse>> {
        let QueryUmOrderParams {
            symbol,
            order_id,
            orig_client_order_id,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = order_id {
            query_params.insert("orderId".to_string(), json!(rw));
        }

        if let Some(rw) = orig_client_order_id {
            query_params.insert("origClientOrderId".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::QueryUmOrderResponse>(
            &self.configuration,
            "/papi/v1/um/order",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_users_cm_force_orders(
        &self,
        params: QueryUsersCmForceOrdersParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryUsersCmForceOrdersResponseInner>>> {
        let QueryUsersCmForceOrdersParams {
            symbol,
            auto_close_type,
            start_time,
            end_time,
            limit,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = auto_close_type {
            query_params.insert("autoCloseType".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::QueryUsersCmForceOrdersResponseInner>>(
            &self.configuration,
            "/papi/v1/cm/forceOrders",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_users_margin_force_orders(
        &self,
        params: QueryUsersMarginForceOrdersParams,
    ) -> anyhow::Result<RestApiResponse<models::QueryUsersMarginForceOrdersResponse>> {
        let QueryUsersMarginForceOrdersParams {
            start_time,
            end_time,
            current,
            size,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = current {
            query_params.insert("current".to_string(), json!(rw));
        }

        if let Some(rw) = size {
            query_params.insert("size".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::QueryUsersMarginForceOrdersResponse>(
            &self.configuration,
            "/papi/v1/margin/forceOrders",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn query_users_um_force_orders(
        &self,
        params: QueryUsersUmForceOrdersParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::QueryUsersUmForceOrdersResponseInner>>> {
        let QueryUsersUmForceOrdersParams {
            symbol,
            auto_close_type,
            start_time,
            end_time,
            limit,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = auto_close_type {
            query_params.insert("autoCloseType".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::QueryUsersUmForceOrdersResponseInner>>(
            &self.configuration,
            "/papi/v1/um/forceOrders",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn toggle_bnb_burn_on_um_futures_trade(
        &self,
        params: ToggleBnbBurnOnUmFuturesTradeParams,
    ) -> anyhow::Result<RestApiResponse<models::ToggleBnbBurnOnUmFuturesTradeResponse>> {
        let ToggleBnbBurnOnUmFuturesTradeParams {
            fee_burn,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("feeBurn".to_string(), json!(fee_burn));

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<models::ToggleBnbBurnOnUmFuturesTradeResponse>(
            &self.configuration,
            "/papi/v1/um/feeBurn",
            reqwest::Method::POST,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn um_account_trade_list(
        &self,
        params: UmAccountTradeListParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::UmAccountTradeListResponseInner>>> {
        let UmAccountTradeListParams {
            symbol,
            start_time,
            end_time,
            from_id,
            limit,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = from_id {
            query_params.insert("fromId".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::UmAccountTradeListResponseInner>>(
            &self.configuration,
            "/papi/v1/um/userTrades",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }

    async fn um_position_adl_quantile_estimation(
        &self,
        params: UmPositionAdlQuantileEstimationParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::UmPositionAdlQuantileEstimationResponseInner>>>
    {
        let UmPositionAdlQuantileEstimationParams {
            symbol,
            recv_window,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = recv_window {
            query_params.insert("recvWindow".to_string(), json!(rw));
        }

        send_request::<Vec<models::UmPositionAdlQuantileEstimationResponseInner>>(
            &self.configuration,
            "/papi/v1/um/adlQuantile",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            true,
        )
        .await
    }
}

#[cfg(all(test, feature = "derivatives_trading_portfolio_margin"))]
mod tests {
    use super::*;
    use crate::TOKIO_SHARED_RT;
    use crate::{errors::ConnectorError, models::DataFuture, models::RestApiRateLimit};
    use async_trait::async_trait;
    use std::collections::HashMap;

    struct DummyRestApiResponse<T> {
        inner: Box<dyn FnOnce() -> DataFuture<Result<T, ConnectorError>> + Send + Sync>,
        status: u16,
        headers: HashMap<String, String>,
        rate_limits: Option<Vec<RestApiRateLimit>>,
    }

    impl<T> From<DummyRestApiResponse<T>> for RestApiResponse<T> {
        fn from(dummy: DummyRestApiResponse<T>) -> Self {
            Self {
                data_fn: dummy.inner,
                status: dummy.status,
                headers: dummy.headers,
                rate_limits: dummy.rate_limits,
            }
        }
    }

    struct MockTradeApiClient {
        force_error: bool,
    }

    #[async_trait]
    impl TradeApi for MockTradeApiClient {
        async fn cancel_all_cm_open_conditional_orders(
            &self,
            _params: CancelAllCmOpenConditionalOrdersParams,
        ) -> anyhow::Result<RestApiResponse<models::CancelAllCmOpenConditionalOrdersResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"code":"200","msg":"The operation of cancel all conditional open order is done."}"#).unwrap();
            let dummy_response: models::CancelAllCmOpenConditionalOrdersResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::CancelAllCmOpenConditionalOrdersResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn cancel_all_cm_open_orders(
            &self,
            _params: CancelAllCmOpenOrdersParams,
        ) -> anyhow::Result<RestApiResponse<models::CancelAllCmOpenOrdersResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(
                r#"{"code":200,"msg":"The operation of cancel all open order is done."}"#,
            )
            .unwrap();
            let dummy_response: models::CancelAllCmOpenOrdersResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::CancelAllCmOpenOrdersResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn cancel_all_um_open_conditional_orders(
            &self,
            _params: CancelAllUmOpenConditionalOrdersParams,
        ) -> anyhow::Result<RestApiResponse<models::CancelAllUmOpenConditionalOrdersResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"code":"200","msg":"The operation of cancel all conditional open order is done."}"#).unwrap();
            let dummy_response: models::CancelAllUmOpenConditionalOrdersResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::CancelAllUmOpenConditionalOrdersResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn cancel_all_um_open_orders(
            &self,
            _params: CancelAllUmOpenOrdersParams,
        ) -> anyhow::Result<RestApiResponse<models::CancelAllUmOpenOrdersResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(
                r#"{"code":200,"msg":"The operation of cancel all open order is done."}"#,
            )
            .unwrap();
            let dummy_response: models::CancelAllUmOpenOrdersResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::CancelAllUmOpenOrdersResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn cancel_cm_conditional_order(
            &self,
            _params: CancelCmConditionalOrderParams,
        ) -> anyhow::Result<RestApiResponse<models::CancelCmConditionalOrderResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"newClientStrategyId":"myOrder1","strategyId":123445,"strategyStatus":"CANCELED","strategyType":"TRAILING_STOP_MARKET","origQty":"11","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSD","timeInForce":"GTC","activatePrice":"9020","priceRate":"0.3","bookTime":1566818724710,"updateTime":1566818724722,"workingType":"CONTRACT_PRICE","priceProtect":false}"#).unwrap();
            let dummy_response: models::CancelCmConditionalOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::CancelCmConditionalOrderResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn cancel_cm_order(
            &self,
            _params: CancelCmOrderParams,
        ) -> anyhow::Result<RestApiResponse<models::CancelCmOrderResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"avgPrice":"0.0","clientOrderId":"myOrder1","cumQty":"0","cumBase":"0","executedQty":"0","orderId":283194212,"origQty":"2","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"CANCELED","symbol":"BTCUSD_200925","pair":"BTCUSD","timeInForce":"GTC","type":"LIMIT","updateTime":1571110484038}"#).unwrap();
            let dummy_response: models::CancelCmOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::CancelCmOrderResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn cancel_margin_account_all_open_orders_on_a_symbol(
            &self,
            _params: CancelMarginAccountAllOpenOrdersOnASymbolParams,
        ) -> anyhow::Result<
            RestApiResponse<Vec<models::CancelMarginAccountAllOpenOrdersOnASymbolResponseInner>>,
        > {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"symbol":"BTCUSDT","origClientOrderId":"E6APeyTJvkMvLMYMqu1KQ4","orderId":11,"orderListId":-1,"clientOrderId":"pXLV6Hz6mprAcVYpVMTGgx","price":"0.089853","origQty":"0.178622","executedQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT","side":"BUY"},{"orderListId":1929,"contingencyType":"OCO","listStatusType":"ALL_DONE","listOrderStatus":"ALL_DONE","listClientOrderId":"2inzWQdDvZLHbbAmAozX2N","transactionTime":1585230948299,"symbol":"BTCUSDT","orders":[{"symbol":"BTCUSDT","orderId":20,"clientOrderId":"CwOOIPHSmYywx6jZX77TdL"},{"symbol":"BTCUSDT","orderId":21,"clientOrderId":"461cPg51vQjV3zIMOXNz39"}],"orderReports":[{"symbol":"BTCUSDT","origClientOrderId":"CwOOIPHSmYywx6jZX77TdL","orderId":20,"orderListId":1929,"clientOrderId":"pXLV6Hz6mprAcVYpVMTGgx","price":"0.668611","origQty":"0.690354","executedQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"CANCELED","timeInForce":"GTC","type":"STOP_LOSS_LIMIT","side":"BUY","stopPrice":"0.378131","icebergQty":"0.017083"},{"symbol":"BTCUSDT","origClientOrderId":"461cPg51vQjV3zIMOXNz39","orderId":21,"orderListId":1929,"clientOrderId":"pXLV6Hz6mprAcVYpVMTGgx","price":"0.008791","origQty":"0.690354","executedQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT_MAKER","side":"BUY","icebergQty":"0.639962"}]}]"#).unwrap();
            let dummy_response : Vec<models::CancelMarginAccountAllOpenOrdersOnASymbolResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::CancelMarginAccountAllOpenOrdersOnASymbolResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn cancel_margin_account_oco_orders(
            &self,
            _params: CancelMarginAccountOcoOrdersParams,
        ) -> anyhow::Result<RestApiResponse<models::CancelMarginAccountOcoOrdersResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"orderListId":0,"contingencyType":"OCO","listStatusType":"ALL_DONE","listOrderStatus":"ALL_DONE","listClientOrderId":"C3wyj4WVEktd7u9aVBRXcN","transactionTime":1574040868128,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":2,"clientOrderId":"pO9ufTiFGg3nw2fOdgeOXa"},{"symbol":"LTCBTC","orderId":3,"clientOrderId":"TXOvglzXuaubXAaENpaRCB"}],"orderReports":[{"symbol":"LTCBTC","origClientOrderId":"pO9ufTiFGg3nw2fOdgeOXa","orderId":2,"orderListId":0,"clientOrderId":"unfWT8ig8i0uj6lPuYLez6","price":"1.00000000","origQty":"10.00000000","executedQty":"0.00000000","cummulativeQuoteQty":"0.00000000","status":"CANCELED","timeInForce":"GTC","type":"STOP_LOSS_LIMIT","side":"SELL","stopPrice":"1.00000000"},{"symbol":"LTCBTC","origClientOrderId":"TXOvglzXuaubXAaENpaRCB","orderId":3,"orderListId":0,"clientOrderId":"unfWT8ig8i0uj6lPuYLez6","price":"3.00000000","origQty":"10.00000000","executedQty":"0.00000000","cummulativeQuoteQty":"0.00000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT_MAKER","side":"SELL"}]}"#).unwrap();
            let dummy_response: models::CancelMarginAccountOcoOrdersResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::CancelMarginAccountOcoOrdersResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn cancel_margin_account_order(
            &self,
            _params: CancelMarginAccountOrderParams,
        ) -> anyhow::Result<RestApiResponse<models::CancelMarginAccountOrderResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"LTCBTC","orderId":28,"origClientOrderId":"myOrder1","clientOrderId":"cancelMyOrder1","price":"1.00000000","origQty":"10.00000000","executedQty":"8.00000000","cummulativeQuoteQty":"8.00000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT","side":"SELL"}"#).unwrap();
            let dummy_response: models::CancelMarginAccountOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::CancelMarginAccountOrderResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn cancel_um_conditional_order(
            &self,
            _params: CancelUmConditionalOrderParams,
        ) -> anyhow::Result<RestApiResponse<models::CancelUmConditionalOrderResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"newClientStrategyId":"myOrder1","strategyId":123445,"strategyStatus":"CANCELED","strategyType":"TRAILING_STOP_MARKET","origQty":"11","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSDT","timeInForce":"GTC","activatePrice":"9020","priceRate":"0.3","bookTime":1566818724710,"updateTime":1566818724722,"workingType":"CONTRACT_PRICE","priceProtect":false,"selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}"#).unwrap();
            let dummy_response: models::CancelUmConditionalOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::CancelUmConditionalOrderResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn cancel_um_order(
            &self,
            _params: CancelUmOrderParams,
        ) -> anyhow::Result<RestApiResponse<models::CancelUmOrderResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"avgPrice":"0.00000","clientOrderId":"myOrder1","cumQty":"0","cumQuote":"0","executedQty":"0","orderId":4611875134427365000,"origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"CANCELED","symbol":"BTCUSDT","timeInForce":"GTC","type":"LIMIT","updateTime":1571110484038,"selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}"#).unwrap();
            let dummy_response: models::CancelUmOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::CancelUmOrderResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn cm_account_trade_list(
            &self,
            _params: CmAccountTradeListParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::CmAccountTradeListResponseInner>>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"symbol":"BTCUSD_200626","id":6,"orderId":28,"pair":"BTCUSD","side":"SELL","price":"8800","qty":"1","realizedPnl":"0","marginAsset":"BTC","baseQty":"0.01136364","commission":"0.00000454","commissionAsset":"BTC","time":1590743483586,"positionSide":"BOTH","buyer":false,"maker":false}]"#).unwrap();
            let dummy_response: Vec<models::CmAccountTradeListResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::CmAccountTradeListResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn cm_position_adl_quantile_estimation(
            &self,
            _params: CmPositionAdlQuantileEstimationParams,
        ) -> anyhow::Result<
            RestApiResponse<Vec<models::CmPositionAdlQuantileEstimationResponseInner>>,
        > {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"symbol":"BTCUSD_200925","adlQuantile":{"LONG":3,"SHORT":3,"HEDGE":0}},{"symbol":"BTCUSD_201225","adlQuantile":{"LONG":1,"SHORT":2,"BOTH":0}}]"#).unwrap();
            let dummy_response: Vec<models::CmPositionAdlQuantileEstimationResponseInner> =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into Vec<models::CmPositionAdlQuantileEstimationResponseInner>",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_um_futures_bnb_burn_status(
            &self,
            _params: GetUmFuturesBnbBurnStatusParams,
        ) -> anyhow::Result<RestApiResponse<models::GetUmFuturesBnbBurnStatusResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"feeBurn":true}"#).unwrap();
            let dummy_response: models::GetUmFuturesBnbBurnStatusResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetUmFuturesBnbBurnStatusResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn margin_account_borrow(
            &self,
            _params: MarginAccountBorrowParams,
        ) -> anyhow::Result<RestApiResponse<models::MarginAccountBorrowResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"tranId":100000001}"#).unwrap();
            let dummy_response: models::MarginAccountBorrowResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::MarginAccountBorrowResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn margin_account_new_oco(
            &self,
            _params: MarginAccountNewOcoParams,
        ) -> anyhow::Result<RestApiResponse<models::MarginAccountNewOcoResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"orderListId":0,"contingencyType":"OCO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"JYVpp3F0f5CAG15DhtrqLp","transactionTime":1563417480525,"symbol":"LTCBTC","marginBuyBorrowAmount":"5","marginBuyBorrowAsset":"BTC","orders":[{"symbol":"LTCBTC","orderId":2,"clientOrderId":"Kk7sqHb9J6mJWTMDVW7Vos"},{"symbol":"LTCBTC","orderId":3,"clientOrderId":"xTXKaGYd4bluPVp78IVRvl"}],"orderReports":[{"symbol":"LTCBTC","orderId":2,"orderListId":0,"clientOrderId":"Kk7sqHb9J6mJWTMDVW7Vos","transactTime":1563417480525,"price":"0.000000","origQty":"0.624363","executedQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"NEW","timeInForce":"GTC","type":"STOP_LOSS","side":"BUY","stopPrice":"0.960664"},{"symbol":"LTCBTC","orderId":3,"orderListId":0,"clientOrderId":"xTXKaGYd4bluPVp78IVRvl","transactTime":1563417480525,"price":"0.036435","origQty":"0.624363","executedQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"NEW","timeInForce":"GTC","type":"LIMIT_MAKER","side":"BUY"}]}"#).unwrap();
            let dummy_response: models::MarginAccountNewOcoResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::MarginAccountNewOcoResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn margin_account_repay(
            &self,
            _params: MarginAccountRepayParams,
        ) -> anyhow::Result<RestApiResponse<models::MarginAccountRepayResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"tranId":100000001}"#).unwrap();
            let dummy_response: models::MarginAccountRepayResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::MarginAccountRepayResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn margin_account_repay_debt(
            &self,
            _params: MarginAccountRepayDebtParams,
        ) -> anyhow::Result<RestApiResponse<models::MarginAccountRepayDebtResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"amount":"0.10000000","asset":"BNB","specifyRepayAssets":["USDT","BTC"],"updateTime":1636371437000,"success":true}"#).unwrap();
            let dummy_response: models::MarginAccountRepayDebtResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::MarginAccountRepayDebtResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn margin_account_trade_list(
            &self,
            _params: MarginAccountTradeListParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::MarginAccountTradeListResponseInner>>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"commission":"0.00006000","commissionAsset":"BTC","id":34,"isBestMatch":true,"isBuyer":false,"isMaker":false,"orderId":39324,"price":"0.02000000","qty":"3.00000000","symbol":"BNBBTC","time":1561973357171}]"#).unwrap();
            let dummy_response: Vec<models::MarginAccountTradeListResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::MarginAccountTradeListResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn modify_cm_order(
            &self,
            _params: ModifyCmOrderParams,
        ) -> anyhow::Result<RestApiResponse<models::ModifyCmOrderResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"orderId":20072994037,"symbol":"BTCUSD_PERP","pair":"BTCUSD","status":"NEW","clientOrderId":"LJ9R4QZDihCaS8UAOOLpgW","price":"30005","avgPrice":"0.0","origQty":"1","executedQty":"0","cumQty":"0","cumBase":"0","timeInForce":"GTC","type":"LIMIT","reduceOnly":false,"side":"BUY","positionSide":"LONG","origType":"LIMIT","updateTime":1629182711600}"#).unwrap();
            let dummy_response: models::ModifyCmOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::ModifyCmOrderResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn modify_um_order(
            &self,
            _params: ModifyUmOrderParams,
        ) -> anyhow::Result<RestApiResponse<models::ModifyUmOrderResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"orderId":20072994037,"symbol":"BTCUSDT","status":"NEW","clientOrderId":"LJ9R4QZDihCaS8UAOOLpgW","price":"30005","avgPrice":"0.0","origQty":"1","executedQty":"0","cumQty":"0","cumQuote":"0","timeInForce":"GTC","type":"LIMIT","reduceOnly":false,"side":"BUY","positionSide":"LONG","origType":"LIMIT","selfTradePreventionMode":"NONE","goodTillDate":0,"updateTime":1629182711600,"priceMatch":"NONE"}"#).unwrap();
            let dummy_response: models::ModifyUmOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::ModifyUmOrderResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn new_cm_conditional_order(
            &self,
            _params: NewCmConditionalOrderParams,
        ) -> anyhow::Result<RestApiResponse<models::NewCmConditionalOrderResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"newClientStrategyId":"testOrder","strategyId":123445,"strategyStatus":"NEW","strategyType":"TRAILING_STOP_MARKET","origQty":"10","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSD_200925","pair":"BTCUSD","timeInForce":"GTC","activatePrice":"9020","priceRate":"0.3","bookTime":1566818724710,"updateTime":1566818724722,"workingType":"CONTRACT_PRICE","priceProtect":false}"#).unwrap();
            let dummy_response: models::NewCmConditionalOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::NewCmConditionalOrderResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn new_cm_order(
            &self,
            _params: NewCmOrderParams,
        ) -> anyhow::Result<RestApiResponse<models::NewCmOrderResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"clientOrderId":"testOrder","cumQty":"0","cumBase":"0","executedQty":"0","orderId":22542179,"avgPrice":"0.0","origQty":"10","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSD_200925","pair":"BTCUSD","timeInForce":"GTC","type":"MARKET","updateTime":1566818724722}"#).unwrap();
            let dummy_response: models::NewCmOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::NewCmOrderResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn new_margin_order(
            &self,
            _params: NewMarginOrderParams,
        ) -> anyhow::Result<RestApiResponse<models::NewMarginOrderResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"BTCUSDT","orderId":28,"clientOrderId":"6gCrw2kRUAF9CvJDGP16IP","transactTime":1507725176595,"price":"1.00000000","origQty":"10.00000000","executedQty":"10.00000000","cummulativeQuoteQty":"10.00000000","status":"FILLED","timeInForce":"GTC","type":"MARKET","side":"SELL","marginBuyBorrowAmount":"5","marginBuyBorrowAsset":"BTC","fills":[{"price":"4000.00000000","qty":"1.00000000","commission":"4.00000000","commissionAsset":"USDT"},{"price":"3999.00000000","qty":"5.00000000","commission":"19.99500000","commissionAsset":"USDT"}]}"#).unwrap();
            let dummy_response: models::NewMarginOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::NewMarginOrderResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn new_um_conditional_order(
            &self,
            _params: NewUmConditionalOrderParams,
        ) -> anyhow::Result<RestApiResponse<models::NewUmConditionalOrderResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"newClientStrategyId":"testOrder","strategyId":123445,"strategyStatus":"NEW","strategyType":"TRAILING_STOP_MARKET","origQty":"10","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSDT","timeInForce":"GTD","activatePrice":"9020","priceRate":"0.3","bookTime":1566818724710,"updateTime":1566818724722,"workingType":"CONTRACT_PRICE","priceProtect":false,"selfTradePreventionMode":"NONE","goodTillDate":1693207680000,"priceMatch":"NONE"}"#).unwrap();
            let dummy_response: models::NewUmConditionalOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::NewUmConditionalOrderResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn new_um_order(
            &self,
            _params: NewUmOrderParams,
        ) -> anyhow::Result<RestApiResponse<models::NewUmOrderResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"clientOrderId":"testOrder","cumQty":"0","cumQuote":"0","executedQty":"0","orderId":22542179,"avgPrice":"0.00000","origQty":"10","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSDT","timeInForce":"GTD","type":"MARKET","selfTradePreventionMode":"NONE","goodTillDate":1693207680000,"updateTime":1566818724722,"priceMatch":"NONE"}"#).unwrap();
            let dummy_response: models::NewUmOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::NewUmOrderResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_all_cm_conditional_orders(
            &self,
            _params: QueryAllCmConditionalOrdersParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::QueryAllCmConditionalOrdersResponseInner>>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"newClientStrategyId":"abc","strategyId":123445,"strategyStatus":"TRIGGERED","strategyType":"TRAILING_STOP_MARKET","origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSD","orderId":12123343534,"status":"NEW","bookTime":1566818724710,"updateTime":1566818724722,"triggerTime":1566818724750,"timeInForce":"GTC","type":"MARKET","activatePrice":"9020","priceRate":"0.3"}]"#).unwrap();
            let dummy_response: Vec<models::QueryAllCmConditionalOrdersResponseInner> =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into Vec<models::QueryAllCmConditionalOrdersResponseInner>",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_all_cm_orders(
            &self,
            _params: QueryAllCmOrdersParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::QueryAllCmOrdersResponseInner>>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"avgPrice":"0.0","clientOrderId":"abc","cumBase":"0","executedQty":"0","orderId":1917641,"origQty":"0.40","origType":"LIMIT","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSD_200925","pair":"BTCUSD","time":1579276756075,"timeInForce":"GTC","type":"LIMIT","updateTime":1579276756075}]"#).unwrap();
            let dummy_response: Vec<models::QueryAllCmOrdersResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::QueryAllCmOrdersResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_all_current_cm_open_conditional_orders(
            &self,
            _params: QueryAllCurrentCmOpenConditionalOrdersParams,
        ) -> anyhow::Result<
            RestApiResponse<Vec<models::QueryAllCurrentCmOpenConditionalOrdersResponseInner>>,
        > {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"newClientStrategyId":"abc","strategyId":123445,"strategyStatus":"NEW","strategyType":"TRAILING_STOP_MARKET","origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSD","bookTime":1566818724710,"updateTime":1566818724722,"timeInForce":"GTC","activatePrice":"9020","priceRate":"0.3"}]"#).unwrap();
            let dummy_response : Vec<models::QueryAllCurrentCmOpenConditionalOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryAllCurrentCmOpenConditionalOrdersResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_all_current_cm_open_orders(
            &self,
            _params: QueryAllCurrentCmOpenOrdersParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::QueryAllCmOrdersResponseInner>>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"avgPrice":"0.0","clientOrderId":"abc","cumBase":"0","executedQty":"0","orderId":1917641,"origQty":"0.40","origType":"LIMIT","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSD_200925","pair":"BTCUSD","time":1579276756075,"timeInForce":"GTC","type":"LIMIT","updateTime":1579276756075}]"#).unwrap();
            let dummy_response: Vec<models::QueryAllCmOrdersResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::QueryAllCmOrdersResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_all_current_um_open_conditional_orders(
            &self,
            _params: QueryAllCurrentUmOpenConditionalOrdersParams,
        ) -> anyhow::Result<
            RestApiResponse<Vec<models::QueryAllCurrentUmOpenConditionalOrdersResponseInner>>,
        > {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"newClientStrategyId":"abc","strategyId":123445,"strategyStatus":"NEW","strategyType":"TRAILING_STOP_MARKET","origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSDT","bookTime":1566818724710,"updateTime":1566818724722,"timeInForce":"GTC","activatePrice":"9020","priceRate":"0.3","selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}]"#).unwrap();
            let dummy_response : Vec<models::QueryAllCurrentUmOpenConditionalOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryAllCurrentUmOpenConditionalOrdersResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_all_current_um_open_orders(
            &self,
            _params: QueryAllCurrentUmOpenOrdersParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::QueryAllCurrentUmOpenOrdersResponseInner>>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"avgPrice":"0.00000","clientOrderId":"abc","cumQuote":"0","executedQty":"0","orderId":1917641,"origQty":"0.40","origType":"LIMIT","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSDT","time":1579276756075,"timeInForce":"GTC","type":"LIMIT","updateTime":1579276756075,"selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}]"#).unwrap();
            let dummy_response: Vec<models::QueryAllCurrentUmOpenOrdersResponseInner> =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into Vec<models::QueryAllCurrentUmOpenOrdersResponseInner>",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_all_margin_account_orders(
            &self,
            _params: QueryAllMarginAccountOrdersParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::QueryAllMarginAccountOrdersResponseInner>>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"clientOrderId":"D2KDy4DIeS56PvkM13f8cP","cummulativeQuoteQty":"0.00000000","executedQty":"0.00000000","icebergQty":"0.00000000","isWorking":false,"orderId":41295,"origQty":"5.31000000","price":"0.22500000","side":"SELL","status":"CANCELED","stopPrice":"0.18000000","symbol":"BNBBTC","time":1565769338806,"timeInForce":"GTC","type":"TAKE_PROFIT_LIMIT","updateTime":1565769342148,"accountId":152950866,"selfTradePreventionMode":"EXPIRE_TAKER","preventedMatchId":null,"preventedQuantity":null}]"#).unwrap();
            let dummy_response: Vec<models::QueryAllMarginAccountOrdersResponseInner> =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into Vec<models::QueryAllMarginAccountOrdersResponseInner>",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_all_um_conditional_orders(
            &self,
            _params: QueryAllUmConditionalOrdersParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::QueryAllUmConditionalOrdersResponseInner>>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"newClientStrategyId":"abc","strategyId":123445,"strategyStatus":"TRIGGERED","strategyType":"TRAILING_STOP_MARKET","origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSDT","orderId":12132343435,"status":"NEW","bookTime":1566818724710,"updateTime":1566818724722,"triggerTime":1566818724750,"timeInForce":"GTC","type":"MARKET","activatePrice":"9020","priceRate":"0.3","selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}]"#).unwrap();
            let dummy_response: Vec<models::QueryAllUmConditionalOrdersResponseInner> =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into Vec<models::QueryAllUmConditionalOrdersResponseInner>",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_all_um_orders(
            &self,
            _params: QueryAllUmOrdersParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::QueryAllCurrentUmOpenOrdersResponseInner>>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"avgPrice":"0.00000","clientOrderId":"abc","cumQuote":"0","executedQty":"0","orderId":1917641,"origQty":"0.40","origType":"LIMIT","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSDT","time":1579276756075,"timeInForce":"GTC","type":"LIMIT","updateTime":1579276756075,"selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}]"#).unwrap();
            let dummy_response: Vec<models::QueryAllCurrentUmOpenOrdersResponseInner> =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into Vec<models::QueryAllCurrentUmOpenOrdersResponseInner>",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_cm_conditional_order_history(
            &self,
            _params: QueryCmConditionalOrderHistoryParams,
        ) -> anyhow::Result<RestApiResponse<models::QueryCmConditionalOrderHistoryResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"newClientStrategyId":"abc","strategyId":123445,"strategyStatus":"TRIGGERED","strategyType":"TRAILING_STOP_MARKET","origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSD","orderId":12123343534,"status":"NEW","bookTime":1566818724710,"updateTime":1566818724722,"triggerTime":1566818724750,"timeInForce":"GTC","type":"MARKET","activatePrice":"9020","priceRate":"0.3","workingType":"CONTRACT_PRICE","priceProtect":false,"priceMatch":"NONE"}"#).unwrap();
            let dummy_response: models::QueryCmConditionalOrderHistoryResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::QueryCmConditionalOrderHistoryResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_cm_modify_order_history(
            &self,
            _params: QueryCmModifyOrderHistoryParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::QueryCmModifyOrderHistoryResponseInner>>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"amendmentId":5363,"symbol":"BTCUSD_PERP","pair":"BTCUSD","orderId":20072994037,"clientOrderId":"LJ9R4QZDihCaS8UAOOLpgW","time":1629184560899,"amendment":{"price":{"before":"30004","after":"30003.2"},"origQty":{"before":"1","after":"1"},"count":3}},{"amendmentId":5361,"symbol":"BTCUSD_PERP","pair":"BTCUSD","orderId":20072994037,"clientOrderId":"LJ9R4QZDihCaS8UAOOLpgW","time":1629184533946,"amendment":{"price":{"before":"30005","after":"30004"},"origQty":{"before":"1","after":"1"},"count":2}},{"amendmentId":5325,"symbol":"BTCUSD_PERP","pair":"BTCUSD","orderId":20072994037,"clientOrderId":"LJ9R4QZDihCaS8UAOOLpgW","time":1629182711787,"amendment":{"price":{"before":"30002","after":"30005"},"origQty":{"before":"1","after":"1"},"count":1}}]"#).unwrap();
            let dummy_response: Vec<models::QueryCmModifyOrderHistoryResponseInner> =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into Vec<models::QueryCmModifyOrderHistoryResponseInner>",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_cm_order(
            &self,
            _params: QueryCmOrderParams,
        ) -> anyhow::Result<RestApiResponse<models::QueryCmOrderResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"avgPrice":"0.0","clientOrderId":"abc","cumBase":"0","executedQty":"0","orderId":1917641,"origQty":"0.40","origType":"LIMIT","price":"0","reduceOnly":false,"side":"BUY","status":"NEW","symbol":"BTCUSD_200925","pair":"BTCUSD","positionSide":"SHORT","time":1579276756075,"timeInForce":"GTC","type":"LIMIT","updateTime":1579276756075}"#).unwrap();
            let dummy_response: models::QueryCmOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::QueryCmOrderResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_current_cm_open_conditional_order(
            &self,
            _params: QueryCurrentCmOpenConditionalOrderParams,
        ) -> anyhow::Result<RestApiResponse<models::QueryCurrentCmOpenConditionalOrderResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"newClientStrategyId":"abc","strategyId":123445,"strategyStatus":"NEW","strategyType":"TRAILING_STOP_MARKET","origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSD","bookTime":1566818724710,"updateTime":1566818724722,"timeInForce":"GTC","activatePrice":"9020","priceRate":"0.3"}"#).unwrap();
            let dummy_response: models::QueryCurrentCmOpenConditionalOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::QueryCurrentCmOpenConditionalOrderResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_current_cm_open_order(
            &self,
            _params: QueryCurrentCmOpenOrderParams,
        ) -> anyhow::Result<RestApiResponse<models::QueryCurrentCmOpenOrderResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"avgPrice":"0.0","clientOrderId":"abc","cumBase":"0","executedQty":"0","orderId":1917641,"origQty":"0.40","origType":"LIMIT","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSD_200925","pair":"BTCUSD","time":1579276756075,"timeInForce":"GTC","type":"LIMIT","updateTime":1579276756075}"#).unwrap();
            let dummy_response: models::QueryCurrentCmOpenOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::QueryCurrentCmOpenOrderResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_current_margin_open_order(
            &self,
            _params: QueryCurrentMarginOpenOrderParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::QueryCurrentMarginOpenOrderResponseInner>>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"clientOrderId":"qhcZw71gAkCCTv0t0k8LUK","cummulativeQuoteQty":"0.00000000","executedQty":"0.00000000","icebergQty":"0.00000000","isWorking":true,"orderId":211842552,"origQty":"0.30000000","price":"0.00475010","side":"SELL","status":"NEW","stopPrice":"0.00000000","symbol":"BNBBTC","time":1562040170089,"timeInForce":"GTC","type":"LIMIT","updateTime":1562040170089,"accountId":152950866,"selfTradePreventionMode":"EXPIRE_TAKER","preventedMatchId":null,"preventedQuantity":null}]"#).unwrap();
            let dummy_response: Vec<models::QueryCurrentMarginOpenOrderResponseInner> =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into Vec<models::QueryCurrentMarginOpenOrderResponseInner>",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_current_um_open_conditional_order(
            &self,
            _params: QueryCurrentUmOpenConditionalOrderParams,
        ) -> anyhow::Result<RestApiResponse<models::QueryCurrentUmOpenConditionalOrderResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"newClientStrategyId":"abc","strategyId":123445,"strategyStatus":"NEW","strategyType":"TRAILING_STOP_MARKET","origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSDT","bookTime":1566818724710,"updateTime":1566818724722,"timeInForce":"GTC","activatePrice":"9020","priceRate":"0.3","selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}"#).unwrap();
            let dummy_response: models::QueryCurrentUmOpenConditionalOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::QueryCurrentUmOpenConditionalOrderResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_current_um_open_order(
            &self,
            _params: QueryCurrentUmOpenOrderParams,
        ) -> anyhow::Result<RestApiResponse<models::QueryCurrentUmOpenOrderResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"avgPrice":"0.00000","clientOrderId":"abc","cumQuote":"0","executedQty":"0","orderId":1917641,"origQty":"0.40","origType":"LIMIT","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSDT","time":1579276756075,"timeInForce":"GTC","type":"LIMIT","updateTime":1579276756075,"selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}"#).unwrap();
            let dummy_response: models::QueryCurrentUmOpenOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::QueryCurrentUmOpenOrderResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_margin_account_order(
            &self,
            _params: QueryMarginAccountOrderParams,
        ) -> anyhow::Result<RestApiResponse<models::QueryMarginAccountOrderResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"clientOrderId":"ZwfQzuDIGpceVhKW5DvCmO","cummulativeQuoteQty":"0.00000000","executedQty":"0.00000000","icebergQty":"0.00000000","isWorking":true,"orderId":213205622,"origQty":"0.30000000","price":"0.00493630","side":"SELL","status":"NEW","stopPrice":"0.00000000","symbol":"BNBBTC","time":1562133008725,"timeInForce":"GTC","type":"LIMIT","updateTime":1562133008725,"accountId":152950866,"selfTradePreventionMode":"EXPIRE_TAKER","preventedMatchId":null,"preventedQuantity":null}"#).unwrap();
            let dummy_response: models::QueryMarginAccountOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::QueryMarginAccountOrderResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_margin_accounts_all_oco(
            &self,
            _params: QueryMarginAccountsAllOcoParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::QueryMarginAccountsAllOcoResponseInner>>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"orderListId":29,"contingencyType":"OCO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"amEEAXryFzFwYF1FeRpUoZ","transactionTime":1565245913483,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":4,"clientOrderId":"oD7aesZqjEGlZrbtRpy5zB"},{"symbol":"LTCBTC","orderId":5,"clientOrderId":"Jr1h6xirOxgeJOUuYQS7V3"}]},{"orderListId":28,"contingencyType":"OCO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"hG7hFNxJV6cZy3Ze4AUT4d","transactionTime":1565245913407,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":2,"clientOrderId":"j6lFOfbmFMRjTYA7rRJ0LP"},{"symbol":"LTCBTC","orderId":3,"clientOrderId":"z0KCjOdditiLS5ekAFtK81"}]}]"#).unwrap();
            let dummy_response: Vec<models::QueryMarginAccountsAllOcoResponseInner> =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into Vec<models::QueryMarginAccountsAllOcoResponseInner>",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_margin_accounts_oco(
            &self,
            _params: QueryMarginAccountsOcoParams,
        ) -> anyhow::Result<RestApiResponse<models::QueryMarginAccountsOcoResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"orderListId":27,"contingencyType":"OCO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"h2USkA5YQpaXHPIrkd96xE","transactionTime":1565245656253,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":4,"clientOrderId":"qD1gy3kc3Gx0rihm9Y3xwS"},{"symbol":"LTCBTC","orderId":5,"clientOrderId":"ARzZ9I00CPM8i3NhmU9Ega"}]}"#).unwrap();
            let dummy_response: models::QueryMarginAccountsOcoResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::QueryMarginAccountsOcoResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_margin_accounts_open_oco(
            &self,
            _params: QueryMarginAccountsOpenOcoParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::QueryMarginAccountsOpenOcoResponseInner>>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"orderListId":31,"contingencyType":"OCO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"wuB13fmulKj3YjdqWEcsnp","transactionTime":1565246080644,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":4,"clientOrderId":"r3EH2N76dHfLoSZWIUw1bT"},{"symbol":"LTCBTC","orderId":5,"clientOrderId":"Cv1SnyPD3qhqpbjpYEHbd2"}]}]"#).unwrap();
            let dummy_response: Vec<models::QueryMarginAccountsOpenOcoResponseInner> =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into Vec<models::QueryMarginAccountsOpenOcoResponseInner>",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_um_conditional_order_history(
            &self,
            _params: QueryUmConditionalOrderHistoryParams,
        ) -> anyhow::Result<RestApiResponse<models::QueryUmConditionalOrderHistoryResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"newClientStrategyId":"abc","strategyId":123445,"strategyStatus":"TRIGGERED","strategyType":"TRAILING_STOP_MARKET","origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSDT","orderId":12132343435,"status":"NEW","bookTime":1566818724710,"updateTime":1566818724722,"triggerTime":1566818724750,"timeInForce":"GTC","type":"MARKET","activatePrice":"9020","priceRate":"0.3","workingType":"CONTRACT_PRICE","priceProtect":false,"selfTradePreventionMode":"NONE","goodTillDate":0}"#).unwrap();
            let dummy_response: models::QueryUmConditionalOrderHistoryResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::QueryUmConditionalOrderHistoryResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_um_modify_order_history(
            &self,
            _params: QueryUmModifyOrderHistoryParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::QueryUmModifyOrderHistoryResponseInner>>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"amendmentId":5363,"symbol":"BTCUSDT","pair":"BTCUSDT","orderId":20072994037,"clientOrderId":"LJ9R4QZDihCaS8UAOOLpgW","time":1629184560899,"amendment":{"price":{"before":"30004","after":"30003.2"},"origQty":{"before":"1","after":"1"},"count":3},"priceMatch":"NONE"},{"amendmentId":5361,"symbol":"BTCUSDT","pair":"BTCUSDT","orderId":20072994037,"clientOrderId":"LJ9R4QZDihCaS8UAOOLpgW","time":1629184533946,"amendment":{"price":{"before":"30005","after":"30004"},"origQty":{"before":"1","after":"1"},"count":2},"priceMatch":"NONE"},{"amendmentId":5325,"symbol":"BTCUSDT","pair":"BTCUSDT","orderId":20072994037,"clientOrderId":"LJ9R4QZDihCaS8UAOOLpgW","time":1629182711787,"amendment":{"price":{"before":"30002","after":"30005"},"origQty":{"before":"1","after":"1"},"count":1},"priceMatch":"NONE"}]"#).unwrap();
            let dummy_response: Vec<models::QueryUmModifyOrderHistoryResponseInner> =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into Vec<models::QueryUmModifyOrderHistoryResponseInner>",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_um_order(
            &self,
            _params: QueryUmOrderParams,
        ) -> anyhow::Result<RestApiResponse<models::QueryUmOrderResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"avgPrice":"0.00000","clientOrderId":"abc","cumQuote":"0","executedQty":"0","orderId":1917641,"origQty":"0.40","origType":"LIMIT","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSDT","time":1579276756075,"timeInForce":"GTC","type":"LIMIT","updateTime":1579276756075,"selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}"#).unwrap();
            let dummy_response: models::QueryUmOrderResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::QueryUmOrderResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_users_cm_force_orders(
            &self,
            _params: QueryUsersCmForceOrdersParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::QueryUsersCmForceOrdersResponseInner>>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"orderId":165123080,"symbol":"BTCUSD_200925","pair":"BTCUSD","status":"FILLED","clientOrderId":"autoclose-1596542005017000006","price":"11326.9","avgPrice":"11326.9","origQty":"1","executedQty":"1","cumBase":"0.00882854","timeInForce":"IOC","type":"LIMIT","reduceOnly":false,"side":"SELL","positionSide":"BOTH","origType":"LIMIT","time":1596542005019,"updateTime":1596542005050}]"#).unwrap();
            let dummy_response: Vec<models::QueryUsersCmForceOrdersResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::QueryUsersCmForceOrdersResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_users_margin_force_orders(
            &self,
            _params: QueryUsersMarginForceOrdersParams,
        ) -> anyhow::Result<RestApiResponse<models::QueryUsersMarginForceOrdersResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"avgPrice":"0.00388359","executedQty":"31.39000000","orderId":180015097,"price":"0.00388110","qty":"31.39000000","side":"SELL","symbol":"BNBBTC","timeInForce":"GTC","updatedTime":1558941374745}],"total":1}"#).unwrap();
            let dummy_response: models::QueryUsersMarginForceOrdersResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::QueryUsersMarginForceOrdersResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn query_users_um_force_orders(
            &self,
            _params: QueryUsersUmForceOrdersParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::QueryUsersUmForceOrdersResponseInner>>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"orderId":6071832819,"symbol":"BTCUSDT","status":"FILLED","clientOrderId":"autoclose-1596107620040000020","price":"10871.09","avgPrice":"10913.21000","origQty":"0.001","executedQty":"0.001","cumQuote":"10.91321","timeInForce":"IOC","type":"LIMIT","reduceOnly":false,"side":"SELL","positionSide":"BOTH","origType":"LIMIT","time":1596107620044,"updateTime":1596107620087}]"#).unwrap();
            let dummy_response: Vec<models::QueryUsersUmForceOrdersResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::QueryUsersUmForceOrdersResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn toggle_bnb_burn_on_um_futures_trade(
            &self,
            _params: ToggleBnbBurnOnUmFuturesTradeParams,
        ) -> anyhow::Result<RestApiResponse<models::ToggleBnbBurnOnUmFuturesTradeResponse>>
        {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"code":200,"msg":"success"}"#).unwrap();
            let dummy_response: models::ToggleBnbBurnOnUmFuturesTradeResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::ToggleBnbBurnOnUmFuturesTradeResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn um_account_trade_list(
            &self,
            _params: UmAccountTradeListParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::UmAccountTradeListResponseInner>>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"symbol":"BTCUSDT","id":67880589,"orderId":270093109,"side":"SELL","price":"28511.00","qty":"0.010","realizedPnl":"2.58500000","quoteQty":"285.11000","commission":"-0.11404400","commissionAsset":"USDT","time":1680688557875,"buyer":false,"maker":false,"positionSide":"BOTH"}]"#).unwrap();
            let dummy_response: Vec<models::UmAccountTradeListResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::UmAccountTradeListResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn um_position_adl_quantile_estimation(
            &self,
            _params: UmPositionAdlQuantileEstimationParams,
        ) -> anyhow::Result<
            RestApiResponse<Vec<models::UmPositionAdlQuantileEstimationResponseInner>>,
        > {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"symbol":"ETHUSDT","adlQuantile":{"LONG":3,"SHORT":3,"HEDGE":0}},{"symbol":"BTCUSDT","adlQuantile":{"LONG":1,"SHORT":2,"BOTH":0}}]"#).unwrap();
            let dummy_response: Vec<models::UmPositionAdlQuantileEstimationResponseInner> =
                serde_json::from_value(resp_json.clone()).expect(
                    "should parse into Vec<models::UmPositionAdlQuantileEstimationResponseInner>",
                );

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }
    }

    #[test]
    fn cancel_all_cm_open_conditional_orders_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CancelAllCmOpenConditionalOrdersParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"code":"200","msg":"The operation of cancel all conditional open order is done."}"#).unwrap();
            let expected_response : models::CancelAllCmOpenConditionalOrdersResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::CancelAllCmOpenConditionalOrdersResponse");

            let resp = client.cancel_all_cm_open_conditional_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_all_cm_open_conditional_orders_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CancelAllCmOpenConditionalOrdersParams::builder("symbol_example".to_string(),).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"code":"200","msg":"The operation of cancel all conditional open order is done."}"#).unwrap();
            let expected_response : models::CancelAllCmOpenConditionalOrdersResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::CancelAllCmOpenConditionalOrdersResponse");

            let resp = client.cancel_all_cm_open_conditional_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_all_cm_open_conditional_orders_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params =
                CancelAllCmOpenConditionalOrdersParams::builder("symbol_example".to_string())
                    .build()
                    .unwrap();

            match client.cancel_all_cm_open_conditional_orders(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn cancel_all_cm_open_orders_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CancelAllCmOpenOrdersParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"code":200,"msg":"The operation of cancel all open order is done."}"#,
            )
            .unwrap();
            let expected_response: models::CancelAllCmOpenOrdersResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::CancelAllCmOpenOrdersResponse");

            let resp = client
                .cancel_all_cm_open_orders(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_all_cm_open_orders_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CancelAllCmOpenOrdersParams::builder("symbol_example".to_string())
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"code":200,"msg":"The operation of cancel all open order is done."}"#,
            )
            .unwrap();
            let expected_response: models::CancelAllCmOpenOrdersResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::CancelAllCmOpenOrdersResponse");

            let resp = client
                .cancel_all_cm_open_orders(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_all_cm_open_orders_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = CancelAllCmOpenOrdersParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.cancel_all_cm_open_orders(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn cancel_all_um_open_conditional_orders_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CancelAllUmOpenConditionalOrdersParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"code":"200","msg":"The operation of cancel all conditional open order is done."}"#).unwrap();
            let expected_response : models::CancelAllUmOpenConditionalOrdersResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::CancelAllUmOpenConditionalOrdersResponse");

            let resp = client.cancel_all_um_open_conditional_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_all_um_open_conditional_orders_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CancelAllUmOpenConditionalOrdersParams::builder("symbol_example".to_string(),).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"code":"200","msg":"The operation of cancel all conditional open order is done."}"#).unwrap();
            let expected_response : models::CancelAllUmOpenConditionalOrdersResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::CancelAllUmOpenConditionalOrdersResponse");

            let resp = client.cancel_all_um_open_conditional_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_all_um_open_conditional_orders_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params =
                CancelAllUmOpenConditionalOrdersParams::builder("symbol_example".to_string())
                    .build()
                    .unwrap();

            match client.cancel_all_um_open_conditional_orders(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn cancel_all_um_open_orders_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CancelAllUmOpenOrdersParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"code":200,"msg":"The operation of cancel all open order is done."}"#,
            )
            .unwrap();
            let expected_response: models::CancelAllUmOpenOrdersResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::CancelAllUmOpenOrdersResponse");

            let resp = client
                .cancel_all_um_open_orders(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_all_um_open_orders_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CancelAllUmOpenOrdersParams::builder("symbol_example".to_string())
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"code":200,"msg":"The operation of cancel all open order is done."}"#,
            )
            .unwrap();
            let expected_response: models::CancelAllUmOpenOrdersResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::CancelAllUmOpenOrdersResponse");

            let resp = client
                .cancel_all_um_open_orders(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_all_um_open_orders_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = CancelAllUmOpenOrdersParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.cancel_all_um_open_orders(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn cancel_cm_conditional_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CancelCmConditionalOrderParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"newClientStrategyId":"myOrder1","strategyId":123445,"strategyStatus":"CANCELED","strategyType":"TRAILING_STOP_MARKET","origQty":"11","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSD","timeInForce":"GTC","activatePrice":"9020","priceRate":"0.3","bookTime":1566818724710,"updateTime":1566818724722,"workingType":"CONTRACT_PRICE","priceProtect":false}"#).unwrap();
            let expected_response : models::CancelCmConditionalOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::CancelCmConditionalOrderResponse");

            let resp = client.cancel_cm_conditional_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_cm_conditional_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CancelCmConditionalOrderParams::builder("symbol_example".to_string(),).strategy_id(1).new_client_strategy_id("1".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"newClientStrategyId":"myOrder1","strategyId":123445,"strategyStatus":"CANCELED","strategyType":"TRAILING_STOP_MARKET","origQty":"11","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSD","timeInForce":"GTC","activatePrice":"9020","priceRate":"0.3","bookTime":1566818724710,"updateTime":1566818724722,"workingType":"CONTRACT_PRICE","priceProtect":false}"#).unwrap();
            let expected_response : models::CancelCmConditionalOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::CancelCmConditionalOrderResponse");

            let resp = client.cancel_cm_conditional_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_cm_conditional_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = CancelCmConditionalOrderParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.cancel_cm_conditional_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn cancel_cm_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CancelCmOrderParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"avgPrice":"0.0","clientOrderId":"myOrder1","cumQty":"0","cumBase":"0","executedQty":"0","orderId":283194212,"origQty":"2","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"CANCELED","symbol":"BTCUSD_200925","pair":"BTCUSD","timeInForce":"GTC","type":"LIMIT","updateTime":1571110484038}"#).unwrap();
            let expected_response : models::CancelCmOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::CancelCmOrderResponse");

            let resp = client.cancel_cm_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_cm_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CancelCmOrderParams::builder("symbol_example".to_string(),).order_id(1).orig_client_order_id("1".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"avgPrice":"0.0","clientOrderId":"myOrder1","cumQty":"0","cumBase":"0","executedQty":"0","orderId":283194212,"origQty":"2","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"CANCELED","symbol":"BTCUSD_200925","pair":"BTCUSD","timeInForce":"GTC","type":"LIMIT","updateTime":1571110484038}"#).unwrap();
            let expected_response : models::CancelCmOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::CancelCmOrderResponse");

            let resp = client.cancel_cm_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_cm_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = CancelCmOrderParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.cancel_cm_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn cancel_margin_account_all_open_orders_on_a_symbol_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CancelMarginAccountAllOpenOrdersOnASymbolParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"symbol":"BTCUSDT","origClientOrderId":"E6APeyTJvkMvLMYMqu1KQ4","orderId":11,"orderListId":-1,"clientOrderId":"pXLV6Hz6mprAcVYpVMTGgx","price":"0.089853","origQty":"0.178622","executedQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT","side":"BUY"},{"orderListId":1929,"contingencyType":"OCO","listStatusType":"ALL_DONE","listOrderStatus":"ALL_DONE","listClientOrderId":"2inzWQdDvZLHbbAmAozX2N","transactionTime":1585230948299,"symbol":"BTCUSDT","orders":[{"symbol":"BTCUSDT","orderId":20,"clientOrderId":"CwOOIPHSmYywx6jZX77TdL"},{"symbol":"BTCUSDT","orderId":21,"clientOrderId":"461cPg51vQjV3zIMOXNz39"}],"orderReports":[{"symbol":"BTCUSDT","origClientOrderId":"CwOOIPHSmYywx6jZX77TdL","orderId":20,"orderListId":1929,"clientOrderId":"pXLV6Hz6mprAcVYpVMTGgx","price":"0.668611","origQty":"0.690354","executedQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"CANCELED","timeInForce":"GTC","type":"STOP_LOSS_LIMIT","side":"BUY","stopPrice":"0.378131","icebergQty":"0.017083"},{"symbol":"BTCUSDT","origClientOrderId":"461cPg51vQjV3zIMOXNz39","orderId":21,"orderListId":1929,"clientOrderId":"pXLV6Hz6mprAcVYpVMTGgx","price":"0.008791","origQty":"0.690354","executedQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT_MAKER","side":"BUY","icebergQty":"0.639962"}]}]"#).unwrap();
            let expected_response : Vec<models::CancelMarginAccountAllOpenOrdersOnASymbolResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::CancelMarginAccountAllOpenOrdersOnASymbolResponseInner>");

            let resp = client.cancel_margin_account_all_open_orders_on_a_symbol(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_margin_account_all_open_orders_on_a_symbol_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CancelMarginAccountAllOpenOrdersOnASymbolParams::builder("symbol_example".to_string(),).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"symbol":"BTCUSDT","origClientOrderId":"E6APeyTJvkMvLMYMqu1KQ4","orderId":11,"orderListId":-1,"clientOrderId":"pXLV6Hz6mprAcVYpVMTGgx","price":"0.089853","origQty":"0.178622","executedQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT","side":"BUY"},{"orderListId":1929,"contingencyType":"OCO","listStatusType":"ALL_DONE","listOrderStatus":"ALL_DONE","listClientOrderId":"2inzWQdDvZLHbbAmAozX2N","transactionTime":1585230948299,"symbol":"BTCUSDT","orders":[{"symbol":"BTCUSDT","orderId":20,"clientOrderId":"CwOOIPHSmYywx6jZX77TdL"},{"symbol":"BTCUSDT","orderId":21,"clientOrderId":"461cPg51vQjV3zIMOXNz39"}],"orderReports":[{"symbol":"BTCUSDT","origClientOrderId":"CwOOIPHSmYywx6jZX77TdL","orderId":20,"orderListId":1929,"clientOrderId":"pXLV6Hz6mprAcVYpVMTGgx","price":"0.668611","origQty":"0.690354","executedQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"CANCELED","timeInForce":"GTC","type":"STOP_LOSS_LIMIT","side":"BUY","stopPrice":"0.378131","icebergQty":"0.017083"},{"symbol":"BTCUSDT","origClientOrderId":"461cPg51vQjV3zIMOXNz39","orderId":21,"orderListId":1929,"clientOrderId":"pXLV6Hz6mprAcVYpVMTGgx","price":"0.008791","origQty":"0.690354","executedQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT_MAKER","side":"BUY","icebergQty":"0.639962"}]}]"#).unwrap();
            let expected_response : Vec<models::CancelMarginAccountAllOpenOrdersOnASymbolResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::CancelMarginAccountAllOpenOrdersOnASymbolResponseInner>");

            let resp = client.cancel_margin_account_all_open_orders_on_a_symbol(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_margin_account_all_open_orders_on_a_symbol_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = CancelMarginAccountAllOpenOrdersOnASymbolParams::builder(
                "symbol_example".to_string(),
            )
            .build()
            .unwrap();

            match client
                .cancel_margin_account_all_open_orders_on_a_symbol(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn cancel_margin_account_oco_orders_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CancelMarginAccountOcoOrdersParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"orderListId":0,"contingencyType":"OCO","listStatusType":"ALL_DONE","listOrderStatus":"ALL_DONE","listClientOrderId":"C3wyj4WVEktd7u9aVBRXcN","transactionTime":1574040868128,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":2,"clientOrderId":"pO9ufTiFGg3nw2fOdgeOXa"},{"symbol":"LTCBTC","orderId":3,"clientOrderId":"TXOvglzXuaubXAaENpaRCB"}],"orderReports":[{"symbol":"LTCBTC","origClientOrderId":"pO9ufTiFGg3nw2fOdgeOXa","orderId":2,"orderListId":0,"clientOrderId":"unfWT8ig8i0uj6lPuYLez6","price":"1.00000000","origQty":"10.00000000","executedQty":"0.00000000","cummulativeQuoteQty":"0.00000000","status":"CANCELED","timeInForce":"GTC","type":"STOP_LOSS_LIMIT","side":"SELL","stopPrice":"1.00000000"},{"symbol":"LTCBTC","origClientOrderId":"TXOvglzXuaubXAaENpaRCB","orderId":3,"orderListId":0,"clientOrderId":"unfWT8ig8i0uj6lPuYLez6","price":"3.00000000","origQty":"10.00000000","executedQty":"0.00000000","cummulativeQuoteQty":"0.00000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT_MAKER","side":"SELL"}]}"#).unwrap();
            let expected_response : models::CancelMarginAccountOcoOrdersResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::CancelMarginAccountOcoOrdersResponse");

            let resp = client.cancel_margin_account_oco_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_margin_account_oco_orders_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CancelMarginAccountOcoOrdersParams::builder("symbol_example".to_string(),).order_list_id(1).list_client_order_id("1".to_string()).new_client_order_id("1".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"orderListId":0,"contingencyType":"OCO","listStatusType":"ALL_DONE","listOrderStatus":"ALL_DONE","listClientOrderId":"C3wyj4WVEktd7u9aVBRXcN","transactionTime":1574040868128,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":2,"clientOrderId":"pO9ufTiFGg3nw2fOdgeOXa"},{"symbol":"LTCBTC","orderId":3,"clientOrderId":"TXOvglzXuaubXAaENpaRCB"}],"orderReports":[{"symbol":"LTCBTC","origClientOrderId":"pO9ufTiFGg3nw2fOdgeOXa","orderId":2,"orderListId":0,"clientOrderId":"unfWT8ig8i0uj6lPuYLez6","price":"1.00000000","origQty":"10.00000000","executedQty":"0.00000000","cummulativeQuoteQty":"0.00000000","status":"CANCELED","timeInForce":"GTC","type":"STOP_LOSS_LIMIT","side":"SELL","stopPrice":"1.00000000"},{"symbol":"LTCBTC","origClientOrderId":"TXOvglzXuaubXAaENpaRCB","orderId":3,"orderListId":0,"clientOrderId":"unfWT8ig8i0uj6lPuYLez6","price":"3.00000000","origQty":"10.00000000","executedQty":"0.00000000","cummulativeQuoteQty":"0.00000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT_MAKER","side":"SELL"}]}"#).unwrap();
            let expected_response : models::CancelMarginAccountOcoOrdersResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::CancelMarginAccountOcoOrdersResponse");

            let resp = client.cancel_margin_account_oco_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_margin_account_oco_orders_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = CancelMarginAccountOcoOrdersParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.cancel_margin_account_oco_orders(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn cancel_margin_account_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CancelMarginAccountOrderParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"LTCBTC","orderId":28,"origClientOrderId":"myOrder1","clientOrderId":"cancelMyOrder1","price":"1.00000000","origQty":"10.00000000","executedQty":"8.00000000","cummulativeQuoteQty":"8.00000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT","side":"SELL"}"#).unwrap();
            let expected_response : models::CancelMarginAccountOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::CancelMarginAccountOrderResponse");

            let resp = client.cancel_margin_account_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_margin_account_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CancelMarginAccountOrderParams::builder("symbol_example".to_string(),).order_id(1).orig_client_order_id("1".to_string()).new_client_order_id("1".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"LTCBTC","orderId":28,"origClientOrderId":"myOrder1","clientOrderId":"cancelMyOrder1","price":"1.00000000","origQty":"10.00000000","executedQty":"8.00000000","cummulativeQuoteQty":"8.00000000","status":"CANCELED","timeInForce":"GTC","type":"LIMIT","side":"SELL"}"#).unwrap();
            let expected_response : models::CancelMarginAccountOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::CancelMarginAccountOrderResponse");

            let resp = client.cancel_margin_account_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_margin_account_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = CancelMarginAccountOrderParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.cancel_margin_account_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn cancel_um_conditional_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CancelUmConditionalOrderParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"newClientStrategyId":"myOrder1","strategyId":123445,"strategyStatus":"CANCELED","strategyType":"TRAILING_STOP_MARKET","origQty":"11","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSDT","timeInForce":"GTC","activatePrice":"9020","priceRate":"0.3","bookTime":1566818724710,"updateTime":1566818724722,"workingType":"CONTRACT_PRICE","priceProtect":false,"selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}"#).unwrap();
            let expected_response : models::CancelUmConditionalOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::CancelUmConditionalOrderResponse");

            let resp = client.cancel_um_conditional_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_um_conditional_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CancelUmConditionalOrderParams::builder("symbol_example".to_string(),).strategy_id(1).new_client_strategy_id("1".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"newClientStrategyId":"myOrder1","strategyId":123445,"strategyStatus":"CANCELED","strategyType":"TRAILING_STOP_MARKET","origQty":"11","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSDT","timeInForce":"GTC","activatePrice":"9020","priceRate":"0.3","bookTime":1566818724710,"updateTime":1566818724722,"workingType":"CONTRACT_PRICE","priceProtect":false,"selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}"#).unwrap();
            let expected_response : models::CancelUmConditionalOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::CancelUmConditionalOrderResponse");

            let resp = client.cancel_um_conditional_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_um_conditional_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = CancelUmConditionalOrderParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.cancel_um_conditional_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn cancel_um_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CancelUmOrderParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"avgPrice":"0.00000","clientOrderId":"myOrder1","cumQty":"0","cumQuote":"0","executedQty":"0","orderId":4611875134427365000,"origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"CANCELED","symbol":"BTCUSDT","timeInForce":"GTC","type":"LIMIT","updateTime":1571110484038,"selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}"#).unwrap();
            let expected_response : models::CancelUmOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::CancelUmOrderResponse");

            let resp = client.cancel_um_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_um_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CancelUmOrderParams::builder("symbol_example".to_string(),).order_id(1).orig_client_order_id("1".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"avgPrice":"0.00000","clientOrderId":"myOrder1","cumQty":"0","cumQuote":"0","executedQty":"0","orderId":4611875134427365000,"origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"CANCELED","symbol":"BTCUSDT","timeInForce":"GTC","type":"LIMIT","updateTime":1571110484038,"selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}"#).unwrap();
            let expected_response : models::CancelUmOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::CancelUmOrderResponse");

            let resp = client.cancel_um_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cancel_um_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = CancelUmOrderParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.cancel_um_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn cm_account_trade_list_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CmAccountTradeListParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"symbol":"BTCUSD_200626","id":6,"orderId":28,"pair":"BTCUSD","side":"SELL","price":"8800","qty":"1","realizedPnl":"0","marginAsset":"BTC","baseQty":"0.01136364","commission":"0.00000454","commissionAsset":"BTC","time":1590743483586,"positionSide":"BOTH","buyer":false,"maker":false}]"#).unwrap();
            let expected_response : Vec<models::CmAccountTradeListResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::CmAccountTradeListResponseInner>");

            let resp = client.cm_account_trade_list(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cm_account_trade_list_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CmAccountTradeListParams::builder().symbol("symbol_example".to_string()).pair("pair_example".to_string()).start_time(1623319461670).end_time(1641782889000).from_id(1).limit(100).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"symbol":"BTCUSD_200626","id":6,"orderId":28,"pair":"BTCUSD","side":"SELL","price":"8800","qty":"1","realizedPnl":"0","marginAsset":"BTC","baseQty":"0.01136364","commission":"0.00000454","commissionAsset":"BTC","time":1590743483586,"positionSide":"BOTH","buyer":false,"maker":false}]"#).unwrap();
            let expected_response : Vec<models::CmAccountTradeListResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::CmAccountTradeListResponseInner>");

            let resp = client.cm_account_trade_list(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cm_account_trade_list_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = CmAccountTradeListParams::builder().build().unwrap();

            match client.cm_account_trade_list(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn cm_position_adl_quantile_estimation_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CmPositionAdlQuantileEstimationParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"symbol":"BTCUSD_200925","adlQuantile":{"LONG":3,"SHORT":3,"HEDGE":0}},{"symbol":"BTCUSD_201225","adlQuantile":{"LONG":1,"SHORT":2,"BOTH":0}}]"#).unwrap();
            let expected_response : Vec<models::CmPositionAdlQuantileEstimationResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::CmPositionAdlQuantileEstimationResponseInner>");

            let resp = client.cm_position_adl_quantile_estimation(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cm_position_adl_quantile_estimation_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = CmPositionAdlQuantileEstimationParams::builder().symbol("symbol_example".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"symbol":"BTCUSD_200925","adlQuantile":{"LONG":3,"SHORT":3,"HEDGE":0}},{"symbol":"BTCUSD_201225","adlQuantile":{"LONG":1,"SHORT":2,"BOTH":0}}]"#).unwrap();
            let expected_response : Vec<models::CmPositionAdlQuantileEstimationResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::CmPositionAdlQuantileEstimationResponseInner>");

            let resp = client.cm_position_adl_quantile_estimation(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn cm_position_adl_quantile_estimation_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = CmPositionAdlQuantileEstimationParams::builder()
                .build()
                .unwrap();

            match client.cm_position_adl_quantile_estimation(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_um_futures_bnb_burn_status_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = GetUmFuturesBnbBurnStatusParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"feeBurn":true}"#).unwrap();
            let expected_response: models::GetUmFuturesBnbBurnStatusResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetUmFuturesBnbBurnStatusResponse");

            let resp = client
                .get_um_futures_bnb_burn_status(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_um_futures_bnb_burn_status_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = GetUmFuturesBnbBurnStatusParams::builder()
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"feeBurn":true}"#).unwrap();
            let expected_response: models::GetUmFuturesBnbBurnStatusResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::GetUmFuturesBnbBurnStatusResponse");

            let resp = client
                .get_um_futures_bnb_burn_status(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_um_futures_bnb_burn_status_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = GetUmFuturesBnbBurnStatusParams::builder().build().unwrap();

            match client.get_um_futures_bnb_burn_status(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn margin_account_borrow_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = MarginAccountBorrowParams::builder("asset_example".to_string(), dec!(1.0))
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"tranId":100000001}"#).unwrap();
            let expected_response: models::MarginAccountBorrowResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::MarginAccountBorrowResponse");

            let resp = client
                .margin_account_borrow(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn margin_account_borrow_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = MarginAccountBorrowParams::builder("asset_example".to_string(), dec!(1.0))
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"tranId":100000001}"#).unwrap();
            let expected_response: models::MarginAccountBorrowResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::MarginAccountBorrowResponse");

            let resp = client
                .margin_account_borrow(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn margin_account_borrow_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = MarginAccountBorrowParams::builder("asset_example".to_string(), dec!(1.0))
                .build()
                .unwrap();

            match client.margin_account_borrow(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn margin_account_new_oco_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = MarginAccountNewOcoParams::builder("symbol_example".to_string(),MarginAccountNewOcoSideEnum::Buy,dec!(1.0),dec!(1.0),dec!(1.0),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"orderListId":0,"contingencyType":"OCO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"JYVpp3F0f5CAG15DhtrqLp","transactionTime":1563417480525,"symbol":"LTCBTC","marginBuyBorrowAmount":"5","marginBuyBorrowAsset":"BTC","orders":[{"symbol":"LTCBTC","orderId":2,"clientOrderId":"Kk7sqHb9J6mJWTMDVW7Vos"},{"symbol":"LTCBTC","orderId":3,"clientOrderId":"xTXKaGYd4bluPVp78IVRvl"}],"orderReports":[{"symbol":"LTCBTC","orderId":2,"orderListId":0,"clientOrderId":"Kk7sqHb9J6mJWTMDVW7Vos","transactTime":1563417480525,"price":"0.000000","origQty":"0.624363","executedQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"NEW","timeInForce":"GTC","type":"STOP_LOSS","side":"BUY","stopPrice":"0.960664"},{"symbol":"LTCBTC","orderId":3,"orderListId":0,"clientOrderId":"xTXKaGYd4bluPVp78IVRvl","transactTime":1563417480525,"price":"0.036435","origQty":"0.624363","executedQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"NEW","timeInForce":"GTC","type":"LIMIT_MAKER","side":"BUY"}]}"#).unwrap();
            let expected_response : models::MarginAccountNewOcoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::MarginAccountNewOcoResponse");

            let resp = client.margin_account_new_oco(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn margin_account_new_oco_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = MarginAccountNewOcoParams::builder("symbol_example".to_string(),MarginAccountNewOcoSideEnum::Buy,dec!(1.0),dec!(1.0),dec!(1.0),).list_client_order_id("1".to_string()).limit_client_order_id("1".to_string()).limit_iceberg_qty(dec!(1.0)).stop_client_order_id("1".to_string()).stop_limit_price(dec!(1.0)).stop_iceberg_qty(dec!(1.0)).stop_limit_time_in_force(MarginAccountNewOcoStopLimitTimeInForceEnum::Gtc).new_order_resp_type(MarginAccountNewOcoNewOrderRespTypeEnum::Ack).side_effect_type(MarginAccountNewOcoSideEffectTypeEnum::NoSideEffect).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"orderListId":0,"contingencyType":"OCO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"JYVpp3F0f5CAG15DhtrqLp","transactionTime":1563417480525,"symbol":"LTCBTC","marginBuyBorrowAmount":"5","marginBuyBorrowAsset":"BTC","orders":[{"symbol":"LTCBTC","orderId":2,"clientOrderId":"Kk7sqHb9J6mJWTMDVW7Vos"},{"symbol":"LTCBTC","orderId":3,"clientOrderId":"xTXKaGYd4bluPVp78IVRvl"}],"orderReports":[{"symbol":"LTCBTC","orderId":2,"orderListId":0,"clientOrderId":"Kk7sqHb9J6mJWTMDVW7Vos","transactTime":1563417480525,"price":"0.000000","origQty":"0.624363","executedQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"NEW","timeInForce":"GTC","type":"STOP_LOSS","side":"BUY","stopPrice":"0.960664"},{"symbol":"LTCBTC","orderId":3,"orderListId":0,"clientOrderId":"xTXKaGYd4bluPVp78IVRvl","transactTime":1563417480525,"price":"0.036435","origQty":"0.624363","executedQty":"0.000000","cummulativeQuoteQty":"0.000000","status":"NEW","timeInForce":"GTC","type":"LIMIT_MAKER","side":"BUY"}]}"#).unwrap();
            let expected_response : models::MarginAccountNewOcoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::MarginAccountNewOcoResponse");

            let resp = client.margin_account_new_oco(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn margin_account_new_oco_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = MarginAccountNewOcoParams::builder(
                "symbol_example".to_string(),
                MarginAccountNewOcoSideEnum::Buy,
                dec!(1.0),
                dec!(1.0),
                dec!(1.0),
            )
            .build()
            .unwrap();

            match client.margin_account_new_oco(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn margin_account_repay_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = MarginAccountRepayParams::builder("asset_example".to_string(), dec!(1.0))
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"tranId":100000001}"#).unwrap();
            let expected_response: models::MarginAccountRepayResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::MarginAccountRepayResponse");

            let resp = client
                .margin_account_repay(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn margin_account_repay_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = MarginAccountRepayParams::builder("asset_example".to_string(), dec!(1.0))
                .recv_window(5000)
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"tranId":100000001}"#).unwrap();
            let expected_response: models::MarginAccountRepayResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::MarginAccountRepayResponse");

            let resp = client
                .margin_account_repay(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn margin_account_repay_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = MarginAccountRepayParams::builder("asset_example".to_string(), dec!(1.0))
                .build()
                .unwrap();

            match client.margin_account_repay(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn margin_account_repay_debt_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = MarginAccountRepayDebtParams::builder("asset_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"amount":"0.10000000","asset":"BNB","specifyRepayAssets":["USDT","BTC"],"updateTime":1636371437000,"success":true}"#).unwrap();
            let expected_response : models::MarginAccountRepayDebtResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::MarginAccountRepayDebtResponse");

            let resp = client.margin_account_repay_debt(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn margin_account_repay_debt_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = MarginAccountRepayDebtParams::builder("asset_example".to_string(),).amount("amount_example".to_string()).specify_repay_assets("specify_repay_assets_example".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"amount":"0.10000000","asset":"BNB","specifyRepayAssets":["USDT","BTC"],"updateTime":1636371437000,"success":true}"#).unwrap();
            let expected_response : models::MarginAccountRepayDebtResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::MarginAccountRepayDebtResponse");

            let resp = client.margin_account_repay_debt(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn margin_account_repay_debt_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = MarginAccountRepayDebtParams::builder("asset_example".to_string())
                .build()
                .unwrap();

            match client.margin_account_repay_debt(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn margin_account_trade_list_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = MarginAccountTradeListParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"commission":"0.00006000","commissionAsset":"BTC","id":34,"isBestMatch":true,"isBuyer":false,"isMaker":false,"orderId":39324,"price":"0.02000000","qty":"3.00000000","symbol":"BNBBTC","time":1561973357171}]"#).unwrap();
            let expected_response : Vec<models::MarginAccountTradeListResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::MarginAccountTradeListResponseInner>");

            let resp = client.margin_account_trade_list(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn margin_account_trade_list_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = MarginAccountTradeListParams::builder("symbol_example".to_string(),).order_id(1).start_time(1623319461670).end_time(1641782889000).from_id(1).limit(100).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"commission":"0.00006000","commissionAsset":"BTC","id":34,"isBestMatch":true,"isBuyer":false,"isMaker":false,"orderId":39324,"price":"0.02000000","qty":"3.00000000","symbol":"BNBBTC","time":1561973357171}]"#).unwrap();
            let expected_response : Vec<models::MarginAccountTradeListResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::MarginAccountTradeListResponseInner>");

            let resp = client.margin_account_trade_list(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn margin_account_trade_list_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = MarginAccountTradeListParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.margin_account_trade_list(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn modify_cm_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = ModifyCmOrderParams::builder("symbol_example".to_string(),ModifyCmOrderSideEnum::Buy,dec!(1.0),dec!(1.0),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"orderId":20072994037,"symbol":"BTCUSD_PERP","pair":"BTCUSD","status":"NEW","clientOrderId":"LJ9R4QZDihCaS8UAOOLpgW","price":"30005","avgPrice":"0.0","origQty":"1","executedQty":"0","cumQty":"0","cumBase":"0","timeInForce":"GTC","type":"LIMIT","reduceOnly":false,"side":"BUY","positionSide":"LONG","origType":"LIMIT","updateTime":1629182711600}"#).unwrap();
            let expected_response : models::ModifyCmOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::ModifyCmOrderResponse");

            let resp = client.modify_cm_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn modify_cm_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = ModifyCmOrderParams::builder("symbol_example".to_string(),ModifyCmOrderSideEnum::Buy,dec!(1.0),dec!(1.0),).order_id(1).orig_client_order_id("1".to_string()).price_match(ModifyCmOrderPriceMatchEnum::None).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"orderId":20072994037,"symbol":"BTCUSD_PERP","pair":"BTCUSD","status":"NEW","clientOrderId":"LJ9R4QZDihCaS8UAOOLpgW","price":"30005","avgPrice":"0.0","origQty":"1","executedQty":"0","cumQty":"0","cumBase":"0","timeInForce":"GTC","type":"LIMIT","reduceOnly":false,"side":"BUY","positionSide":"LONG","origType":"LIMIT","updateTime":1629182711600}"#).unwrap();
            let expected_response : models::ModifyCmOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::ModifyCmOrderResponse");

            let resp = client.modify_cm_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn modify_cm_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = ModifyCmOrderParams::builder(
                "symbol_example".to_string(),
                ModifyCmOrderSideEnum::Buy,
                dec!(1.0),
                dec!(1.0),
            )
            .build()
            .unwrap();

            match client.modify_cm_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn modify_um_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = ModifyUmOrderParams::builder("symbol_example".to_string(),ModifyUmOrderSideEnum::Buy,dec!(1.0),dec!(1.0),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"orderId":20072994037,"symbol":"BTCUSDT","status":"NEW","clientOrderId":"LJ9R4QZDihCaS8UAOOLpgW","price":"30005","avgPrice":"0.0","origQty":"1","executedQty":"0","cumQty":"0","cumQuote":"0","timeInForce":"GTC","type":"LIMIT","reduceOnly":false,"side":"BUY","positionSide":"LONG","origType":"LIMIT","selfTradePreventionMode":"NONE","goodTillDate":0,"updateTime":1629182711600,"priceMatch":"NONE"}"#).unwrap();
            let expected_response : models::ModifyUmOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::ModifyUmOrderResponse");

            let resp = client.modify_um_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn modify_um_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = ModifyUmOrderParams::builder("symbol_example".to_string(),ModifyUmOrderSideEnum::Buy,dec!(1.0),dec!(1.0),).order_id(1).orig_client_order_id("1".to_string()).price_match(ModifyUmOrderPriceMatchEnum::None).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"orderId":20072994037,"symbol":"BTCUSDT","status":"NEW","clientOrderId":"LJ9R4QZDihCaS8UAOOLpgW","price":"30005","avgPrice":"0.0","origQty":"1","executedQty":"0","cumQty":"0","cumQuote":"0","timeInForce":"GTC","type":"LIMIT","reduceOnly":false,"side":"BUY","positionSide":"LONG","origType":"LIMIT","selfTradePreventionMode":"NONE","goodTillDate":0,"updateTime":1629182711600,"priceMatch":"NONE"}"#).unwrap();
            let expected_response : models::ModifyUmOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::ModifyUmOrderResponse");

            let resp = client.modify_um_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn modify_um_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = ModifyUmOrderParams::builder(
                "symbol_example".to_string(),
                ModifyUmOrderSideEnum::Buy,
                dec!(1.0),
                dec!(1.0),
            )
            .build()
            .unwrap();

            match client.modify_um_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn new_cm_conditional_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = NewCmConditionalOrderParams::builder("symbol_example".to_string(),NewCmConditionalOrderSideEnum::Buy,NewCmConditionalOrderStrategyTypeEnum::Stop,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"newClientStrategyId":"testOrder","strategyId":123445,"strategyStatus":"NEW","strategyType":"TRAILING_STOP_MARKET","origQty":"10","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSD_200925","pair":"BTCUSD","timeInForce":"GTC","activatePrice":"9020","priceRate":"0.3","bookTime":1566818724710,"updateTime":1566818724722,"workingType":"CONTRACT_PRICE","priceProtect":false}"#).unwrap();
            let expected_response : models::NewCmConditionalOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::NewCmConditionalOrderResponse");

            let resp = client.new_cm_conditional_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn new_cm_conditional_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = NewCmConditionalOrderParams::builder("symbol_example".to_string(),NewCmConditionalOrderSideEnum::Buy,NewCmConditionalOrderStrategyTypeEnum::Stop,).position_side(NewCmConditionalOrderPositionSideEnum::Both).time_in_force(NewCmConditionalOrderTimeInForceEnum::Gtc).quantity(dec!(1.0)).reduce_only("false".to_string()).price(dec!(1.0)).working_type(NewCmConditionalOrderWorkingTypeEnum::MarkPrice).price_protect("false".to_string()).new_client_strategy_id("1".to_string()).stop_price(dec!(1.0)).activation_price(dec!(1.0)).callback_rate(dec!(1.0)).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"newClientStrategyId":"testOrder","strategyId":123445,"strategyStatus":"NEW","strategyType":"TRAILING_STOP_MARKET","origQty":"10","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSD_200925","pair":"BTCUSD","timeInForce":"GTC","activatePrice":"9020","priceRate":"0.3","bookTime":1566818724710,"updateTime":1566818724722,"workingType":"CONTRACT_PRICE","priceProtect":false}"#).unwrap();
            let expected_response : models::NewCmConditionalOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::NewCmConditionalOrderResponse");

            let resp = client.new_cm_conditional_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn new_cm_conditional_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = NewCmConditionalOrderParams::builder(
                "symbol_example".to_string(),
                NewCmConditionalOrderSideEnum::Buy,
                NewCmConditionalOrderStrategyTypeEnum::Stop,
            )
            .build()
            .unwrap();

            match client.new_cm_conditional_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn new_cm_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = NewCmOrderParams::builder("symbol_example".to_string(),NewCmOrderSideEnum::Buy,NewCmOrderTypeEnum::Limit,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"clientOrderId":"testOrder","cumQty":"0","cumBase":"0","executedQty":"0","orderId":22542179,"avgPrice":"0.0","origQty":"10","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSD_200925","pair":"BTCUSD","timeInForce":"GTC","type":"MARKET","updateTime":1566818724722}"#).unwrap();
            let expected_response : models::NewCmOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::NewCmOrderResponse");

            let resp = client.new_cm_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn new_cm_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = NewCmOrderParams::builder("symbol_example".to_string(),NewCmOrderSideEnum::Buy,NewCmOrderTypeEnum::Limit,).position_side(NewCmOrderPositionSideEnum::Both).time_in_force(NewCmOrderTimeInForceEnum::Gtc).quantity(dec!(1.0)).reduce_only("false".to_string()).price(dec!(1.0)).price_match(NewCmOrderPriceMatchEnum::None).new_client_order_id("1".to_string()).new_order_resp_type(NewCmOrderNewOrderRespTypeEnum::Ack).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"clientOrderId":"testOrder","cumQty":"0","cumBase":"0","executedQty":"0","orderId":22542179,"avgPrice":"0.0","origQty":"10","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSD_200925","pair":"BTCUSD","timeInForce":"GTC","type":"MARKET","updateTime":1566818724722}"#).unwrap();
            let expected_response : models::NewCmOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::NewCmOrderResponse");

            let resp = client.new_cm_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn new_cm_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = NewCmOrderParams::builder(
                "symbol_example".to_string(),
                NewCmOrderSideEnum::Buy,
                NewCmOrderTypeEnum::Limit,
            )
            .build()
            .unwrap();

            match client.new_cm_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn new_margin_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = NewMarginOrderParams::builder("symbol_example".to_string(),NewMarginOrderSideEnum::Buy,NewMarginOrderTypeEnum::Limit,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"BTCUSDT","orderId":28,"clientOrderId":"6gCrw2kRUAF9CvJDGP16IP","transactTime":1507725176595,"price":"1.00000000","origQty":"10.00000000","executedQty":"10.00000000","cummulativeQuoteQty":"10.00000000","status":"FILLED","timeInForce":"GTC","type":"MARKET","side":"SELL","marginBuyBorrowAmount":"5","marginBuyBorrowAsset":"BTC","fills":[{"price":"4000.00000000","qty":"1.00000000","commission":"4.00000000","commissionAsset":"USDT"},{"price":"3999.00000000","qty":"5.00000000","commission":"19.99500000","commissionAsset":"USDT"}]}"#).unwrap();
            let expected_response : models::NewMarginOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::NewMarginOrderResponse");

            let resp = client.new_margin_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn new_margin_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = NewMarginOrderParams::builder("symbol_example".to_string(),NewMarginOrderSideEnum::Buy,NewMarginOrderTypeEnum::Limit,).quantity(dec!(1.0)).quote_order_qty(dec!(1.0)).price(dec!(1.0)).stop_price(dec!(1.0)).new_client_order_id("1".to_string()).new_order_resp_type(NewMarginOrderNewOrderRespTypeEnum::Ack).iceberg_qty(dec!(1.0)).side_effect_type(NewMarginOrderSideEffectTypeEnum::NoSideEffect).time_in_force(NewMarginOrderTimeInForceEnum::Gtc).self_trade_prevention_mode(NewMarginOrderSelfTradePreventionModeEnum::None).auto_repay_at_cancel(true).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"BTCUSDT","orderId":28,"clientOrderId":"6gCrw2kRUAF9CvJDGP16IP","transactTime":1507725176595,"price":"1.00000000","origQty":"10.00000000","executedQty":"10.00000000","cummulativeQuoteQty":"10.00000000","status":"FILLED","timeInForce":"GTC","type":"MARKET","side":"SELL","marginBuyBorrowAmount":"5","marginBuyBorrowAsset":"BTC","fills":[{"price":"4000.00000000","qty":"1.00000000","commission":"4.00000000","commissionAsset":"USDT"},{"price":"3999.00000000","qty":"5.00000000","commission":"19.99500000","commissionAsset":"USDT"}]}"#).unwrap();
            let expected_response : models::NewMarginOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::NewMarginOrderResponse");

            let resp = client.new_margin_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn new_margin_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = NewMarginOrderParams::builder(
                "symbol_example".to_string(),
                NewMarginOrderSideEnum::Buy,
                NewMarginOrderTypeEnum::Limit,
            )
            .build()
            .unwrap();

            match client.new_margin_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn new_um_conditional_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = NewUmConditionalOrderParams::builder("symbol_example".to_string(),NewUmConditionalOrderSideEnum::Buy,NewUmConditionalOrderStrategyTypeEnum::Stop,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"newClientStrategyId":"testOrder","strategyId":123445,"strategyStatus":"NEW","strategyType":"TRAILING_STOP_MARKET","origQty":"10","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSDT","timeInForce":"GTD","activatePrice":"9020","priceRate":"0.3","bookTime":1566818724710,"updateTime":1566818724722,"workingType":"CONTRACT_PRICE","priceProtect":false,"selfTradePreventionMode":"NONE","goodTillDate":1693207680000,"priceMatch":"NONE"}"#).unwrap();
            let expected_response : models::NewUmConditionalOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::NewUmConditionalOrderResponse");

            let resp = client.new_um_conditional_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn new_um_conditional_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = NewUmConditionalOrderParams::builder("symbol_example".to_string(),NewUmConditionalOrderSideEnum::Buy,NewUmConditionalOrderStrategyTypeEnum::Stop,).position_side(NewUmConditionalOrderPositionSideEnum::Both).time_in_force(NewUmConditionalOrderTimeInForceEnum::Gtc).quantity(dec!(1.0)).reduce_only("false".to_string()).price(dec!(1.0)).working_type(NewUmConditionalOrderWorkingTypeEnum::MarkPrice).price_protect("false".to_string()).new_client_strategy_id("1".to_string()).stop_price(dec!(1.0)).activation_price(dec!(1.0)).callback_rate(dec!(1.0)).price_match(NewUmConditionalOrderPriceMatchEnum::None).self_trade_prevention_mode(NewUmConditionalOrderSelfTradePreventionModeEnum::None).good_till_date(789).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"newClientStrategyId":"testOrder","strategyId":123445,"strategyStatus":"NEW","strategyType":"TRAILING_STOP_MARKET","origQty":"10","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSDT","timeInForce":"GTD","activatePrice":"9020","priceRate":"0.3","bookTime":1566818724710,"updateTime":1566818724722,"workingType":"CONTRACT_PRICE","priceProtect":false,"selfTradePreventionMode":"NONE","goodTillDate":1693207680000,"priceMatch":"NONE"}"#).unwrap();
            let expected_response : models::NewUmConditionalOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::NewUmConditionalOrderResponse");

            let resp = client.new_um_conditional_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn new_um_conditional_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = NewUmConditionalOrderParams::builder(
                "symbol_example".to_string(),
                NewUmConditionalOrderSideEnum::Buy,
                NewUmConditionalOrderStrategyTypeEnum::Stop,
            )
            .build()
            .unwrap();

            match client.new_um_conditional_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn new_um_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = NewUmOrderParams::builder("symbol_example".to_string(),NewUmOrderSideEnum::Buy,NewUmOrderTypeEnum::Limit,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"clientOrderId":"testOrder","cumQty":"0","cumQuote":"0","executedQty":"0","orderId":22542179,"avgPrice":"0.00000","origQty":"10","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSDT","timeInForce":"GTD","type":"MARKET","selfTradePreventionMode":"NONE","goodTillDate":1693207680000,"updateTime":1566818724722,"priceMatch":"NONE"}"#).unwrap();
            let expected_response : models::NewUmOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::NewUmOrderResponse");

            let resp = client.new_um_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn new_um_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = NewUmOrderParams::builder("symbol_example".to_string(),NewUmOrderSideEnum::Buy,NewUmOrderTypeEnum::Limit,).position_side(NewUmOrderPositionSideEnum::Both).time_in_force(NewUmOrderTimeInForceEnum::Gtc).quantity(dec!(1.0)).reduce_only("false".to_string()).price(dec!(1.0)).new_client_order_id("1".to_string()).new_order_resp_type(NewUmOrderNewOrderRespTypeEnum::Ack).price_match(NewUmOrderPriceMatchEnum::None).self_trade_prevention_mode(NewUmOrderSelfTradePreventionModeEnum::None).good_till_date(789).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"clientOrderId":"testOrder","cumQty":"0","cumQuote":"0","executedQty":"0","orderId":22542179,"avgPrice":"0.00000","origQty":"10","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSDT","timeInForce":"GTD","type":"MARKET","selfTradePreventionMode":"NONE","goodTillDate":1693207680000,"updateTime":1566818724722,"priceMatch":"NONE"}"#).unwrap();
            let expected_response : models::NewUmOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::NewUmOrderResponse");

            let resp = client.new_um_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn new_um_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = NewUmOrderParams::builder(
                "symbol_example".to_string(),
                NewUmOrderSideEnum::Buy,
                NewUmOrderTypeEnum::Limit,
            )
            .build()
            .unwrap();

            match client.new_um_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_all_cm_conditional_orders_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryAllCmConditionalOrdersParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"newClientStrategyId":"abc","strategyId":123445,"strategyStatus":"TRIGGERED","strategyType":"TRAILING_STOP_MARKET","origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSD","orderId":12123343534,"status":"NEW","bookTime":1566818724710,"updateTime":1566818724722,"triggerTime":1566818724750,"timeInForce":"GTC","type":"MARKET","activatePrice":"9020","priceRate":"0.3"}]"#).unwrap();
            let expected_response : Vec<models::QueryAllCmConditionalOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryAllCmConditionalOrdersResponseInner>");

            let resp = client.query_all_cm_conditional_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_all_cm_conditional_orders_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryAllCmConditionalOrdersParams::builder().symbol("symbol_example".to_string()).strategy_id(1).start_time(1623319461670).end_time(1641782889000).limit(100).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"newClientStrategyId":"abc","strategyId":123445,"strategyStatus":"TRIGGERED","strategyType":"TRAILING_STOP_MARKET","origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSD","orderId":12123343534,"status":"NEW","bookTime":1566818724710,"updateTime":1566818724722,"triggerTime":1566818724750,"timeInForce":"GTC","type":"MARKET","activatePrice":"9020","priceRate":"0.3"}]"#).unwrap();
            let expected_response : Vec<models::QueryAllCmConditionalOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryAllCmConditionalOrdersResponseInner>");

            let resp = client.query_all_cm_conditional_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_all_cm_conditional_orders_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = QueryAllCmConditionalOrdersParams::builder()
                .build()
                .unwrap();

            match client.query_all_cm_conditional_orders(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_all_cm_orders_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryAllCmOrdersParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"avgPrice":"0.0","clientOrderId":"abc","cumBase":"0","executedQty":"0","orderId":1917641,"origQty":"0.40","origType":"LIMIT","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSD_200925","pair":"BTCUSD","time":1579276756075,"timeInForce":"GTC","type":"LIMIT","updateTime":1579276756075}]"#).unwrap();
            let expected_response : Vec<models::QueryAllCmOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryAllCmOrdersResponseInner>");

            let resp = client.query_all_cm_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_all_cm_orders_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryAllCmOrdersParams::builder("symbol_example".to_string(),).pair("pair_example".to_string()).order_id(1).start_time(1623319461670).end_time(1641782889000).limit(100).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"avgPrice":"0.0","clientOrderId":"abc","cumBase":"0","executedQty":"0","orderId":1917641,"origQty":"0.40","origType":"LIMIT","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSD_200925","pair":"BTCUSD","time":1579276756075,"timeInForce":"GTC","type":"LIMIT","updateTime":1579276756075}]"#).unwrap();
            let expected_response : Vec<models::QueryAllCmOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryAllCmOrdersResponseInner>");

            let resp = client.query_all_cm_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_all_cm_orders_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = QueryAllCmOrdersParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.query_all_cm_orders(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_all_current_cm_open_conditional_orders_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryAllCurrentCmOpenConditionalOrdersParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"newClientStrategyId":"abc","strategyId":123445,"strategyStatus":"NEW","strategyType":"TRAILING_STOP_MARKET","origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSD","bookTime":1566818724710,"updateTime":1566818724722,"timeInForce":"GTC","activatePrice":"9020","priceRate":"0.3"}]"#).unwrap();
            let expected_response : Vec<models::QueryAllCurrentCmOpenConditionalOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryAllCurrentCmOpenConditionalOrdersResponseInner>");

            let resp = client.query_all_current_cm_open_conditional_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_all_current_cm_open_conditional_orders_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryAllCurrentCmOpenConditionalOrdersParams::builder().symbol("symbol_example".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"newClientStrategyId":"abc","strategyId":123445,"strategyStatus":"NEW","strategyType":"TRAILING_STOP_MARKET","origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSD","bookTime":1566818724710,"updateTime":1566818724722,"timeInForce":"GTC","activatePrice":"9020","priceRate":"0.3"}]"#).unwrap();
            let expected_response : Vec<models::QueryAllCurrentCmOpenConditionalOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryAllCurrentCmOpenConditionalOrdersResponseInner>");

            let resp = client.query_all_current_cm_open_conditional_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_all_current_cm_open_conditional_orders_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = QueryAllCurrentCmOpenConditionalOrdersParams::builder()
                .build()
                .unwrap();

            match client
                .query_all_current_cm_open_conditional_orders(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_all_current_cm_open_orders_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryAllCurrentCmOpenOrdersParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"avgPrice":"0.0","clientOrderId":"abc","cumBase":"0","executedQty":"0","orderId":1917641,"origQty":"0.40","origType":"LIMIT","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSD_200925","pair":"BTCUSD","time":1579276756075,"timeInForce":"GTC","type":"LIMIT","updateTime":1579276756075}]"#).unwrap();
            let expected_response : Vec<models::QueryAllCmOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryAllCmOrdersResponseInner>");

            let resp = client.query_all_current_cm_open_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_all_current_cm_open_orders_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryAllCurrentCmOpenOrdersParams::builder().symbol("symbol_example".to_string()).pair("pair_example".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"avgPrice":"0.0","clientOrderId":"abc","cumBase":"0","executedQty":"0","orderId":1917641,"origQty":"0.40","origType":"LIMIT","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSD_200925","pair":"BTCUSD","time":1579276756075,"timeInForce":"GTC","type":"LIMIT","updateTime":1579276756075}]"#).unwrap();
            let expected_response : Vec<models::QueryAllCmOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryAllCmOrdersResponseInner>");

            let resp = client.query_all_current_cm_open_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_all_current_cm_open_orders_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = QueryAllCurrentCmOpenOrdersParams::builder()
                .build()
                .unwrap();

            match client.query_all_current_cm_open_orders(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_all_current_um_open_conditional_orders_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryAllCurrentUmOpenConditionalOrdersParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"newClientStrategyId":"abc","strategyId":123445,"strategyStatus":"NEW","strategyType":"TRAILING_STOP_MARKET","origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSDT","bookTime":1566818724710,"updateTime":1566818724722,"timeInForce":"GTC","activatePrice":"9020","priceRate":"0.3","selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}]"#).unwrap();
            let expected_response : Vec<models::QueryAllCurrentUmOpenConditionalOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryAllCurrentUmOpenConditionalOrdersResponseInner>");

            let resp = client.query_all_current_um_open_conditional_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_all_current_um_open_conditional_orders_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryAllCurrentUmOpenConditionalOrdersParams::builder().symbol("symbol_example".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"newClientStrategyId":"abc","strategyId":123445,"strategyStatus":"NEW","strategyType":"TRAILING_STOP_MARKET","origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSDT","bookTime":1566818724710,"updateTime":1566818724722,"timeInForce":"GTC","activatePrice":"9020","priceRate":"0.3","selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}]"#).unwrap();
            let expected_response : Vec<models::QueryAllCurrentUmOpenConditionalOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryAllCurrentUmOpenConditionalOrdersResponseInner>");

            let resp = client.query_all_current_um_open_conditional_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_all_current_um_open_conditional_orders_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = QueryAllCurrentUmOpenConditionalOrdersParams::builder()
                .build()
                .unwrap();

            match client
                .query_all_current_um_open_conditional_orders(params)
                .await
            {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_all_current_um_open_orders_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryAllCurrentUmOpenOrdersParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"avgPrice":"0.00000","clientOrderId":"abc","cumQuote":"0","executedQty":"0","orderId":1917641,"origQty":"0.40","origType":"LIMIT","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSDT","time":1579276756075,"timeInForce":"GTC","type":"LIMIT","updateTime":1579276756075,"selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}]"#).unwrap();
            let expected_response : Vec<models::QueryAllCurrentUmOpenOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryAllCurrentUmOpenOrdersResponseInner>");

            let resp = client.query_all_current_um_open_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_all_current_um_open_orders_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryAllCurrentUmOpenOrdersParams::builder().symbol("symbol_example".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"avgPrice":"0.00000","clientOrderId":"abc","cumQuote":"0","executedQty":"0","orderId":1917641,"origQty":"0.40","origType":"LIMIT","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSDT","time":1579276756075,"timeInForce":"GTC","type":"LIMIT","updateTime":1579276756075,"selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}]"#).unwrap();
            let expected_response : Vec<models::QueryAllCurrentUmOpenOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryAllCurrentUmOpenOrdersResponseInner>");

            let resp = client.query_all_current_um_open_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_all_current_um_open_orders_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = QueryAllCurrentUmOpenOrdersParams::builder()
                .build()
                .unwrap();

            match client.query_all_current_um_open_orders(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_all_margin_account_orders_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryAllMarginAccountOrdersParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"clientOrderId":"D2KDy4DIeS56PvkM13f8cP","cummulativeQuoteQty":"0.00000000","executedQty":"0.00000000","icebergQty":"0.00000000","isWorking":false,"orderId":41295,"origQty":"5.31000000","price":"0.22500000","side":"SELL","status":"CANCELED","stopPrice":"0.18000000","symbol":"BNBBTC","time":1565769338806,"timeInForce":"GTC","type":"TAKE_PROFIT_LIMIT","updateTime":1565769342148,"accountId":152950866,"selfTradePreventionMode":"EXPIRE_TAKER","preventedMatchId":null,"preventedQuantity":null}]"#).unwrap();
            let expected_response : Vec<models::QueryAllMarginAccountOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryAllMarginAccountOrdersResponseInner>");

            let resp = client.query_all_margin_account_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_all_margin_account_orders_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryAllMarginAccountOrdersParams::builder("symbol_example".to_string(),).order_id(1).start_time(1623319461670).end_time(1641782889000).limit(100).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"clientOrderId":"D2KDy4DIeS56PvkM13f8cP","cummulativeQuoteQty":"0.00000000","executedQty":"0.00000000","icebergQty":"0.00000000","isWorking":false,"orderId":41295,"origQty":"5.31000000","price":"0.22500000","side":"SELL","status":"CANCELED","stopPrice":"0.18000000","symbol":"BNBBTC","time":1565769338806,"timeInForce":"GTC","type":"TAKE_PROFIT_LIMIT","updateTime":1565769342148,"accountId":152950866,"selfTradePreventionMode":"EXPIRE_TAKER","preventedMatchId":null,"preventedQuantity":null}]"#).unwrap();
            let expected_response : Vec<models::QueryAllMarginAccountOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryAllMarginAccountOrdersResponseInner>");

            let resp = client.query_all_margin_account_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_all_margin_account_orders_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = QueryAllMarginAccountOrdersParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.query_all_margin_account_orders(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_all_um_conditional_orders_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryAllUmConditionalOrdersParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"newClientStrategyId":"abc","strategyId":123445,"strategyStatus":"TRIGGERED","strategyType":"TRAILING_STOP_MARKET","origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSDT","orderId":12132343435,"status":"NEW","bookTime":1566818724710,"updateTime":1566818724722,"triggerTime":1566818724750,"timeInForce":"GTC","type":"MARKET","activatePrice":"9020","priceRate":"0.3","selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}]"#).unwrap();
            let expected_response : Vec<models::QueryAllUmConditionalOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryAllUmConditionalOrdersResponseInner>");

            let resp = client.query_all_um_conditional_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_all_um_conditional_orders_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryAllUmConditionalOrdersParams::builder().symbol("symbol_example".to_string()).strategy_id(1).start_time(1623319461670).end_time(1641782889000).limit(100).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"newClientStrategyId":"abc","strategyId":123445,"strategyStatus":"TRIGGERED","strategyType":"TRAILING_STOP_MARKET","origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSDT","orderId":12132343435,"status":"NEW","bookTime":1566818724710,"updateTime":1566818724722,"triggerTime":1566818724750,"timeInForce":"GTC","type":"MARKET","activatePrice":"9020","priceRate":"0.3","selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}]"#).unwrap();
            let expected_response : Vec<models::QueryAllUmConditionalOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryAllUmConditionalOrdersResponseInner>");

            let resp = client.query_all_um_conditional_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_all_um_conditional_orders_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = QueryAllUmConditionalOrdersParams::builder()
                .build()
                .unwrap();

            match client.query_all_um_conditional_orders(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_all_um_orders_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryAllUmOrdersParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"avgPrice":"0.00000","clientOrderId":"abc","cumQuote":"0","executedQty":"0","orderId":1917641,"origQty":"0.40","origType":"LIMIT","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSDT","time":1579276756075,"timeInForce":"GTC","type":"LIMIT","updateTime":1579276756075,"selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}]"#).unwrap();
            let expected_response : Vec<models::QueryAllCurrentUmOpenOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryAllCurrentUmOpenOrdersResponseInner>");

            let resp = client.query_all_um_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_all_um_orders_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryAllUmOrdersParams::builder("symbol_example".to_string(),).order_id(1).start_time(1623319461670).end_time(1641782889000).limit(100).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"avgPrice":"0.00000","clientOrderId":"abc","cumQuote":"0","executedQty":"0","orderId":1917641,"origQty":"0.40","origType":"LIMIT","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSDT","time":1579276756075,"timeInForce":"GTC","type":"LIMIT","updateTime":1579276756075,"selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}]"#).unwrap();
            let expected_response : Vec<models::QueryAllCurrentUmOpenOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryAllCurrentUmOpenOrdersResponseInner>");

            let resp = client.query_all_um_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_all_um_orders_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = QueryAllUmOrdersParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.query_all_um_orders(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_cm_conditional_order_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryCmConditionalOrderHistoryParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"newClientStrategyId":"abc","strategyId":123445,"strategyStatus":"TRIGGERED","strategyType":"TRAILING_STOP_MARKET","origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSD","orderId":12123343534,"status":"NEW","bookTime":1566818724710,"updateTime":1566818724722,"triggerTime":1566818724750,"timeInForce":"GTC","type":"MARKET","activatePrice":"9020","priceRate":"0.3","workingType":"CONTRACT_PRICE","priceProtect":false,"priceMatch":"NONE"}"#).unwrap();
            let expected_response : models::QueryCmConditionalOrderHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryCmConditionalOrderHistoryResponse");

            let resp = client.query_cm_conditional_order_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_cm_conditional_order_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryCmConditionalOrderHistoryParams::builder("symbol_example".to_string(),).strategy_id(1).new_client_strategy_id("1".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"newClientStrategyId":"abc","strategyId":123445,"strategyStatus":"TRIGGERED","strategyType":"TRAILING_STOP_MARKET","origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSD","orderId":12123343534,"status":"NEW","bookTime":1566818724710,"updateTime":1566818724722,"triggerTime":1566818724750,"timeInForce":"GTC","type":"MARKET","activatePrice":"9020","priceRate":"0.3","workingType":"CONTRACT_PRICE","priceProtect":false,"priceMatch":"NONE"}"#).unwrap();
            let expected_response : models::QueryCmConditionalOrderHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryCmConditionalOrderHistoryResponse");

            let resp = client.query_cm_conditional_order_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_cm_conditional_order_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params =
                QueryCmConditionalOrderHistoryParams::builder("symbol_example".to_string())
                    .build()
                    .unwrap();

            match client.query_cm_conditional_order_history(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_cm_modify_order_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryCmModifyOrderHistoryParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"amendmentId":5363,"symbol":"BTCUSD_PERP","pair":"BTCUSD","orderId":20072994037,"clientOrderId":"LJ9R4QZDihCaS8UAOOLpgW","time":1629184560899,"amendment":{"price":{"before":"30004","after":"30003.2"},"origQty":{"before":"1","after":"1"},"count":3}},{"amendmentId":5361,"symbol":"BTCUSD_PERP","pair":"BTCUSD","orderId":20072994037,"clientOrderId":"LJ9R4QZDihCaS8UAOOLpgW","time":1629184533946,"amendment":{"price":{"before":"30005","after":"30004"},"origQty":{"before":"1","after":"1"},"count":2}},{"amendmentId":5325,"symbol":"BTCUSD_PERP","pair":"BTCUSD","orderId":20072994037,"clientOrderId":"LJ9R4QZDihCaS8UAOOLpgW","time":1629182711787,"amendment":{"price":{"before":"30002","after":"30005"},"origQty":{"before":"1","after":"1"},"count":1}}]"#).unwrap();
            let expected_response : Vec<models::QueryCmModifyOrderHistoryResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryCmModifyOrderHistoryResponseInner>");

            let resp = client.query_cm_modify_order_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_cm_modify_order_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryCmModifyOrderHistoryParams::builder("symbol_example".to_string(),).order_id(1).orig_client_order_id("1".to_string()).start_time(1623319461670).end_time(1641782889000).limit(100).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"amendmentId":5363,"symbol":"BTCUSD_PERP","pair":"BTCUSD","orderId":20072994037,"clientOrderId":"LJ9R4QZDihCaS8UAOOLpgW","time":1629184560899,"amendment":{"price":{"before":"30004","after":"30003.2"},"origQty":{"before":"1","after":"1"},"count":3}},{"amendmentId":5361,"symbol":"BTCUSD_PERP","pair":"BTCUSD","orderId":20072994037,"clientOrderId":"LJ9R4QZDihCaS8UAOOLpgW","time":1629184533946,"amendment":{"price":{"before":"30005","after":"30004"},"origQty":{"before":"1","after":"1"},"count":2}},{"amendmentId":5325,"symbol":"BTCUSD_PERP","pair":"BTCUSD","orderId":20072994037,"clientOrderId":"LJ9R4QZDihCaS8UAOOLpgW","time":1629182711787,"amendment":{"price":{"before":"30002","after":"30005"},"origQty":{"before":"1","after":"1"},"count":1}}]"#).unwrap();
            let expected_response : Vec<models::QueryCmModifyOrderHistoryResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryCmModifyOrderHistoryResponseInner>");

            let resp = client.query_cm_modify_order_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_cm_modify_order_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = QueryCmModifyOrderHistoryParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.query_cm_modify_order_history(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_cm_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryCmOrderParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"avgPrice":"0.0","clientOrderId":"abc","cumBase":"0","executedQty":"0","orderId":1917641,"origQty":"0.40","origType":"LIMIT","price":"0","reduceOnly":false,"side":"BUY","status":"NEW","symbol":"BTCUSD_200925","pair":"BTCUSD","positionSide":"SHORT","time":1579276756075,"timeInForce":"GTC","type":"LIMIT","updateTime":1579276756075}"#).unwrap();
            let expected_response : models::QueryCmOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryCmOrderResponse");

            let resp = client.query_cm_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_cm_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryCmOrderParams::builder("symbol_example".to_string(),).order_id(1).orig_client_order_id("1".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"avgPrice":"0.0","clientOrderId":"abc","cumBase":"0","executedQty":"0","orderId":1917641,"origQty":"0.40","origType":"LIMIT","price":"0","reduceOnly":false,"side":"BUY","status":"NEW","symbol":"BTCUSD_200925","pair":"BTCUSD","positionSide":"SHORT","time":1579276756075,"timeInForce":"GTC","type":"LIMIT","updateTime":1579276756075}"#).unwrap();
            let expected_response : models::QueryCmOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryCmOrderResponse");

            let resp = client.query_cm_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_cm_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = QueryCmOrderParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.query_cm_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_current_cm_open_conditional_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryCurrentCmOpenConditionalOrderParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"newClientStrategyId":"abc","strategyId":123445,"strategyStatus":"NEW","strategyType":"TRAILING_STOP_MARKET","origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSD","bookTime":1566818724710,"updateTime":1566818724722,"timeInForce":"GTC","activatePrice":"9020","priceRate":"0.3"}"#).unwrap();
            let expected_response : models::QueryCurrentCmOpenConditionalOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryCurrentCmOpenConditionalOrderResponse");

            let resp = client.query_current_cm_open_conditional_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_current_cm_open_conditional_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryCurrentCmOpenConditionalOrderParams::builder("symbol_example".to_string(),).strategy_id(1).new_client_strategy_id("1".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"newClientStrategyId":"abc","strategyId":123445,"strategyStatus":"NEW","strategyType":"TRAILING_STOP_MARKET","origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSD","bookTime":1566818724710,"updateTime":1566818724722,"timeInForce":"GTC","activatePrice":"9020","priceRate":"0.3"}"#).unwrap();
            let expected_response : models::QueryCurrentCmOpenConditionalOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryCurrentCmOpenConditionalOrderResponse");

            let resp = client.query_current_cm_open_conditional_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_current_cm_open_conditional_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params =
                QueryCurrentCmOpenConditionalOrderParams::builder("symbol_example".to_string())
                    .build()
                    .unwrap();

            match client.query_current_cm_open_conditional_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_current_cm_open_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryCurrentCmOpenOrderParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"avgPrice":"0.0","clientOrderId":"abc","cumBase":"0","executedQty":"0","orderId":1917641,"origQty":"0.40","origType":"LIMIT","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSD_200925","pair":"BTCUSD","time":1579276756075,"timeInForce":"GTC","type":"LIMIT","updateTime":1579276756075}"#).unwrap();
            let expected_response : models::QueryCurrentCmOpenOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryCurrentCmOpenOrderResponse");

            let resp = client.query_current_cm_open_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_current_cm_open_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryCurrentCmOpenOrderParams::builder("symbol_example".to_string(),).order_id(1).orig_client_order_id("1".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"avgPrice":"0.0","clientOrderId":"abc","cumBase":"0","executedQty":"0","orderId":1917641,"origQty":"0.40","origType":"LIMIT","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSD_200925","pair":"BTCUSD","time":1579276756075,"timeInForce":"GTC","type":"LIMIT","updateTime":1579276756075}"#).unwrap();
            let expected_response : models::QueryCurrentCmOpenOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryCurrentCmOpenOrderResponse");

            let resp = client.query_current_cm_open_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_current_cm_open_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = QueryCurrentCmOpenOrderParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.query_current_cm_open_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_current_margin_open_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryCurrentMarginOpenOrderParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"clientOrderId":"qhcZw71gAkCCTv0t0k8LUK","cummulativeQuoteQty":"0.00000000","executedQty":"0.00000000","icebergQty":"0.00000000","isWorking":true,"orderId":211842552,"origQty":"0.30000000","price":"0.00475010","side":"SELL","status":"NEW","stopPrice":"0.00000000","symbol":"BNBBTC","time":1562040170089,"timeInForce":"GTC","type":"LIMIT","updateTime":1562040170089,"accountId":152950866,"selfTradePreventionMode":"EXPIRE_TAKER","preventedMatchId":null,"preventedQuantity":null}]"#).unwrap();
            let expected_response : Vec<models::QueryCurrentMarginOpenOrderResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryCurrentMarginOpenOrderResponseInner>");

            let resp = client.query_current_margin_open_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_current_margin_open_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryCurrentMarginOpenOrderParams::builder("symbol_example".to_string(),).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"clientOrderId":"qhcZw71gAkCCTv0t0k8LUK","cummulativeQuoteQty":"0.00000000","executedQty":"0.00000000","icebergQty":"0.00000000","isWorking":true,"orderId":211842552,"origQty":"0.30000000","price":"0.00475010","side":"SELL","status":"NEW","stopPrice":"0.00000000","symbol":"BNBBTC","time":1562040170089,"timeInForce":"GTC","type":"LIMIT","updateTime":1562040170089,"accountId":152950866,"selfTradePreventionMode":"EXPIRE_TAKER","preventedMatchId":null,"preventedQuantity":null}]"#).unwrap();
            let expected_response : Vec<models::QueryCurrentMarginOpenOrderResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryCurrentMarginOpenOrderResponseInner>");

            let resp = client.query_current_margin_open_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_current_margin_open_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = QueryCurrentMarginOpenOrderParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.query_current_margin_open_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_current_um_open_conditional_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryCurrentUmOpenConditionalOrderParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"newClientStrategyId":"abc","strategyId":123445,"strategyStatus":"NEW","strategyType":"TRAILING_STOP_MARKET","origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSDT","bookTime":1566818724710,"updateTime":1566818724722,"timeInForce":"GTC","activatePrice":"9020","priceRate":"0.3","selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}"#).unwrap();
            let expected_response : models::QueryCurrentUmOpenConditionalOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryCurrentUmOpenConditionalOrderResponse");

            let resp = client.query_current_um_open_conditional_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_current_um_open_conditional_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryCurrentUmOpenConditionalOrderParams::builder("symbol_example".to_string(),).strategy_id(1).new_client_strategy_id("1".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"newClientStrategyId":"abc","strategyId":123445,"strategyStatus":"NEW","strategyType":"TRAILING_STOP_MARKET","origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSDT","bookTime":1566818724710,"updateTime":1566818724722,"timeInForce":"GTC","activatePrice":"9020","priceRate":"0.3","selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}"#).unwrap();
            let expected_response : models::QueryCurrentUmOpenConditionalOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryCurrentUmOpenConditionalOrderResponse");

            let resp = client.query_current_um_open_conditional_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_current_um_open_conditional_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params =
                QueryCurrentUmOpenConditionalOrderParams::builder("symbol_example".to_string())
                    .build()
                    .unwrap();

            match client.query_current_um_open_conditional_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_current_um_open_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryCurrentUmOpenOrderParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"avgPrice":"0.00000","clientOrderId":"abc","cumQuote":"0","executedQty":"0","orderId":1917641,"origQty":"0.40","origType":"LIMIT","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSDT","time":1579276756075,"timeInForce":"GTC","type":"LIMIT","updateTime":1579276756075,"selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}"#).unwrap();
            let expected_response : models::QueryCurrentUmOpenOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryCurrentUmOpenOrderResponse");

            let resp = client.query_current_um_open_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_current_um_open_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryCurrentUmOpenOrderParams::builder("symbol_example".to_string(),).order_id(1).orig_client_order_id("1".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"avgPrice":"0.00000","clientOrderId":"abc","cumQuote":"0","executedQty":"0","orderId":1917641,"origQty":"0.40","origType":"LIMIT","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSDT","time":1579276756075,"timeInForce":"GTC","type":"LIMIT","updateTime":1579276756075,"selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}"#).unwrap();
            let expected_response : models::QueryCurrentUmOpenOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryCurrentUmOpenOrderResponse");

            let resp = client.query_current_um_open_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_current_um_open_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = QueryCurrentUmOpenOrderParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.query_current_um_open_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_margin_account_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryMarginAccountOrderParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"clientOrderId":"ZwfQzuDIGpceVhKW5DvCmO","cummulativeQuoteQty":"0.00000000","executedQty":"0.00000000","icebergQty":"0.00000000","isWorking":true,"orderId":213205622,"origQty":"0.30000000","price":"0.00493630","side":"SELL","status":"NEW","stopPrice":"0.00000000","symbol":"BNBBTC","time":1562133008725,"timeInForce":"GTC","type":"LIMIT","updateTime":1562133008725,"accountId":152950866,"selfTradePreventionMode":"EXPIRE_TAKER","preventedMatchId":null,"preventedQuantity":null}"#).unwrap();
            let expected_response : models::QueryMarginAccountOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryMarginAccountOrderResponse");

            let resp = client.query_margin_account_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_margin_account_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryMarginAccountOrderParams::builder("symbol_example".to_string(),).order_id(1).orig_client_order_id("1".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"clientOrderId":"ZwfQzuDIGpceVhKW5DvCmO","cummulativeQuoteQty":"0.00000000","executedQty":"0.00000000","icebergQty":"0.00000000","isWorking":true,"orderId":213205622,"origQty":"0.30000000","price":"0.00493630","side":"SELL","status":"NEW","stopPrice":"0.00000000","symbol":"BNBBTC","time":1562133008725,"timeInForce":"GTC","type":"LIMIT","updateTime":1562133008725,"accountId":152950866,"selfTradePreventionMode":"EXPIRE_TAKER","preventedMatchId":null,"preventedQuantity":null}"#).unwrap();
            let expected_response : models::QueryMarginAccountOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryMarginAccountOrderResponse");

            let resp = client.query_margin_account_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_margin_account_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = QueryMarginAccountOrderParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.query_margin_account_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_margin_accounts_all_oco_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryMarginAccountsAllOcoParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"orderListId":29,"contingencyType":"OCO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"amEEAXryFzFwYF1FeRpUoZ","transactionTime":1565245913483,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":4,"clientOrderId":"oD7aesZqjEGlZrbtRpy5zB"},{"symbol":"LTCBTC","orderId":5,"clientOrderId":"Jr1h6xirOxgeJOUuYQS7V3"}]},{"orderListId":28,"contingencyType":"OCO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"hG7hFNxJV6cZy3Ze4AUT4d","transactionTime":1565245913407,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":2,"clientOrderId":"j6lFOfbmFMRjTYA7rRJ0LP"},{"symbol":"LTCBTC","orderId":3,"clientOrderId":"z0KCjOdditiLS5ekAFtK81"}]}]"#).unwrap();
            let expected_response : Vec<models::QueryMarginAccountsAllOcoResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryMarginAccountsAllOcoResponseInner>");

            let resp = client.query_margin_accounts_all_oco(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_margin_accounts_all_oco_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryMarginAccountsAllOcoParams::builder().from_id(1).start_time(1623319461670).end_time(1641782889000).limit(100).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"orderListId":29,"contingencyType":"OCO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"amEEAXryFzFwYF1FeRpUoZ","transactionTime":1565245913483,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":4,"clientOrderId":"oD7aesZqjEGlZrbtRpy5zB"},{"symbol":"LTCBTC","orderId":5,"clientOrderId":"Jr1h6xirOxgeJOUuYQS7V3"}]},{"orderListId":28,"contingencyType":"OCO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"hG7hFNxJV6cZy3Ze4AUT4d","transactionTime":1565245913407,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":2,"clientOrderId":"j6lFOfbmFMRjTYA7rRJ0LP"},{"symbol":"LTCBTC","orderId":3,"clientOrderId":"z0KCjOdditiLS5ekAFtK81"}]}]"#).unwrap();
            let expected_response : Vec<models::QueryMarginAccountsAllOcoResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryMarginAccountsAllOcoResponseInner>");

            let resp = client.query_margin_accounts_all_oco(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_margin_accounts_all_oco_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = QueryMarginAccountsAllOcoParams::builder().build().unwrap();

            match client.query_margin_accounts_all_oco(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_margin_accounts_oco_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryMarginAccountsOcoParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"orderListId":27,"contingencyType":"OCO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"h2USkA5YQpaXHPIrkd96xE","transactionTime":1565245656253,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":4,"clientOrderId":"qD1gy3kc3Gx0rihm9Y3xwS"},{"symbol":"LTCBTC","orderId":5,"clientOrderId":"ARzZ9I00CPM8i3NhmU9Ega"}]}"#).unwrap();
            let expected_response : models::QueryMarginAccountsOcoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryMarginAccountsOcoResponse");

            let resp = client.query_margin_accounts_oco(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_margin_accounts_oco_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryMarginAccountsOcoParams::builder().order_list_id(1).orig_client_order_id("1".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"orderListId":27,"contingencyType":"OCO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"h2USkA5YQpaXHPIrkd96xE","transactionTime":1565245656253,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":4,"clientOrderId":"qD1gy3kc3Gx0rihm9Y3xwS"},{"symbol":"LTCBTC","orderId":5,"clientOrderId":"ARzZ9I00CPM8i3NhmU9Ega"}]}"#).unwrap();
            let expected_response : models::QueryMarginAccountsOcoResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryMarginAccountsOcoResponse");

            let resp = client.query_margin_accounts_oco(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_margin_accounts_oco_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = QueryMarginAccountsOcoParams::builder().build().unwrap();

            match client.query_margin_accounts_oco(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_margin_accounts_open_oco_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryMarginAccountsOpenOcoParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"orderListId":31,"contingencyType":"OCO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"wuB13fmulKj3YjdqWEcsnp","transactionTime":1565246080644,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":4,"clientOrderId":"r3EH2N76dHfLoSZWIUw1bT"},{"symbol":"LTCBTC","orderId":5,"clientOrderId":"Cv1SnyPD3qhqpbjpYEHbd2"}]}]"#).unwrap();
            let expected_response : Vec<models::QueryMarginAccountsOpenOcoResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryMarginAccountsOpenOcoResponseInner>");

            let resp = client.query_margin_accounts_open_oco(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_margin_accounts_open_oco_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryMarginAccountsOpenOcoParams::builder().recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"orderListId":31,"contingencyType":"OCO","listStatusType":"EXEC_STARTED","listOrderStatus":"EXECUTING","listClientOrderId":"wuB13fmulKj3YjdqWEcsnp","transactionTime":1565246080644,"symbol":"LTCBTC","orders":[{"symbol":"LTCBTC","orderId":4,"clientOrderId":"r3EH2N76dHfLoSZWIUw1bT"},{"symbol":"LTCBTC","orderId":5,"clientOrderId":"Cv1SnyPD3qhqpbjpYEHbd2"}]}]"#).unwrap();
            let expected_response : Vec<models::QueryMarginAccountsOpenOcoResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryMarginAccountsOpenOcoResponseInner>");

            let resp = client.query_margin_accounts_open_oco(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_margin_accounts_open_oco_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = QueryMarginAccountsOpenOcoParams::builder().build().unwrap();

            match client.query_margin_accounts_open_oco(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_um_conditional_order_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryUmConditionalOrderHistoryParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"newClientStrategyId":"abc","strategyId":123445,"strategyStatus":"TRIGGERED","strategyType":"TRAILING_STOP_MARKET","origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSDT","orderId":12132343435,"status":"NEW","bookTime":1566818724710,"updateTime":1566818724722,"triggerTime":1566818724750,"timeInForce":"GTC","type":"MARKET","activatePrice":"9020","priceRate":"0.3","workingType":"CONTRACT_PRICE","priceProtect":false,"selfTradePreventionMode":"NONE","goodTillDate":0}"#).unwrap();
            let expected_response : models::QueryUmConditionalOrderHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryUmConditionalOrderHistoryResponse");

            let resp = client.query_um_conditional_order_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_um_conditional_order_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryUmConditionalOrderHistoryParams::builder("symbol_example".to_string(),).strategy_id(1).new_client_strategy_id("1".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"newClientStrategyId":"abc","strategyId":123445,"strategyStatus":"TRIGGERED","strategyType":"TRAILING_STOP_MARKET","origQty":"0.40","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","stopPrice":"9300","symbol":"BTCUSDT","orderId":12132343435,"status":"NEW","bookTime":1566818724710,"updateTime":1566818724722,"triggerTime":1566818724750,"timeInForce":"GTC","type":"MARKET","activatePrice":"9020","priceRate":"0.3","workingType":"CONTRACT_PRICE","priceProtect":false,"selfTradePreventionMode":"NONE","goodTillDate":0}"#).unwrap();
            let expected_response : models::QueryUmConditionalOrderHistoryResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryUmConditionalOrderHistoryResponse");

            let resp = client.query_um_conditional_order_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_um_conditional_order_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params =
                QueryUmConditionalOrderHistoryParams::builder("symbol_example".to_string())
                    .build()
                    .unwrap();

            match client.query_um_conditional_order_history(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_um_modify_order_history_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryUmModifyOrderHistoryParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"amendmentId":5363,"symbol":"BTCUSDT","pair":"BTCUSDT","orderId":20072994037,"clientOrderId":"LJ9R4QZDihCaS8UAOOLpgW","time":1629184560899,"amendment":{"price":{"before":"30004","after":"30003.2"},"origQty":{"before":"1","after":"1"},"count":3},"priceMatch":"NONE"},{"amendmentId":5361,"symbol":"BTCUSDT","pair":"BTCUSDT","orderId":20072994037,"clientOrderId":"LJ9R4QZDihCaS8UAOOLpgW","time":1629184533946,"amendment":{"price":{"before":"30005","after":"30004"},"origQty":{"before":"1","after":"1"},"count":2},"priceMatch":"NONE"},{"amendmentId":5325,"symbol":"BTCUSDT","pair":"BTCUSDT","orderId":20072994037,"clientOrderId":"LJ9R4QZDihCaS8UAOOLpgW","time":1629182711787,"amendment":{"price":{"before":"30002","after":"30005"},"origQty":{"before":"1","after":"1"},"count":1},"priceMatch":"NONE"}]"#).unwrap();
            let expected_response : Vec<models::QueryUmModifyOrderHistoryResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryUmModifyOrderHistoryResponseInner>");

            let resp = client.query_um_modify_order_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_um_modify_order_history_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryUmModifyOrderHistoryParams::builder("symbol_example".to_string(),).order_id(1).orig_client_order_id("1".to_string()).start_time(1623319461670).end_time(1641782889000).limit(100).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"amendmentId":5363,"symbol":"BTCUSDT","pair":"BTCUSDT","orderId":20072994037,"clientOrderId":"LJ9R4QZDihCaS8UAOOLpgW","time":1629184560899,"amendment":{"price":{"before":"30004","after":"30003.2"},"origQty":{"before":"1","after":"1"},"count":3},"priceMatch":"NONE"},{"amendmentId":5361,"symbol":"BTCUSDT","pair":"BTCUSDT","orderId":20072994037,"clientOrderId":"LJ9R4QZDihCaS8UAOOLpgW","time":1629184533946,"amendment":{"price":{"before":"30005","after":"30004"},"origQty":{"before":"1","after":"1"},"count":2},"priceMatch":"NONE"},{"amendmentId":5325,"symbol":"BTCUSDT","pair":"BTCUSDT","orderId":20072994037,"clientOrderId":"LJ9R4QZDihCaS8UAOOLpgW","time":1629182711787,"amendment":{"price":{"before":"30002","after":"30005"},"origQty":{"before":"1","after":"1"},"count":1},"priceMatch":"NONE"}]"#).unwrap();
            let expected_response : Vec<models::QueryUmModifyOrderHistoryResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryUmModifyOrderHistoryResponseInner>");

            let resp = client.query_um_modify_order_history(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_um_modify_order_history_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = QueryUmModifyOrderHistoryParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.query_um_modify_order_history(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_um_order_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryUmOrderParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"avgPrice":"0.00000","clientOrderId":"abc","cumQuote":"0","executedQty":"0","orderId":1917641,"origQty":"0.40","origType":"LIMIT","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSDT","time":1579276756075,"timeInForce":"GTC","type":"LIMIT","updateTime":1579276756075,"selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}"#).unwrap();
            let expected_response : models::QueryUmOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryUmOrderResponse");

            let resp = client.query_um_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_um_order_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryUmOrderParams::builder("symbol_example".to_string(),).order_id(1).orig_client_order_id("1".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"avgPrice":"0.00000","clientOrderId":"abc","cumQuote":"0","executedQty":"0","orderId":1917641,"origQty":"0.40","origType":"LIMIT","price":"0","reduceOnly":false,"side":"BUY","positionSide":"SHORT","status":"NEW","symbol":"BTCUSDT","time":1579276756075,"timeInForce":"GTC","type":"LIMIT","updateTime":1579276756075,"selfTradePreventionMode":"NONE","goodTillDate":0,"priceMatch":"NONE"}"#).unwrap();
            let expected_response : models::QueryUmOrderResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryUmOrderResponse");

            let resp = client.query_um_order(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_um_order_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = QueryUmOrderParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.query_um_order(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_users_cm_force_orders_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryUsersCmForceOrdersParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"orderId":165123080,"symbol":"BTCUSD_200925","pair":"BTCUSD","status":"FILLED","clientOrderId":"autoclose-1596542005017000006","price":"11326.9","avgPrice":"11326.9","origQty":"1","executedQty":"1","cumBase":"0.00882854","timeInForce":"IOC","type":"LIMIT","reduceOnly":false,"side":"SELL","positionSide":"BOTH","origType":"LIMIT","time":1596542005019,"updateTime":1596542005050}]"#).unwrap();
            let expected_response : Vec<models::QueryUsersCmForceOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryUsersCmForceOrdersResponseInner>");

            let resp = client.query_users_cm_force_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_users_cm_force_orders_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryUsersCmForceOrdersParams::builder().symbol("symbol_example".to_string()).auto_close_type(QueryUsersCmForceOrdersAutoCloseTypeEnum::Liquidation).start_time(1623319461670).end_time(1641782889000).limit(100).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"orderId":165123080,"symbol":"BTCUSD_200925","pair":"BTCUSD","status":"FILLED","clientOrderId":"autoclose-1596542005017000006","price":"11326.9","avgPrice":"11326.9","origQty":"1","executedQty":"1","cumBase":"0.00882854","timeInForce":"IOC","type":"LIMIT","reduceOnly":false,"side":"SELL","positionSide":"BOTH","origType":"LIMIT","time":1596542005019,"updateTime":1596542005050}]"#).unwrap();
            let expected_response : Vec<models::QueryUsersCmForceOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryUsersCmForceOrdersResponseInner>");

            let resp = client.query_users_cm_force_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_users_cm_force_orders_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = QueryUsersCmForceOrdersParams::builder().build().unwrap();

            match client.query_users_cm_force_orders(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_users_margin_force_orders_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryUsersMarginForceOrdersParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"avgPrice":"0.00388359","executedQty":"31.39000000","orderId":180015097,"price":"0.00388110","qty":"31.39000000","side":"SELL","symbol":"BNBBTC","timeInForce":"GTC","updatedTime":1558941374745}],"total":1}"#).unwrap();
            let expected_response : models::QueryUsersMarginForceOrdersResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryUsersMarginForceOrdersResponse");

            let resp = client.query_users_margin_force_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_users_margin_force_orders_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryUsersMarginForceOrdersParams::builder().start_time(1623319461670).end_time(1641782889000).current(1).size(10).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"rows":[{"avgPrice":"0.00388359","executedQty":"31.39000000","orderId":180015097,"price":"0.00388110","qty":"31.39000000","side":"SELL","symbol":"BNBBTC","timeInForce":"GTC","updatedTime":1558941374745}],"total":1}"#).unwrap();
            let expected_response : models::QueryUsersMarginForceOrdersResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::QueryUsersMarginForceOrdersResponse");

            let resp = client.query_users_margin_force_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_users_margin_force_orders_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = QueryUsersMarginForceOrdersParams::builder()
                .build()
                .unwrap();

            match client.query_users_margin_force_orders(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn query_users_um_force_orders_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryUsersUmForceOrdersParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"orderId":6071832819,"symbol":"BTCUSDT","status":"FILLED","clientOrderId":"autoclose-1596107620040000020","price":"10871.09","avgPrice":"10913.21000","origQty":"0.001","executedQty":"0.001","cumQuote":"10.91321","timeInForce":"IOC","type":"LIMIT","reduceOnly":false,"side":"SELL","positionSide":"BOTH","origType":"LIMIT","time":1596107620044,"updateTime":1596107620087}]"#).unwrap();
            let expected_response : Vec<models::QueryUsersUmForceOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryUsersUmForceOrdersResponseInner>");

            let resp = client.query_users_um_force_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_users_um_force_orders_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = QueryUsersUmForceOrdersParams::builder().symbol("symbol_example".to_string()).auto_close_type(QueryUsersUmForceOrdersAutoCloseTypeEnum::Liquidation).start_time(1623319461670).end_time(1641782889000).limit(100).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"orderId":6071832819,"symbol":"BTCUSDT","status":"FILLED","clientOrderId":"autoclose-1596107620040000020","price":"10871.09","avgPrice":"10913.21000","origQty":"0.001","executedQty":"0.001","cumQuote":"10.91321","timeInForce":"IOC","type":"LIMIT","reduceOnly":false,"side":"SELL","positionSide":"BOTH","origType":"LIMIT","time":1596107620044,"updateTime":1596107620087}]"#).unwrap();
            let expected_response : Vec<models::QueryUsersUmForceOrdersResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::QueryUsersUmForceOrdersResponseInner>");

            let resp = client.query_users_um_force_orders(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn query_users_um_force_orders_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = QueryUsersUmForceOrdersParams::builder().build().unwrap();

            match client.query_users_um_force_orders(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn toggle_bnb_burn_on_um_futures_trade_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params =
                ToggleBnbBurnOnUmFuturesTradeParams::builder("fee_burn_example".to_string())
                    .build()
                    .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"code":200,"msg":"success"}"#).unwrap();
            let expected_response: models::ToggleBnbBurnOnUmFuturesTradeResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::ToggleBnbBurnOnUmFuturesTradeResponse");

            let resp = client
                .toggle_bnb_burn_on_um_futures_trade(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn toggle_bnb_burn_on_um_futures_trade_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params =
                ToggleBnbBurnOnUmFuturesTradeParams::builder("fee_burn_example".to_string())
                    .recv_window(5000)
                    .build()
                    .unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"code":200,"msg":"success"}"#).unwrap();
            let expected_response: models::ToggleBnbBurnOnUmFuturesTradeResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::ToggleBnbBurnOnUmFuturesTradeResponse");

            let resp = client
                .toggle_bnb_burn_on_um_futures_trade(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn toggle_bnb_burn_on_um_futures_trade_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params =
                ToggleBnbBurnOnUmFuturesTradeParams::builder("fee_burn_example".to_string())
                    .build()
                    .unwrap();

            match client.toggle_bnb_burn_on_um_futures_trade(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn um_account_trade_list_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = UmAccountTradeListParams::builder("symbol_example".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"symbol":"BTCUSDT","id":67880589,"orderId":270093109,"side":"SELL","price":"28511.00","qty":"0.010","realizedPnl":"2.58500000","quoteQty":"285.11000","commission":"-0.11404400","commissionAsset":"USDT","time":1680688557875,"buyer":false,"maker":false,"positionSide":"BOTH"}]"#).unwrap();
            let expected_response : Vec<models::UmAccountTradeListResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::UmAccountTradeListResponseInner>");

            let resp = client.um_account_trade_list(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn um_account_trade_list_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = UmAccountTradeListParams::builder("symbol_example".to_string(),).start_time(1623319461670).end_time(1641782889000).from_id(1).limit(100).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"symbol":"BTCUSDT","id":67880589,"orderId":270093109,"side":"SELL","price":"28511.00","qty":"0.010","realizedPnl":"2.58500000","quoteQty":"285.11000","commission":"-0.11404400","commissionAsset":"USDT","time":1680688557875,"buyer":false,"maker":false,"positionSide":"BOTH"}]"#).unwrap();
            let expected_response : Vec<models::UmAccountTradeListResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::UmAccountTradeListResponseInner>");

            let resp = client.um_account_trade_list(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn um_account_trade_list_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = UmAccountTradeListParams::builder("symbol_example".to_string())
                .build()
                .unwrap();

            match client.um_account_trade_list(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn um_position_adl_quantile_estimation_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = UmPositionAdlQuantileEstimationParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"symbol":"ETHUSDT","adlQuantile":{"LONG":3,"SHORT":3,"HEDGE":0}},{"symbol":"BTCUSDT","adlQuantile":{"LONG":1,"SHORT":2,"BOTH":0}}]"#).unwrap();
            let expected_response : Vec<models::UmPositionAdlQuantileEstimationResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::UmPositionAdlQuantileEstimationResponseInner>");

            let resp = client.um_position_adl_quantile_estimation(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn um_position_adl_quantile_estimation_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: false };

            let params = UmPositionAdlQuantileEstimationParams::builder().symbol("symbol_example".to_string()).recv_window(5000).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"symbol":"ETHUSDT","adlQuantile":{"LONG":3,"SHORT":3,"HEDGE":0}},{"symbol":"BTCUSDT","adlQuantile":{"LONG":1,"SHORT":2,"BOTH":0}}]"#).unwrap();
            let expected_response : Vec<models::UmPositionAdlQuantileEstimationResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::UmPositionAdlQuantileEstimationResponseInner>");

            let resp = client.um_position_adl_quantile_estimation(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn um_position_adl_quantile_estimation_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockTradeApiClient { force_error: true };

            let params = UmPositionAdlQuantileEstimationParams::builder()
                .build()
                .unwrap();

            match client.um_position_adl_quantile_estimation(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }
}
