/*
 * Binance Spot REST API
 *
 * OpenAPI Specifications for the Binance Spot REST API
 *
 * API documents:
 * - [Github rest-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md)
 * - [General API information for rest-api on website](https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-api-information)
 *
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#![allow(unused_imports)]
use async_trait::async_trait;
use derive_builder::Builder;
use reqwest;
use rust_decimal::prelude::*;
use serde::{Deserialize, Serialize};
use serde_json::{Value, json};
use std::collections::BTreeMap;

use crate::common::{
    config::ConfigurationRestApi,
    models::{ParamBuildError, RestApiResponse},
    utils::send_request,
};
use crate::spot::rest_api::models;

const HAS_TIME_UNIT: bool = true;

#[async_trait]
pub trait MarketApi: Send + Sync {
    async fn agg_trades(
        &self,
        params: AggTradesParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::AggTradesResponseInner>>>;
    async fn avg_price(
        &self,
        params: AvgPriceParams,
    ) -> anyhow::Result<RestApiResponse<models::AvgPriceResponse>>;
    async fn depth(
        &self,
        params: DepthParams,
    ) -> anyhow::Result<RestApiResponse<models::DepthResponse>>;
    async fn get_trades(
        &self,
        params: GetTradesParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::HistoricalTradesResponseInner>>>;
    async fn historical_trades(
        &self,
        params: HistoricalTradesParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::HistoricalTradesResponseInner>>>;
    async fn klines(
        &self,
        params: KlinesParams,
    ) -> anyhow::Result<RestApiResponse<Vec<Vec<models::KlinesItemInner>>>>;
    async fn ticker(
        &self,
        params: TickerParams,
    ) -> anyhow::Result<RestApiResponse<models::TickerResponse>>;
    async fn ticker24hr(
        &self,
        params: Ticker24hrParams,
    ) -> anyhow::Result<RestApiResponse<models::Ticker24hrResponse>>;
    async fn ticker_book_ticker(
        &self,
        params: TickerBookTickerParams,
    ) -> anyhow::Result<RestApiResponse<models::TickerBookTickerResponse>>;
    async fn ticker_price(
        &self,
        params: TickerPriceParams,
    ) -> anyhow::Result<RestApiResponse<models::TickerPriceResponse>>;
    async fn ticker_trading_day(
        &self,
        params: TickerTradingDayParams,
    ) -> anyhow::Result<RestApiResponse<models::TickerTradingDayResponse>>;
    async fn ui_klines(
        &self,
        params: UiKlinesParams,
    ) -> anyhow::Result<RestApiResponse<Vec<Vec<models::KlinesItemInner>>>>;
}

#[derive(Debug, Clone)]
pub struct MarketApiClient {
    configuration: ConfigurationRestApi,
}

impl MarketApiClient {
    pub fn new(configuration: ConfigurationRestApi) -> Self {
        Self { configuration }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DepthSymbolStatusEnum {
    #[serde(rename = "TRADING")]
    Trading,
    #[serde(rename = "END_OF_DAY")]
    EndOfDay,
    #[serde(rename = "HALT")]
    Halt,
    #[serde(rename = "BREAK")]
    Break,
    #[serde(rename = "NON_REPRESENTABLE")]
    NonRepresentable,
}

impl DepthSymbolStatusEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Trading => "TRADING",
            Self::EndOfDay => "END_OF_DAY",
            Self::Halt => "HALT",
            Self::Break => "BREAK",
            Self::NonRepresentable => "NON_REPRESENTABLE",
        }
    }
}

impl std::str::FromStr for DepthSymbolStatusEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "TRADING" => Ok(Self::Trading),
            "END_OF_DAY" => Ok(Self::EndOfDay),
            "HALT" => Ok(Self::Halt),
            "BREAK" => Ok(Self::Break),
            "NON_REPRESENTABLE" => Ok(Self::NonRepresentable),
            other => Err(format!("invalid DepthSymbolStatusEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum KlinesIntervalEnum {
    #[serde(rename = "1s")]
    Interval1s,
    #[serde(rename = "1m")]
    Interval1m,
    #[serde(rename = "3m")]
    Interval3m,
    #[serde(rename = "5m")]
    Interval5m,
    #[serde(rename = "15m")]
    Interval15m,
    #[serde(rename = "30m")]
    Interval30m,
    #[serde(rename = "1h")]
    Interval1h,
    #[serde(rename = "2h")]
    Interval2h,
    #[serde(rename = "4h")]
    Interval4h,
    #[serde(rename = "6h")]
    Interval6h,
    #[serde(rename = "8h")]
    Interval8h,
    #[serde(rename = "12h")]
    Interval12h,
    #[serde(rename = "1d")]
    Interval1d,
    #[serde(rename = "3d")]
    Interval3d,
    #[serde(rename = "1w")]
    Interval1w,
    #[serde(rename = "1M")]
    Interval1M,
}

impl KlinesIntervalEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Interval1s => "1s",
            Self::Interval1m => "1m",
            Self::Interval3m => "3m",
            Self::Interval5m => "5m",
            Self::Interval15m => "15m",
            Self::Interval30m => "30m",
            Self::Interval1h => "1h",
            Self::Interval2h => "2h",
            Self::Interval4h => "4h",
            Self::Interval6h => "6h",
            Self::Interval8h => "8h",
            Self::Interval12h => "12h",
            Self::Interval1d => "1d",
            Self::Interval3d => "3d",
            Self::Interval1w => "1w",
            Self::Interval1M => "1M",
        }
    }
}

impl std::str::FromStr for KlinesIntervalEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "1s" => Ok(Self::Interval1s),
            "1m" => Ok(Self::Interval1m),
            "3m" => Ok(Self::Interval3m),
            "5m" => Ok(Self::Interval5m),
            "15m" => Ok(Self::Interval15m),
            "30m" => Ok(Self::Interval30m),
            "1h" => Ok(Self::Interval1h),
            "2h" => Ok(Self::Interval2h),
            "4h" => Ok(Self::Interval4h),
            "6h" => Ok(Self::Interval6h),
            "8h" => Ok(Self::Interval8h),
            "12h" => Ok(Self::Interval12h),
            "1d" => Ok(Self::Interval1d),
            "3d" => Ok(Self::Interval3d),
            "1w" => Ok(Self::Interval1w),
            "1M" => Ok(Self::Interval1M),
            other => Err(format!("invalid KlinesIntervalEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TickerWindowSizeEnum {
    #[serde(rename = "1m")]
    WindowSize1m,
    #[serde(rename = "2m")]
    WindowSize2m,
    #[serde(rename = "3m")]
    WindowSize3m,
    #[serde(rename = "4m")]
    WindowSize4m,
    #[serde(rename = "5m")]
    WindowSize5m,
    #[serde(rename = "6m")]
    WindowSize6m,
    #[serde(rename = "7m")]
    WindowSize7m,
    #[serde(rename = "8m")]
    WindowSize8m,
    #[serde(rename = "9m")]
    WindowSize9m,
    #[serde(rename = "10m")]
    WindowSize10m,
    #[serde(rename = "11m")]
    WindowSize11m,
    #[serde(rename = "12m")]
    WindowSize12m,
    #[serde(rename = "13m")]
    WindowSize13m,
    #[serde(rename = "14m")]
    WindowSize14m,
    #[serde(rename = "15m")]
    WindowSize15m,
    #[serde(rename = "16m")]
    WindowSize16m,
    #[serde(rename = "17m")]
    WindowSize17m,
    #[serde(rename = "18m")]
    WindowSize18m,
    #[serde(rename = "19m")]
    WindowSize19m,
    #[serde(rename = "20m")]
    WindowSize20m,
    #[serde(rename = "21m")]
    WindowSize21m,
    #[serde(rename = "22m")]
    WindowSize22m,
    #[serde(rename = "23m")]
    WindowSize23m,
    #[serde(rename = "24m")]
    WindowSize24m,
    #[serde(rename = "25m")]
    WindowSize25m,
    #[serde(rename = "26m")]
    WindowSize26m,
    #[serde(rename = "27m")]
    WindowSize27m,
    #[serde(rename = "28m")]
    WindowSize28m,
    #[serde(rename = "29m")]
    WindowSize29m,
    #[serde(rename = "30m")]
    WindowSize30m,
    #[serde(rename = "31m")]
    WindowSize31m,
    #[serde(rename = "32m")]
    WindowSize32m,
    #[serde(rename = "33m")]
    WindowSize33m,
    #[serde(rename = "34m")]
    WindowSize34m,
    #[serde(rename = "35m")]
    WindowSize35m,
    #[serde(rename = "36m")]
    WindowSize36m,
    #[serde(rename = "37m")]
    WindowSize37m,
    #[serde(rename = "38m")]
    WindowSize38m,
    #[serde(rename = "39m")]
    WindowSize39m,
    #[serde(rename = "40m")]
    WindowSize40m,
    #[serde(rename = "41m")]
    WindowSize41m,
    #[serde(rename = "42m")]
    WindowSize42m,
    #[serde(rename = "43m")]
    WindowSize43m,
    #[serde(rename = "44m")]
    WindowSize44m,
    #[serde(rename = "45m")]
    WindowSize45m,
    #[serde(rename = "46m")]
    WindowSize46m,
    #[serde(rename = "47m")]
    WindowSize47m,
    #[serde(rename = "48m")]
    WindowSize48m,
    #[serde(rename = "49m")]
    WindowSize49m,
    #[serde(rename = "50m")]
    WindowSize50m,
    #[serde(rename = "51m")]
    WindowSize51m,
    #[serde(rename = "52m")]
    WindowSize52m,
    #[serde(rename = "53m")]
    WindowSize53m,
    #[serde(rename = "54m")]
    WindowSize54m,
    #[serde(rename = "55m")]
    WindowSize55m,
    #[serde(rename = "56m")]
    WindowSize56m,
    #[serde(rename = "57m")]
    WindowSize57m,
    #[serde(rename = "58m")]
    WindowSize58m,
    #[serde(rename = "59m")]
    WindowSize59m,
    #[serde(rename = "1h")]
    WindowSize1h,
    #[serde(rename = "2h")]
    WindowSize2h,
    #[serde(rename = "3h")]
    WindowSize3h,
    #[serde(rename = "4h")]
    WindowSize4h,
    #[serde(rename = "5h")]
    WindowSize5h,
    #[serde(rename = "6h")]
    WindowSize6h,
    #[serde(rename = "7h")]
    WindowSize7h,
    #[serde(rename = "8h")]
    WindowSize8h,
    #[serde(rename = "9h")]
    WindowSize9h,
    #[serde(rename = "10h")]
    WindowSize10h,
    #[serde(rename = "11h")]
    WindowSize11h,
    #[serde(rename = "12h")]
    WindowSize12h,
    #[serde(rename = "13h")]
    WindowSize13h,
    #[serde(rename = "14h")]
    WindowSize14h,
    #[serde(rename = "15h")]
    WindowSize15h,
    #[serde(rename = "16h")]
    WindowSize16h,
    #[serde(rename = "17h")]
    WindowSize17h,
    #[serde(rename = "18h")]
    WindowSize18h,
    #[serde(rename = "19h")]
    WindowSize19h,
    #[serde(rename = "20h")]
    WindowSize20h,
    #[serde(rename = "21h")]
    WindowSize21h,
    #[serde(rename = "22h")]
    WindowSize22h,
    #[serde(rename = "23h")]
    WindowSize23h,
    #[serde(rename = "1d")]
    WindowSize1d,
    #[serde(rename = "2d")]
    WindowSize2d,
    #[serde(rename = "3d")]
    WindowSize3d,
    #[serde(rename = "4d")]
    WindowSize4d,
    #[serde(rename = "5d")]
    WindowSize5d,
    #[serde(rename = "6d")]
    WindowSize6d,
}

impl TickerWindowSizeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::WindowSize1m => "1m",
            Self::WindowSize2m => "2m",
            Self::WindowSize3m => "3m",
            Self::WindowSize4m => "4m",
            Self::WindowSize5m => "5m",
            Self::WindowSize6m => "6m",
            Self::WindowSize7m => "7m",
            Self::WindowSize8m => "8m",
            Self::WindowSize9m => "9m",
            Self::WindowSize10m => "10m",
            Self::WindowSize11m => "11m",
            Self::WindowSize12m => "12m",
            Self::WindowSize13m => "13m",
            Self::WindowSize14m => "14m",
            Self::WindowSize15m => "15m",
            Self::WindowSize16m => "16m",
            Self::WindowSize17m => "17m",
            Self::WindowSize18m => "18m",
            Self::WindowSize19m => "19m",
            Self::WindowSize20m => "20m",
            Self::WindowSize21m => "21m",
            Self::WindowSize22m => "22m",
            Self::WindowSize23m => "23m",
            Self::WindowSize24m => "24m",
            Self::WindowSize25m => "25m",
            Self::WindowSize26m => "26m",
            Self::WindowSize27m => "27m",
            Self::WindowSize28m => "28m",
            Self::WindowSize29m => "29m",
            Self::WindowSize30m => "30m",
            Self::WindowSize31m => "31m",
            Self::WindowSize32m => "32m",
            Self::WindowSize33m => "33m",
            Self::WindowSize34m => "34m",
            Self::WindowSize35m => "35m",
            Self::WindowSize36m => "36m",
            Self::WindowSize37m => "37m",
            Self::WindowSize38m => "38m",
            Self::WindowSize39m => "39m",
            Self::WindowSize40m => "40m",
            Self::WindowSize41m => "41m",
            Self::WindowSize42m => "42m",
            Self::WindowSize43m => "43m",
            Self::WindowSize44m => "44m",
            Self::WindowSize45m => "45m",
            Self::WindowSize46m => "46m",
            Self::WindowSize47m => "47m",
            Self::WindowSize48m => "48m",
            Self::WindowSize49m => "49m",
            Self::WindowSize50m => "50m",
            Self::WindowSize51m => "51m",
            Self::WindowSize52m => "52m",
            Self::WindowSize53m => "53m",
            Self::WindowSize54m => "54m",
            Self::WindowSize55m => "55m",
            Self::WindowSize56m => "56m",
            Self::WindowSize57m => "57m",
            Self::WindowSize58m => "58m",
            Self::WindowSize59m => "59m",
            Self::WindowSize1h => "1h",
            Self::WindowSize2h => "2h",
            Self::WindowSize3h => "3h",
            Self::WindowSize4h => "4h",
            Self::WindowSize5h => "5h",
            Self::WindowSize6h => "6h",
            Self::WindowSize7h => "7h",
            Self::WindowSize8h => "8h",
            Self::WindowSize9h => "9h",
            Self::WindowSize10h => "10h",
            Self::WindowSize11h => "11h",
            Self::WindowSize12h => "12h",
            Self::WindowSize13h => "13h",
            Self::WindowSize14h => "14h",
            Self::WindowSize15h => "15h",
            Self::WindowSize16h => "16h",
            Self::WindowSize17h => "17h",
            Self::WindowSize18h => "18h",
            Self::WindowSize19h => "19h",
            Self::WindowSize20h => "20h",
            Self::WindowSize21h => "21h",
            Self::WindowSize22h => "22h",
            Self::WindowSize23h => "23h",
            Self::WindowSize1d => "1d",
            Self::WindowSize2d => "2d",
            Self::WindowSize3d => "3d",
            Self::WindowSize4d => "4d",
            Self::WindowSize5d => "5d",
            Self::WindowSize6d => "6d",
        }
    }
}

impl std::str::FromStr for TickerWindowSizeEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "1m" => Ok(Self::WindowSize1m),
            "2m" => Ok(Self::WindowSize2m),
            "3m" => Ok(Self::WindowSize3m),
            "4m" => Ok(Self::WindowSize4m),
            "5m" => Ok(Self::WindowSize5m),
            "6m" => Ok(Self::WindowSize6m),
            "7m" => Ok(Self::WindowSize7m),
            "8m" => Ok(Self::WindowSize8m),
            "9m" => Ok(Self::WindowSize9m),
            "10m" => Ok(Self::WindowSize10m),
            "11m" => Ok(Self::WindowSize11m),
            "12m" => Ok(Self::WindowSize12m),
            "13m" => Ok(Self::WindowSize13m),
            "14m" => Ok(Self::WindowSize14m),
            "15m" => Ok(Self::WindowSize15m),
            "16m" => Ok(Self::WindowSize16m),
            "17m" => Ok(Self::WindowSize17m),
            "18m" => Ok(Self::WindowSize18m),
            "19m" => Ok(Self::WindowSize19m),
            "20m" => Ok(Self::WindowSize20m),
            "21m" => Ok(Self::WindowSize21m),
            "22m" => Ok(Self::WindowSize22m),
            "23m" => Ok(Self::WindowSize23m),
            "24m" => Ok(Self::WindowSize24m),
            "25m" => Ok(Self::WindowSize25m),
            "26m" => Ok(Self::WindowSize26m),
            "27m" => Ok(Self::WindowSize27m),
            "28m" => Ok(Self::WindowSize28m),
            "29m" => Ok(Self::WindowSize29m),
            "30m" => Ok(Self::WindowSize30m),
            "31m" => Ok(Self::WindowSize31m),
            "32m" => Ok(Self::WindowSize32m),
            "33m" => Ok(Self::WindowSize33m),
            "34m" => Ok(Self::WindowSize34m),
            "35m" => Ok(Self::WindowSize35m),
            "36m" => Ok(Self::WindowSize36m),
            "37m" => Ok(Self::WindowSize37m),
            "38m" => Ok(Self::WindowSize38m),
            "39m" => Ok(Self::WindowSize39m),
            "40m" => Ok(Self::WindowSize40m),
            "41m" => Ok(Self::WindowSize41m),
            "42m" => Ok(Self::WindowSize42m),
            "43m" => Ok(Self::WindowSize43m),
            "44m" => Ok(Self::WindowSize44m),
            "45m" => Ok(Self::WindowSize45m),
            "46m" => Ok(Self::WindowSize46m),
            "47m" => Ok(Self::WindowSize47m),
            "48m" => Ok(Self::WindowSize48m),
            "49m" => Ok(Self::WindowSize49m),
            "50m" => Ok(Self::WindowSize50m),
            "51m" => Ok(Self::WindowSize51m),
            "52m" => Ok(Self::WindowSize52m),
            "53m" => Ok(Self::WindowSize53m),
            "54m" => Ok(Self::WindowSize54m),
            "55m" => Ok(Self::WindowSize55m),
            "56m" => Ok(Self::WindowSize56m),
            "57m" => Ok(Self::WindowSize57m),
            "58m" => Ok(Self::WindowSize58m),
            "59m" => Ok(Self::WindowSize59m),
            "1h" => Ok(Self::WindowSize1h),
            "2h" => Ok(Self::WindowSize2h),
            "3h" => Ok(Self::WindowSize3h),
            "4h" => Ok(Self::WindowSize4h),
            "5h" => Ok(Self::WindowSize5h),
            "6h" => Ok(Self::WindowSize6h),
            "7h" => Ok(Self::WindowSize7h),
            "8h" => Ok(Self::WindowSize8h),
            "9h" => Ok(Self::WindowSize9h),
            "10h" => Ok(Self::WindowSize10h),
            "11h" => Ok(Self::WindowSize11h),
            "12h" => Ok(Self::WindowSize12h),
            "13h" => Ok(Self::WindowSize13h),
            "14h" => Ok(Self::WindowSize14h),
            "15h" => Ok(Self::WindowSize15h),
            "16h" => Ok(Self::WindowSize16h),
            "17h" => Ok(Self::WindowSize17h),
            "18h" => Ok(Self::WindowSize18h),
            "19h" => Ok(Self::WindowSize19h),
            "20h" => Ok(Self::WindowSize20h),
            "21h" => Ok(Self::WindowSize21h),
            "22h" => Ok(Self::WindowSize22h),
            "23h" => Ok(Self::WindowSize23h),
            "1d" => Ok(Self::WindowSize1d),
            "2d" => Ok(Self::WindowSize2d),
            "3d" => Ok(Self::WindowSize3d),
            "4d" => Ok(Self::WindowSize4d),
            "5d" => Ok(Self::WindowSize5d),
            "6d" => Ok(Self::WindowSize6d),
            other => Err(format!("invalid TickerWindowSizeEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TickerTypeEnum {
    #[serde(rename = "FULL")]
    Full,
    #[serde(rename = "MINI")]
    Mini,
}

impl TickerTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Full => "FULL",
            Self::Mini => "MINI",
        }
    }
}

impl std::str::FromStr for TickerTypeEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "FULL" => Ok(Self::Full),
            "MINI" => Ok(Self::Mini),
            other => Err(format!("invalid TickerTypeEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TickerSymbolStatusEnum {
    #[serde(rename = "TRADING")]
    Trading,
    #[serde(rename = "END_OF_DAY")]
    EndOfDay,
    #[serde(rename = "HALT")]
    Halt,
    #[serde(rename = "BREAK")]
    Break,
    #[serde(rename = "NON_REPRESENTABLE")]
    NonRepresentable,
}

impl TickerSymbolStatusEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Trading => "TRADING",
            Self::EndOfDay => "END_OF_DAY",
            Self::Halt => "HALT",
            Self::Break => "BREAK",
            Self::NonRepresentable => "NON_REPRESENTABLE",
        }
    }
}

impl std::str::FromStr for TickerSymbolStatusEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "TRADING" => Ok(Self::Trading),
            "END_OF_DAY" => Ok(Self::EndOfDay),
            "HALT" => Ok(Self::Halt),
            "BREAK" => Ok(Self::Break),
            "NON_REPRESENTABLE" => Ok(Self::NonRepresentable),
            other => Err(format!("invalid TickerSymbolStatusEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Ticker24hrTypeEnum {
    #[serde(rename = "FULL")]
    Full,
    #[serde(rename = "MINI")]
    Mini,
}

impl Ticker24hrTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Full => "FULL",
            Self::Mini => "MINI",
        }
    }
}

impl std::str::FromStr for Ticker24hrTypeEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "FULL" => Ok(Self::Full),
            "MINI" => Ok(Self::Mini),
            other => Err(format!("invalid Ticker24hrTypeEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Ticker24hrSymbolStatusEnum {
    #[serde(rename = "TRADING")]
    Trading,
    #[serde(rename = "END_OF_DAY")]
    EndOfDay,
    #[serde(rename = "HALT")]
    Halt,
    #[serde(rename = "BREAK")]
    Break,
    #[serde(rename = "NON_REPRESENTABLE")]
    NonRepresentable,
}

impl Ticker24hrSymbolStatusEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Trading => "TRADING",
            Self::EndOfDay => "END_OF_DAY",
            Self::Halt => "HALT",
            Self::Break => "BREAK",
            Self::NonRepresentable => "NON_REPRESENTABLE",
        }
    }
}

impl std::str::FromStr for Ticker24hrSymbolStatusEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "TRADING" => Ok(Self::Trading),
            "END_OF_DAY" => Ok(Self::EndOfDay),
            "HALT" => Ok(Self::Halt),
            "BREAK" => Ok(Self::Break),
            "NON_REPRESENTABLE" => Ok(Self::NonRepresentable),
            other => Err(format!("invalid Ticker24hrSymbolStatusEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TickerBookTickerSymbolStatusEnum {
    #[serde(rename = "TRADING")]
    Trading,
    #[serde(rename = "END_OF_DAY")]
    EndOfDay,
    #[serde(rename = "HALT")]
    Halt,
    #[serde(rename = "BREAK")]
    Break,
    #[serde(rename = "NON_REPRESENTABLE")]
    NonRepresentable,
}

impl TickerBookTickerSymbolStatusEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Trading => "TRADING",
            Self::EndOfDay => "END_OF_DAY",
            Self::Halt => "HALT",
            Self::Break => "BREAK",
            Self::NonRepresentable => "NON_REPRESENTABLE",
        }
    }
}

impl std::str::FromStr for TickerBookTickerSymbolStatusEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "TRADING" => Ok(Self::Trading),
            "END_OF_DAY" => Ok(Self::EndOfDay),
            "HALT" => Ok(Self::Halt),
            "BREAK" => Ok(Self::Break),
            "NON_REPRESENTABLE" => Ok(Self::NonRepresentable),
            other => Err(format!("invalid TickerBookTickerSymbolStatusEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TickerPriceSymbolStatusEnum {
    #[serde(rename = "TRADING")]
    Trading,
    #[serde(rename = "END_OF_DAY")]
    EndOfDay,
    #[serde(rename = "HALT")]
    Halt,
    #[serde(rename = "BREAK")]
    Break,
    #[serde(rename = "NON_REPRESENTABLE")]
    NonRepresentable,
}

impl TickerPriceSymbolStatusEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Trading => "TRADING",
            Self::EndOfDay => "END_OF_DAY",
            Self::Halt => "HALT",
            Self::Break => "BREAK",
            Self::NonRepresentable => "NON_REPRESENTABLE",
        }
    }
}

impl std::str::FromStr for TickerPriceSymbolStatusEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "TRADING" => Ok(Self::Trading),
            "END_OF_DAY" => Ok(Self::EndOfDay),
            "HALT" => Ok(Self::Halt),
            "BREAK" => Ok(Self::Break),
            "NON_REPRESENTABLE" => Ok(Self::NonRepresentable),
            other => Err(format!("invalid TickerPriceSymbolStatusEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TickerTradingDayTypeEnum {
    #[serde(rename = "FULL")]
    Full,
    #[serde(rename = "MINI")]
    Mini,
}

impl TickerTradingDayTypeEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Full => "FULL",
            Self::Mini => "MINI",
        }
    }
}

impl std::str::FromStr for TickerTradingDayTypeEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "FULL" => Ok(Self::Full),
            "MINI" => Ok(Self::Mini),
            other => Err(format!("invalid TickerTradingDayTypeEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TickerTradingDaySymbolStatusEnum {
    #[serde(rename = "TRADING")]
    Trading,
    #[serde(rename = "END_OF_DAY")]
    EndOfDay,
    #[serde(rename = "HALT")]
    Halt,
    #[serde(rename = "BREAK")]
    Break,
    #[serde(rename = "NON_REPRESENTABLE")]
    NonRepresentable,
}

impl TickerTradingDaySymbolStatusEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Trading => "TRADING",
            Self::EndOfDay => "END_OF_DAY",
            Self::Halt => "HALT",
            Self::Break => "BREAK",
            Self::NonRepresentable => "NON_REPRESENTABLE",
        }
    }
}

impl std::str::FromStr for TickerTradingDaySymbolStatusEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "TRADING" => Ok(Self::Trading),
            "END_OF_DAY" => Ok(Self::EndOfDay),
            "HALT" => Ok(Self::Halt),
            "BREAK" => Ok(Self::Break),
            "NON_REPRESENTABLE" => Ok(Self::NonRepresentable),
            other => Err(format!("invalid TickerTradingDaySymbolStatusEnum: {}", other).into()),
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum UiKlinesIntervalEnum {
    #[serde(rename = "1s")]
    Interval1s,
    #[serde(rename = "1m")]
    Interval1m,
    #[serde(rename = "3m")]
    Interval3m,
    #[serde(rename = "5m")]
    Interval5m,
    #[serde(rename = "15m")]
    Interval15m,
    #[serde(rename = "30m")]
    Interval30m,
    #[serde(rename = "1h")]
    Interval1h,
    #[serde(rename = "2h")]
    Interval2h,
    #[serde(rename = "4h")]
    Interval4h,
    #[serde(rename = "6h")]
    Interval6h,
    #[serde(rename = "8h")]
    Interval8h,
    #[serde(rename = "12h")]
    Interval12h,
    #[serde(rename = "1d")]
    Interval1d,
    #[serde(rename = "3d")]
    Interval3d,
    #[serde(rename = "1w")]
    Interval1w,
    #[serde(rename = "1M")]
    Interval1M,
}

impl UiKlinesIntervalEnum {
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Interval1s => "1s",
            Self::Interval1m => "1m",
            Self::Interval3m => "3m",
            Self::Interval5m => "5m",
            Self::Interval15m => "15m",
            Self::Interval30m => "30m",
            Self::Interval1h => "1h",
            Self::Interval2h => "2h",
            Self::Interval4h => "4h",
            Self::Interval6h => "6h",
            Self::Interval8h => "8h",
            Self::Interval12h => "12h",
            Self::Interval1d => "1d",
            Self::Interval3d => "3d",
            Self::Interval1w => "1w",
            Self::Interval1M => "1M",
        }
    }
}

impl std::str::FromStr for UiKlinesIntervalEnum {
    type Err = Box<dyn std::error::Error + Send + Sync>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "1s" => Ok(Self::Interval1s),
            "1m" => Ok(Self::Interval1m),
            "3m" => Ok(Self::Interval3m),
            "5m" => Ok(Self::Interval5m),
            "15m" => Ok(Self::Interval15m),
            "30m" => Ok(Self::Interval30m),
            "1h" => Ok(Self::Interval1h),
            "2h" => Ok(Self::Interval2h),
            "4h" => Ok(Self::Interval4h),
            "6h" => Ok(Self::Interval6h),
            "8h" => Ok(Self::Interval8h),
            "12h" => Ok(Self::Interval12h),
            "1d" => Ok(Self::Interval1d),
            "3d" => Ok(Self::Interval3d),
            "1w" => Ok(Self::Interval1w),
            "1M" => Ok(Self::Interval1M),
            other => Err(format!("invalid UiKlinesIntervalEnum: {}", other).into()),
        }
    }
}

/// Request parameters for the [`agg_trades`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`agg_trades`](#method.agg_trades).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct AggTradesParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// ID to get aggregate trades from INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub from_id: Option<i64>,
    /// Timestamp in ms to get aggregate trades from INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    /// Timestamp in ms to get aggregate trades until INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Default: 500; Maximum: 1000.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i32>,
}

impl AggTradesParams {
    /// Create a builder for [`agg_trades`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> AggTradesParamsBuilder {
        AggTradesParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`avg_price`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`avg_price`](#method.avg_price).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct AvgPriceParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
}

impl AvgPriceParams {
    /// Create a builder for [`avg_price`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> AvgPriceParamsBuilder {
        AvgPriceParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`depth`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`depth`](#method.depth).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct DepthParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// Default: 500; Maximum: 1000.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i32>,
    ///
    /// The `symbol_status` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol_status: Option<DepthSymbolStatusEnum>,
}

impl DepthParams {
    /// Create a builder for [`depth`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> DepthParamsBuilder {
        DepthParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`get_trades`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`get_trades`](#method.get_trades).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct GetTradesParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// Default: 500; Maximum: 1000.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i32>,
}

impl GetTradesParams {
    /// Create a builder for [`get_trades`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> GetTradesParamsBuilder {
        GetTradesParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`historical_trades`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`historical_trades`](#method.historical_trades).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct HistoricalTradesParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    /// Default: 500; Maximum: 1000.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i32>,
    /// ID to get aggregate trades from INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub from_id: Option<i64>,
}

impl HistoricalTradesParams {
    /// Create a builder for [`historical_trades`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    ///
    #[must_use]
    pub fn builder(symbol: String) -> HistoricalTradesParamsBuilder {
        HistoricalTradesParamsBuilder::default().symbol(symbol)
    }
}
/// Request parameters for the [`klines`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`klines`](#method.klines).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct KlinesParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `interval` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub interval: KlinesIntervalEnum,
    /// Timestamp in ms to get aggregate trades from INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    /// Timestamp in ms to get aggregate trades until INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Default: 0 (UTC)
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub time_zone: Option<String>,
    /// Default: 500; Maximum: 1000.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i32>,
}

impl KlinesParams {
    /// Create a builder for [`klines`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `interval` — String
    ///
    #[must_use]
    pub fn builder(symbol: String, interval: KlinesIntervalEnum) -> KlinesParamsBuilder {
        KlinesParamsBuilder::default()
            .symbol(symbol)
            .interval(interval)
    }
}
/// Request parameters for the [`ticker`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`ticker`](#method.ticker).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct TickerParams {
    /// Symbol to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    /// List of symbols to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbols: Option<Vec<String>>,
    ///
    /// The `window_size` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub window_size: Option<TickerWindowSizeEnum>,
    ///
    /// The `r#type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub r#type: Option<TickerTypeEnum>,
    ///
    /// The `symbol_status` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol_status: Option<TickerSymbolStatusEnum>,
}

impl TickerParams {
    /// Create a builder for [`ticker`].
    ///
    #[must_use]
    pub fn builder() -> TickerParamsBuilder {
        TickerParamsBuilder::default()
    }
}
/// Request parameters for the [`ticker24hr`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`ticker24hr`](#method.ticker24hr).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct Ticker24hrParams {
    /// Symbol to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    /// List of symbols to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbols: Option<Vec<String>>,
    ///
    /// The `r#type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub r#type: Option<Ticker24hrTypeEnum>,
    ///
    /// The `symbol_status` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol_status: Option<Ticker24hrSymbolStatusEnum>,
}

impl Ticker24hrParams {
    /// Create a builder for [`ticker24hr`].
    ///
    #[must_use]
    pub fn builder() -> Ticker24hrParamsBuilder {
        Ticker24hrParamsBuilder::default()
    }
}
/// Request parameters for the [`ticker_book_ticker`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`ticker_book_ticker`](#method.ticker_book_ticker).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct TickerBookTickerParams {
    /// Symbol to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    /// List of symbols to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbols: Option<Vec<String>>,
    ///
    /// The `symbol_status` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol_status: Option<TickerBookTickerSymbolStatusEnum>,
}

impl TickerBookTickerParams {
    /// Create a builder for [`ticker_book_ticker`].
    ///
    #[must_use]
    pub fn builder() -> TickerBookTickerParamsBuilder {
        TickerBookTickerParamsBuilder::default()
    }
}
/// Request parameters for the [`ticker_price`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`ticker_price`](#method.ticker_price).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct TickerPriceParams {
    /// Symbol to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    /// List of symbols to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbols: Option<Vec<String>>,
    ///
    /// The `symbol_status` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol_status: Option<TickerPriceSymbolStatusEnum>,
}

impl TickerPriceParams {
    /// Create a builder for [`ticker_price`].
    ///
    #[must_use]
    pub fn builder() -> TickerPriceParamsBuilder {
        TickerPriceParamsBuilder::default()
    }
}
/// Request parameters for the [`ticker_trading_day`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`ticker_trading_day`](#method.ticker_trading_day).
#[derive(Clone, Debug, Builder, Default)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct TickerTradingDayParams {
    /// Symbol to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol: Option<String>,
    /// List of symbols to query
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbols: Option<Vec<String>>,
    /// Default: 0 (UTC)
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub time_zone: Option<String>,
    ///
    /// The `r#type` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub r#type: Option<TickerTradingDayTypeEnum>,
    ///
    /// The `symbol_status` parameter.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub symbol_status: Option<TickerTradingDaySymbolStatusEnum>,
}

impl TickerTradingDayParams {
    /// Create a builder for [`ticker_trading_day`].
    ///
    #[must_use]
    pub fn builder() -> TickerTradingDayParamsBuilder {
        TickerTradingDayParamsBuilder::default()
    }
}
/// Request parameters for the [`ui_klines`] operation.
///
/// This struct holds all of the inputs you can pass when calling
/// [`ui_klines`](#method.ui_klines).
#[derive(Clone, Debug, Builder)]
#[builder(pattern = "owned", build_fn(error = "ParamBuildError"))]
pub struct UiKlinesParams {
    ///
    /// The `symbol` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub symbol: String,
    ///
    /// The `interval` parameter.
    ///
    /// This field is **required.
    #[builder(setter(into))]
    pub interval: UiKlinesIntervalEnum,
    /// Timestamp in ms to get aggregate trades from INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub start_time: Option<i64>,
    /// Timestamp in ms to get aggregate trades until INCLUSIVE.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub end_time: Option<i64>,
    /// Default: 0 (UTC)
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub time_zone: Option<String>,
    /// Default: 500; Maximum: 1000.
    ///
    /// This field is **optional.
    #[builder(setter(into), default)]
    pub limit: Option<i32>,
}

impl UiKlinesParams {
    /// Create a builder for [`ui_klines`].
    ///
    /// Required parameters:
    ///
    /// * `symbol` — String
    /// * `interval` — String
    ///
    #[must_use]
    pub fn builder(symbol: String, interval: UiKlinesIntervalEnum) -> UiKlinesParamsBuilder {
        UiKlinesParamsBuilder::default()
            .symbol(symbol)
            .interval(interval)
    }
}

#[async_trait]
impl MarketApi for MarketApiClient {
    async fn agg_trades(
        &self,
        params: AggTradesParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::AggTradesResponseInner>>> {
        let AggTradesParams {
            symbol,
            from_id,
            start_time,
            end_time,
            limit,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = from_id {
            query_params.insert("fromId".to_string(), json!(rw));
        }

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        send_request::<Vec<models::AggTradesResponseInner>>(
            &self.configuration,
            "/api/v3/aggTrades",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn avg_price(
        &self,
        params: AvgPriceParams,
    ) -> anyhow::Result<RestApiResponse<models::AvgPriceResponse>> {
        let AvgPriceParams { symbol } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        send_request::<models::AvgPriceResponse>(
            &self.configuration,
            "/api/v3/avgPrice",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn depth(
        &self,
        params: DepthParams,
    ) -> anyhow::Result<RestApiResponse<models::DepthResponse>> {
        let DepthParams {
            symbol,
            limit,
            symbol_status,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = symbol_status {
            query_params.insert("symbolStatus".to_string(), json!(rw));
        }

        send_request::<models::DepthResponse>(
            &self.configuration,
            "/api/v3/depth",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn get_trades(
        &self,
        params: GetTradesParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::HistoricalTradesResponseInner>>> {
        let GetTradesParams { symbol, limit } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        send_request::<Vec<models::HistoricalTradesResponseInner>>(
            &self.configuration,
            "/api/v3/trades",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn historical_trades(
        &self,
        params: HistoricalTradesParams,
    ) -> anyhow::Result<RestApiResponse<Vec<models::HistoricalTradesResponseInner>>> {
        let HistoricalTradesParams {
            symbol,
            limit,
            from_id,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        if let Some(rw) = from_id {
            query_params.insert("fromId".to_string(), json!(rw));
        }

        send_request::<Vec<models::HistoricalTradesResponseInner>>(
            &self.configuration,
            "/api/v3/historicalTrades",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn klines(
        &self,
        params: KlinesParams,
    ) -> anyhow::Result<RestApiResponse<Vec<Vec<models::KlinesItemInner>>>> {
        let KlinesParams {
            symbol,
            interval,
            start_time,
            end_time,
            time_zone,
            limit,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        query_params.insert("interval".to_string(), json!(interval));

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = time_zone {
            query_params.insert("timeZone".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        send_request::<Vec<Vec<models::KlinesItemInner>>>(
            &self.configuration,
            "/api/v3/klines",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn ticker(
        &self,
        params: TickerParams,
    ) -> anyhow::Result<RestApiResponse<models::TickerResponse>> {
        let TickerParams {
            symbol,
            symbols,
            window_size,
            r#type,
            symbol_status,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = symbols {
            query_params.insert("symbols".to_string(), json!(rw));
        }

        if let Some(rw) = window_size {
            query_params.insert("windowSize".to_string(), json!(rw));
        }

        if let Some(rw) = r#type {
            query_params.insert("type".to_string(), json!(rw));
        }

        if let Some(rw) = symbol_status {
            query_params.insert("symbolStatus".to_string(), json!(rw));
        }

        send_request::<models::TickerResponse>(
            &self.configuration,
            "/api/v3/ticker",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn ticker24hr(
        &self,
        params: Ticker24hrParams,
    ) -> anyhow::Result<RestApiResponse<models::Ticker24hrResponse>> {
        let Ticker24hrParams {
            symbol,
            symbols,
            r#type,
            symbol_status,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = symbols {
            query_params.insert("symbols".to_string(), json!(rw));
        }

        if let Some(rw) = r#type {
            query_params.insert("type".to_string(), json!(rw));
        }

        if let Some(rw) = symbol_status {
            query_params.insert("symbolStatus".to_string(), json!(rw));
        }

        send_request::<models::Ticker24hrResponse>(
            &self.configuration,
            "/api/v3/ticker/24hr",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn ticker_book_ticker(
        &self,
        params: TickerBookTickerParams,
    ) -> anyhow::Result<RestApiResponse<models::TickerBookTickerResponse>> {
        let TickerBookTickerParams {
            symbol,
            symbols,
            symbol_status,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = symbols {
            query_params.insert("symbols".to_string(), json!(rw));
        }

        if let Some(rw) = symbol_status {
            query_params.insert("symbolStatus".to_string(), json!(rw));
        }

        send_request::<models::TickerBookTickerResponse>(
            &self.configuration,
            "/api/v3/ticker/bookTicker",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn ticker_price(
        &self,
        params: TickerPriceParams,
    ) -> anyhow::Result<RestApiResponse<models::TickerPriceResponse>> {
        let TickerPriceParams {
            symbol,
            symbols,
            symbol_status,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = symbols {
            query_params.insert("symbols".to_string(), json!(rw));
        }

        if let Some(rw) = symbol_status {
            query_params.insert("symbolStatus".to_string(), json!(rw));
        }

        send_request::<models::TickerPriceResponse>(
            &self.configuration,
            "/api/v3/ticker/price",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn ticker_trading_day(
        &self,
        params: TickerTradingDayParams,
    ) -> anyhow::Result<RestApiResponse<models::TickerTradingDayResponse>> {
        let TickerTradingDayParams {
            symbol,
            symbols,
            time_zone,
            r#type,
            symbol_status,
        } = params;

        let mut query_params = BTreeMap::new();

        if let Some(rw) = symbol {
            query_params.insert("symbol".to_string(), json!(rw));
        }

        if let Some(rw) = symbols {
            query_params.insert("symbols".to_string(), json!(rw));
        }

        if let Some(rw) = time_zone {
            query_params.insert("timeZone".to_string(), json!(rw));
        }

        if let Some(rw) = r#type {
            query_params.insert("type".to_string(), json!(rw));
        }

        if let Some(rw) = symbol_status {
            query_params.insert("symbolStatus".to_string(), json!(rw));
        }

        send_request::<models::TickerTradingDayResponse>(
            &self.configuration,
            "/api/v3/ticker/tradingDay",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }

    async fn ui_klines(
        &self,
        params: UiKlinesParams,
    ) -> anyhow::Result<RestApiResponse<Vec<Vec<models::KlinesItemInner>>>> {
        let UiKlinesParams {
            symbol,
            interval,
            start_time,
            end_time,
            time_zone,
            limit,
        } = params;

        let mut query_params = BTreeMap::new();

        query_params.insert("symbol".to_string(), json!(symbol));

        query_params.insert("interval".to_string(), json!(interval));

        if let Some(rw) = start_time {
            query_params.insert("startTime".to_string(), json!(rw));
        }

        if let Some(rw) = end_time {
            query_params.insert("endTime".to_string(), json!(rw));
        }

        if let Some(rw) = time_zone {
            query_params.insert("timeZone".to_string(), json!(rw));
        }

        if let Some(rw) = limit {
            query_params.insert("limit".to_string(), json!(rw));
        }

        send_request::<Vec<Vec<models::KlinesItemInner>>>(
            &self.configuration,
            "/api/v3/uiKlines",
            reqwest::Method::GET,
            query_params,
            if HAS_TIME_UNIT {
                self.configuration.time_unit
            } else {
                None
            },
            false,
        )
        .await
    }
}

#[cfg(all(test, feature = "spot"))]
mod tests {
    use super::*;
    use crate::TOKIO_SHARED_RT;
    use crate::{errors::ConnectorError, models::DataFuture, models::RestApiRateLimit};
    use async_trait::async_trait;
    use std::collections::HashMap;

    struct DummyRestApiResponse<T> {
        inner: Box<dyn FnOnce() -> DataFuture<Result<T, ConnectorError>> + Send + Sync>,
        status: u16,
        headers: HashMap<String, String>,
        rate_limits: Option<Vec<RestApiRateLimit>>,
    }

    impl<T> From<DummyRestApiResponse<T>> for RestApiResponse<T> {
        fn from(dummy: DummyRestApiResponse<T>) -> Self {
            Self {
                data_fn: dummy.inner,
                status: dummy.status,
                headers: dummy.headers,
                rate_limits: dummy.rate_limits,
            }
        }
    }

    struct MockMarketApiClient {
        force_error: bool,
    }

    #[async_trait]
    impl MarketApi for MockMarketApiClient {
        async fn agg_trades(
            &self,
            _params: AggTradesParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::AggTradesResponseInner>>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"a":26129,"p":"0.01633102","q":"4.70443515","f":27781,"l":27781,"T":1498793709153,"m":true,"M":true}]"#).unwrap();
            let dummy_response: Vec<models::AggTradesResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::AggTradesResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn avg_price(
            &self,
            _params: AvgPriceParams,
        ) -> anyhow::Result<RestApiResponse<models::AvgPriceResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(
                r#"{"mins":5,"price":"9.35751834","closeTime":1694061154503}"#,
            )
            .unwrap();
            let dummy_response: models::AvgPriceResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::AvgPriceResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn depth(
            &self,
            _params: DepthParams,
        ) -> anyhow::Result<RestApiResponse<models::DepthResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"lastUpdateId":1027024,"bids":[["4.00000000","431.00000000"]],"asks":[["4.00000200","12.00000000"]]}"#).unwrap();
            let dummy_response: models::DepthResponse = serde_json::from_value(resp_json.clone())
                .expect("should parse into models::DepthResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn get_trades(
            &self,
            _params: GetTradesParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::HistoricalTradesResponseInner>>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"id":28457,"price":"4.00000100","qty":"12.00000000","quoteQty":"48.000012","time":1499865549590,"isBuyerMaker":true,"isBestMatch":true}]"#).unwrap();
            let dummy_response: Vec<models::HistoricalTradesResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::HistoricalTradesResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn historical_trades(
            &self,
            _params: HistoricalTradesParams,
        ) -> anyhow::Result<RestApiResponse<Vec<models::HistoricalTradesResponseInner>>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[{"id":28457,"price":"4.00000100","qty":"12.00000000","quoteQty":"48.000012","time":1499865549590,"isBuyerMaker":true,"isBestMatch":true}]"#).unwrap();
            let dummy_response: Vec<models::HistoricalTradesResponseInner> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<models::HistoricalTradesResponseInner>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn klines(
            &self,
            _params: KlinesParams,
        ) -> anyhow::Result<RestApiResponse<Vec<Vec<models::KlinesItemInner>>>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[[1499040000000,"0.01634790","0.80000000","0.01575800","0.01577100","148976.11427815",1499644799999,"2434.19055334",308,"1756.87402397","28.46694368","0"]]"#).unwrap();
            let dummy_response: Vec<Vec<models::KlinesItemInner>> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<Vec<models::KlinesItemInner>>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn ticker(
            &self,
            _params: TickerParams,
        ) -> anyhow::Result<RestApiResponse<models::TickerResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"LTCBTC","priceChange":"-8.00000000","priceChangePercent":"-88.889","weightedAvgPrice":"2.60427807","openPrice":"0.10000000","highPrice":"2.00000000","lowPrice":"0.10000000","lastPrice":"2.00000000","volume":"39.00000000","quoteVolume":"13.40000000","openTime":1656986580000,"closeTime":1657001016795,"firstId":0,"lastId":34,"count":35}"#).unwrap();
            let dummy_response: models::TickerResponse = serde_json::from_value(resp_json.clone())
                .expect("should parse into models::TickerResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn ticker24hr(
            &self,
            _params: Ticker24hrParams,
        ) -> anyhow::Result<RestApiResponse<models::Ticker24hrResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"BNBBTC","priceChange":"-94.99999800","priceChangePercent":"-95.960","weightedAvgPrice":"0.29628482","prevClosePrice":"0.10002000","lastPrice":"4.00000200","lastQty":"200.00000000","bidPrice":"4.00000000","bidQty":"100.00000000","askPrice":"4.00000200","askQty":"100.00000000","openPrice":"99.00000000","highPrice":"100.00000000","lowPrice":"0.10000000","volume":"8913.30000000","quoteVolume":"15.30000000","openTime":1499783499040,"closeTime":1499869899040,"firstId":28385,"lastId":28460,"count":76}"#).unwrap();
            let dummy_response: models::Ticker24hrResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::Ticker24hrResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn ticker_book_ticker(
            &self,
            _params: TickerBookTickerParams,
        ) -> anyhow::Result<RestApiResponse<models::TickerBookTickerResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"LTCBTC","bidPrice":"4.00000000","bidQty":"431.00000000","askPrice":"4.00000200","askQty":"9.00000000"}"#).unwrap();
            let dummy_response: models::TickerBookTickerResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::TickerBookTickerResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn ticker_price(
            &self,
            _params: TickerPriceParams,
        ) -> anyhow::Result<RestApiResponse<models::TickerPriceResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value =
                serde_json::from_str(r#"{"symbol":"LTCBTC","price":"4.00000200"}"#).unwrap();
            let dummy_response: models::TickerPriceResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::TickerPriceResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn ticker_trading_day(
            &self,
            _params: TickerTradingDayParams,
        ) -> anyhow::Result<RestApiResponse<models::TickerTradingDayResponse>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"BTCUSDT","priceChange":"-83.13000000","priceChangePercent":"-0.317","weightedAvgPrice":"26234.58803036","openPrice":"26304.80000000","highPrice":"26397.46000000","lowPrice":"26088.34000000","lastPrice":"26221.67000000","volume":"18495.35066000","quoteVolume":"485217905.04210480","openTime":1695686400000,"closeTime":1695772799999,"firstId":3220151555,"lastId":3220849281,"count":697727}"#).unwrap();
            let dummy_response: models::TickerTradingDayResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::TickerTradingDayResponse");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }

        async fn ui_klines(
            &self,
            _params: UiKlinesParams,
        ) -> anyhow::Result<RestApiResponse<Vec<Vec<models::KlinesItemInner>>>> {
            if self.force_error {
                return Err(
                    ConnectorError::ConnectorClientError("ResponseError".to_string()).into(),
                );
            }

            let resp_json: Value = serde_json::from_str(r#"[[1499040000000,"0.01634790","0.80000000","0.01575800","0.01577100","148976.11427815",1499644799999,"2434.19055334",308,"1756.87402397","28.46694368","0"]]"#).unwrap();
            let dummy_response: Vec<Vec<models::KlinesItemInner>> =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into Vec<Vec<models::KlinesItemInner>>");

            let dummy = DummyRestApiResponse {
                inner: Box::new(move || Box::pin(async move { Ok(dummy_response) })),
                status: 200,
                headers: HashMap::new(),
                rate_limits: None,
            };

            Ok(dummy.into())
        }
    }

    #[test]
    fn agg_trades_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = AggTradesParams::builder("BNBUSDT".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"a":26129,"p":"0.01633102","q":"4.70443515","f":27781,"l":27781,"T":1498793709153,"m":true,"M":true}]"#).unwrap();
            let expected_response : Vec<models::AggTradesResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::AggTradesResponseInner>");

            let resp = client.agg_trades(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn agg_trades_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = AggTradesParams::builder("BNBUSDT".to_string(),).from_id(1).start_time(1735693200000).end_time(1735693200000).limit(500).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"a":26129,"p":"0.01633102","q":"4.70443515","f":27781,"l":27781,"T":1498793709153,"m":true,"M":true}]"#).unwrap();
            let expected_response : Vec<models::AggTradesResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::AggTradesResponseInner>");

            let resp = client.agg_trades(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn agg_trades_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: true };

            let params = AggTradesParams::builder("BNBUSDT".to_string())
                .build()
                .unwrap();

            match client.agg_trades(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn avg_price_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = AvgPriceParams::builder("BNBUSDT".to_string())
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"mins":5,"price":"9.35751834","closeTime":1694061154503}"#,
            )
            .unwrap();
            let expected_response: models::AvgPriceResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::AvgPriceResponse");

            let resp = client.avg_price(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn avg_price_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = AvgPriceParams::builder("BNBUSDT".to_string())
                .build()
                .unwrap();

            let resp_json: Value = serde_json::from_str(
                r#"{"mins":5,"price":"9.35751834","closeTime":1694061154503}"#,
            )
            .unwrap();
            let expected_response: models::AvgPriceResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::AvgPriceResponse");

            let resp = client.avg_price(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn avg_price_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: true };

            let params = AvgPriceParams::builder("BNBUSDT".to_string())
                .build()
                .unwrap();

            match client.avg_price(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn depth_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = DepthParams::builder("BNBUSDT".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"lastUpdateId":1027024,"bids":[["4.00000000","431.00000000"]],"asks":[["4.00000200","12.00000000"]]}"#).unwrap();
            let expected_response : models::DepthResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::DepthResponse");

            let resp = client.depth(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn depth_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = DepthParams::builder("BNBUSDT".to_string(),).limit(500).symbol_status(DepthSymbolStatusEnum::Trading).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"lastUpdateId":1027024,"bids":[["4.00000000","431.00000000"]],"asks":[["4.00000200","12.00000000"]]}"#).unwrap();
            let expected_response : models::DepthResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::DepthResponse");

            let resp = client.depth(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn depth_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: true };

            let params = DepthParams::builder("BNBUSDT".to_string()).build().unwrap();

            match client.depth(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn get_trades_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = GetTradesParams::builder("BNBUSDT".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"id":28457,"price":"4.00000100","qty":"12.00000000","quoteQty":"48.000012","time":1499865549590,"isBuyerMaker":true,"isBestMatch":true}]"#).unwrap();
            let expected_response : Vec<models::HistoricalTradesResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::HistoricalTradesResponseInner>");

            let resp = client.get_trades(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_trades_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = GetTradesParams::builder("BNBUSDT".to_string(),).limit(500).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"id":28457,"price":"4.00000100","qty":"12.00000000","quoteQty":"48.000012","time":1499865549590,"isBuyerMaker":true,"isBestMatch":true}]"#).unwrap();
            let expected_response : Vec<models::HistoricalTradesResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::HistoricalTradesResponseInner>");

            let resp = client.get_trades(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn get_trades_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: true };

            let params = GetTradesParams::builder("BNBUSDT".to_string())
                .build()
                .unwrap();

            match client.get_trades(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn historical_trades_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = HistoricalTradesParams::builder("BNBUSDT".to_string(),).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"id":28457,"price":"4.00000100","qty":"12.00000000","quoteQty":"48.000012","time":1499865549590,"isBuyerMaker":true,"isBestMatch":true}]"#).unwrap();
            let expected_response : Vec<models::HistoricalTradesResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::HistoricalTradesResponseInner>");

            let resp = client.historical_trades(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn historical_trades_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = HistoricalTradesParams::builder("BNBUSDT".to_string(),).limit(500).from_id(1).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[{"id":28457,"price":"4.00000100","qty":"12.00000000","quoteQty":"48.000012","time":1499865549590,"isBuyerMaker":true,"isBestMatch":true}]"#).unwrap();
            let expected_response : Vec<models::HistoricalTradesResponseInner> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<models::HistoricalTradesResponseInner>");

            let resp = client.historical_trades(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn historical_trades_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: true };

            let params = HistoricalTradesParams::builder("BNBUSDT".to_string())
                .build()
                .unwrap();

            match client.historical_trades(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn klines_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = KlinesParams::builder("BNBUSDT".to_string(),KlinesIntervalEnum::Interval1s,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[[1499040000000,"0.01634790","0.80000000","0.01575800","0.01577100","148976.11427815",1499644799999,"2434.19055334",308,"1756.87402397","28.46694368","0"]]"#).unwrap();
            let expected_response : Vec<Vec<models::KlinesItemInner>> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<Vec<models::KlinesItemInner>>");

            let resp = client.klines(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn klines_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = KlinesParams::builder("BNBUSDT".to_string(),KlinesIntervalEnum::Interval1s,).start_time(1735693200000).end_time(1735693200000).time_zone("time_zone_example".to_string()).limit(500).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[[1499040000000,"0.01634790","0.80000000","0.01575800","0.01577100","148976.11427815",1499644799999,"2434.19055334",308,"1756.87402397","28.46694368","0"]]"#).unwrap();
            let expected_response : Vec<Vec<models::KlinesItemInner>> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<Vec<models::KlinesItemInner>>");

            let resp = client.klines(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn klines_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: true };

            let params =
                KlinesParams::builder("BNBUSDT".to_string(), KlinesIntervalEnum::Interval1s)
                    .build()
                    .unwrap();

            match client.klines(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn ticker_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = TickerParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"LTCBTC","priceChange":"-8.00000000","priceChangePercent":"-88.889","weightedAvgPrice":"2.60427807","openPrice":"0.10000000","highPrice":"2.00000000","lowPrice":"0.10000000","lastPrice":"2.00000000","volume":"39.00000000","quoteVolume":"13.40000000","openTime":1656986580000,"closeTime":1657001016795,"firstId":0,"lastId":34,"count":35}"#).unwrap();
            let expected_response : models::TickerResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::TickerResponse");

            let resp = client.ticker(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ticker_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = TickerParams::builder().symbol("BNBUSDT".to_string()).symbols(["null".to_string(),].to_vec()).window_size(TickerWindowSizeEnum::WindowSize1m).r#type(TickerTypeEnum::Full).symbol_status(TickerSymbolStatusEnum::Trading).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"LTCBTC","priceChange":"-8.00000000","priceChangePercent":"-88.889","weightedAvgPrice":"2.60427807","openPrice":"0.10000000","highPrice":"2.00000000","lowPrice":"0.10000000","lastPrice":"2.00000000","volume":"39.00000000","quoteVolume":"13.40000000","openTime":1656986580000,"closeTime":1657001016795,"firstId":0,"lastId":34,"count":35}"#).unwrap();
            let expected_response : models::TickerResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::TickerResponse");

            let resp = client.ticker(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ticker_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: true };

            let params = TickerParams::builder().build().unwrap();

            match client.ticker(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn ticker24hr_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = Ticker24hrParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"BNBBTC","priceChange":"-94.99999800","priceChangePercent":"-95.960","weightedAvgPrice":"0.29628482","prevClosePrice":"0.10002000","lastPrice":"4.00000200","lastQty":"200.00000000","bidPrice":"4.00000000","bidQty":"100.00000000","askPrice":"4.00000200","askQty":"100.00000000","openPrice":"99.00000000","highPrice":"100.00000000","lowPrice":"0.10000000","volume":"8913.30000000","quoteVolume":"15.30000000","openTime":1499783499040,"closeTime":1499869899040,"firstId":28385,"lastId":28460,"count":76}"#).unwrap();
            let expected_response : models::Ticker24hrResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::Ticker24hrResponse");

            let resp = client.ticker24hr(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ticker24hr_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = Ticker24hrParams::builder().symbol("BNBUSDT".to_string()).symbols(["null".to_string(),].to_vec()).r#type(Ticker24hrTypeEnum::Full).symbol_status(Ticker24hrSymbolStatusEnum::Trading).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"BNBBTC","priceChange":"-94.99999800","priceChangePercent":"-95.960","weightedAvgPrice":"0.29628482","prevClosePrice":"0.10002000","lastPrice":"4.00000200","lastQty":"200.00000000","bidPrice":"4.00000000","bidQty":"100.00000000","askPrice":"4.00000200","askQty":"100.00000000","openPrice":"99.00000000","highPrice":"100.00000000","lowPrice":"0.10000000","volume":"8913.30000000","quoteVolume":"15.30000000","openTime":1499783499040,"closeTime":1499869899040,"firstId":28385,"lastId":28460,"count":76}"#).unwrap();
            let expected_response : models::Ticker24hrResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::Ticker24hrResponse");

            let resp = client.ticker24hr(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ticker24hr_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: true };

            let params = Ticker24hrParams::builder().build().unwrap();

            match client.ticker24hr(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn ticker_book_ticker_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = TickerBookTickerParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"LTCBTC","bidPrice":"4.00000000","bidQty":"431.00000000","askPrice":"4.00000200","askQty":"9.00000000"}"#).unwrap();
            let expected_response : models::TickerBookTickerResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::TickerBookTickerResponse");

            let resp = client.ticker_book_ticker(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ticker_book_ticker_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = TickerBookTickerParams::builder().symbol("BNBUSDT".to_string()).symbols(["null".to_string(),].to_vec()).symbol_status(TickerBookTickerSymbolStatusEnum::Trading).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"LTCBTC","bidPrice":"4.00000000","bidQty":"431.00000000","askPrice":"4.00000200","askQty":"9.00000000"}"#).unwrap();
            let expected_response : models::TickerBookTickerResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::TickerBookTickerResponse");

            let resp = client.ticker_book_ticker(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ticker_book_ticker_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: true };

            let params = TickerBookTickerParams::builder().build().unwrap();

            match client.ticker_book_ticker(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn ticker_price_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = TickerPriceParams::builder().build().unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"symbol":"LTCBTC","price":"4.00000200"}"#).unwrap();
            let expected_response: models::TickerPriceResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::TickerPriceResponse");

            let resp = client
                .ticker_price(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ticker_price_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = TickerPriceParams::builder()
                .symbol("BNBUSDT".to_string())
                .symbols(["null".to_string()].to_vec())
                .symbol_status(TickerPriceSymbolStatusEnum::Trading)
                .build()
                .unwrap();

            let resp_json: Value =
                serde_json::from_str(r#"{"symbol":"LTCBTC","price":"4.00000200"}"#).unwrap();
            let expected_response: models::TickerPriceResponse =
                serde_json::from_value(resp_json.clone())
                    .expect("should parse into models::TickerPriceResponse");

            let resp = client
                .ticker_price(params)
                .await
                .expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ticker_price_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: true };

            let params = TickerPriceParams::builder().build().unwrap();

            match client.ticker_price(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn ticker_trading_day_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = TickerTradingDayParams::builder().build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"BTCUSDT","priceChange":"-83.13000000","priceChangePercent":"-0.317","weightedAvgPrice":"26234.58803036","openPrice":"26304.80000000","highPrice":"26397.46000000","lowPrice":"26088.34000000","lastPrice":"26221.67000000","volume":"18495.35066000","quoteVolume":"485217905.04210480","openTime":1695686400000,"closeTime":1695772799999,"firstId":3220151555,"lastId":3220849281,"count":697727}"#).unwrap();
            let expected_response : models::TickerTradingDayResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::TickerTradingDayResponse");

            let resp = client.ticker_trading_day(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ticker_trading_day_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = TickerTradingDayParams::builder().symbol("BNBUSDT".to_string()).symbols(["null".to_string(),].to_vec()).time_zone("time_zone_example".to_string()).r#type(TickerTradingDayTypeEnum::Full).symbol_status(TickerTradingDaySymbolStatusEnum::Trading).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"{"symbol":"BTCUSDT","priceChange":"-83.13000000","priceChangePercent":"-0.317","weightedAvgPrice":"26234.58803036","openPrice":"26304.80000000","highPrice":"26397.46000000","lowPrice":"26088.34000000","lastPrice":"26221.67000000","volume":"18495.35066000","quoteVolume":"485217905.04210480","openTime":1695686400000,"closeTime":1695772799999,"firstId":3220151555,"lastId":3220849281,"count":697727}"#).unwrap();
            let expected_response : models::TickerTradingDayResponse = serde_json::from_value(resp_json.clone()).expect("should parse into models::TickerTradingDayResponse");

            let resp = client.ticker_trading_day(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ticker_trading_day_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: true };

            let params = TickerTradingDayParams::builder().build().unwrap();

            match client.ticker_trading_day(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }

    #[test]
    fn ui_klines_required_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = UiKlinesParams::builder("BNBUSDT".to_string(),UiKlinesIntervalEnum::Interval1s,).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[[1499040000000,"0.01634790","0.80000000","0.01575800","0.01577100","148976.11427815",1499644799999,"2434.19055334",308,"1756.87402397","28.46694368","0"]]"#).unwrap();
            let expected_response : Vec<Vec<models::KlinesItemInner>> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<Vec<models::KlinesItemInner>>");

            let resp = client.ui_klines(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ui_klines_optional_params_success() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: false };

            let params = UiKlinesParams::builder("BNBUSDT".to_string(),UiKlinesIntervalEnum::Interval1s,).start_time(1735693200000).end_time(1735693200000).time_zone("time_zone_example".to_string()).limit(500).build().unwrap();

            let resp_json: Value = serde_json::from_str(r#"[[1499040000000,"0.01634790","0.80000000","0.01575800","0.01577100","148976.11427815",1499644799999,"2434.19055334",308,"1756.87402397","28.46694368","0"]]"#).unwrap();
            let expected_response : Vec<Vec<models::KlinesItemInner>> = serde_json::from_value(resp_json.clone()).expect("should parse into Vec<Vec<models::KlinesItemInner>>");

            let resp = client.ui_klines(params).await.expect("Expected a response");
            let data_future = resp.data();
            let actual_response = data_future.await.unwrap();
            assert_eq!(actual_response, expected_response);
        });
    }

    #[test]
    fn ui_klines_response_error() {
        TOKIO_SHARED_RT.block_on(async {
            let client = MockMarketApiClient { force_error: true };

            let params =
                UiKlinesParams::builder("BNBUSDT".to_string(), UiKlinesIntervalEnum::Interval1s)
                    .build()
                    .unwrap();

            match client.ui_klines(params).await {
                Ok(_) => panic!("Expected an error"),
                Err(err) => {
                    assert_eq!(err.to_string(), "Connector client error: ResponseError");
                }
            }
        });
    }
}
